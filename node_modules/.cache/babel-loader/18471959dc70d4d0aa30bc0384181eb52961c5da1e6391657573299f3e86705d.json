{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _indexOf = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/index-of\"));\nvar _map = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/map\"));\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/keys\"));\nvar _stringify = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/json/stringify\"));\nvar _forEach = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/for-each\"));\nvar _values = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/values\"));\nvar _setTimeout2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/set-timeout\"));\nvar _map2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/map\"));\nvar _bind = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/bind\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\nvar _LiveQuerySubscription = _interopRequireDefault(require(\"./LiveQuerySubscription\"));\nvar _promiseUtils = require(\"./promiseUtils\");\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\n// The LiveQuery client inner state\nconst CLIENT_STATE = {\n  INITIALIZED: 'initialized',\n  CONNECTING: 'connecting',\n  CONNECTED: 'connected',\n  CLOSED: 'closed',\n  RECONNECTING: 'reconnecting',\n  DISCONNECTED: 'disconnected'\n};\n\n// The event type the LiveQuery client should sent to server\nconst OP_TYPES = {\n  CONNECT: 'connect',\n  SUBSCRIBE: 'subscribe',\n  UNSUBSCRIBE: 'unsubscribe',\n  ERROR: 'error',\n  QUERY: 'query'\n};\n\n// The event we get back from LiveQuery server\nconst OP_EVENTS = {\n  CONNECTED: 'connected',\n  SUBSCRIBED: 'subscribed',\n  UNSUBSCRIBED: 'unsubscribed',\n  ERROR: 'error',\n  CREATE: 'create',\n  UPDATE: 'update',\n  ENTER: 'enter',\n  LEAVE: 'leave',\n  DELETE: 'delete',\n  RESULT: 'result'\n};\n\n// The event the LiveQuery client should emit\nconst CLIENT_EMMITER_TYPES = {\n  CLOSE: 'close',\n  ERROR: 'error',\n  OPEN: 'open'\n};\n\n// The event the LiveQuery subscription should emit\nconst SUBSCRIPTION_EMMITER_TYPES = {\n  OPEN: 'open',\n  CLOSE: 'close',\n  ERROR: 'error',\n  CREATE: 'create',\n  UPDATE: 'update',\n  ENTER: 'enter',\n  LEAVE: 'leave',\n  DELETE: 'delete',\n  RESULT: 'result'\n};\n\n// Exponentially-growing random delay\nconst generateInterval = k => {\n  return Math.random() * Math.min(30, Math.pow(2, k) - 1) * 1000;\n};\n\n/**\n * Creates a new LiveQueryClient.\n * <a href=\"https://nodejs.org/api/events.html#events_class_eventemitter\">cloud functions</a>.\n *\n * A wrapper of a standard WebSocket client. We add several useful methods to\n * help you connect/disconnect to LiveQueryServer, subscribe/unsubscribe a ParseQuery easily.\n *\n * javascriptKey and masterKey are used for verifying the LiveQueryClient when it tries\n * to connect to the LiveQuery server\n *\n * We expose three events to help you monitor the status of the LiveQueryClient.\n *\n * <pre>\n * const LiveQueryClient = Parse.LiveQueryClient;\n * const client = new LiveQueryClient({\n *   applicationId: '',\n *   serverURL: '',\n *   javascriptKey: '',\n *   masterKey: ''\n *  });\n * </pre>\n *\n * Open - When we establish the WebSocket connection to the LiveQuery server, you'll get this event.\n * <pre>\n * client.on('open', () => {\n *\n * });</pre>\n *\n * Close - When we lose the WebSocket connection to the LiveQuery server, you'll get this event.\n * <pre>\n * client.on('close', () => {\n *\n * });</pre>\n *\n * Error - When some network error or LiveQuery server error happens, you'll get this event.\n * <pre>\n * client.on('error', (error) => {\n *\n * });</pre>\n *\n * @alias Parse.LiveQueryClient\n */\nclass LiveQueryClient {\n  /**\n   * Creates a new LiveQueryClient instance.\n   *\n   * @param options - Configuration options for the LiveQuery client\n   * @param options.applicationId - The applicationId of your Parse app\n   * @param options.serverURL - The URL of your LiveQuery server (must start with 'ws' or 'wss')\n   * @param options.javascriptKey - (Optional) The JavaScript key for your Parse app\n   * @param options.masterKey - (Optional) Your Parse Master Key (Node.js only!)\n   * @param options.sessionToken - (Optional) Session token for authenticated requests\n   * @param options.installationId - (Optional) Installation ID for the client\n   */\n  constructor(_ref) {\n    var _this = this;\n    let {\n      applicationId,\n      serverURL,\n      javascriptKey,\n      masterKey,\n      sessionToken,\n      installationId\n    } = _ref;\n    (0, _defineProperty2.default)(this, \"attempts\", void 0);\n    (0, _defineProperty2.default)(this, \"id\", void 0);\n    (0, _defineProperty2.default)(this, \"requestId\", void 0);\n    (0, _defineProperty2.default)(this, \"applicationId\", void 0);\n    (0, _defineProperty2.default)(this, \"serverURL\", void 0);\n    (0, _defineProperty2.default)(this, \"javascriptKey\", void 0);\n    (0, _defineProperty2.default)(this, \"masterKey\", void 0);\n    (0, _defineProperty2.default)(this, \"sessionToken\", void 0);\n    (0, _defineProperty2.default)(this, \"installationId\", void 0);\n    (0, _defineProperty2.default)(this, \"additionalProperties\", void 0);\n    (0, _defineProperty2.default)(this, \"connectPromise\", void 0);\n    (0, _defineProperty2.default)(this, \"subscriptions\", void 0);\n    (0, _defineProperty2.default)(this, \"socket\", void 0);\n    (0, _defineProperty2.default)(this, \"state\", void 0);\n    (0, _defineProperty2.default)(this, \"reconnectHandle\", void 0);\n    (0, _defineProperty2.default)(this, \"emitter\", void 0);\n    (0, _defineProperty2.default)(this, \"on\", void 0);\n    (0, _defineProperty2.default)(this, \"emit\", void 0);\n    if (!serverURL || (0, _indexOf.default)(serverURL).call(serverURL, 'ws') !== 0) {\n      throw new Error('You need to set a proper Parse LiveQuery server url before using LiveQueryClient');\n    }\n    this.reconnectHandle = null;\n    this.attempts = 1;\n    this.id = 0;\n    this.requestId = 1;\n    this.serverURL = serverURL;\n    this.applicationId = applicationId;\n    this.javascriptKey = javascriptKey || undefined;\n    this.masterKey = masterKey || undefined;\n    this.sessionToken = sessionToken || undefined;\n    this.installationId = installationId || undefined;\n    this.additionalProperties = true;\n    this.connectPromise = (0, _promiseUtils.resolvingPromise)();\n    this.subscriptions = new _map.default();\n    this.state = CLIENT_STATE.INITIALIZED;\n    const EventEmitter = _CoreManager.default.getEventEmitter();\n    this.emitter = new EventEmitter();\n    this.on = (eventName, listener) => this.emitter.on(eventName, listener);\n    this.emit = function (eventName) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      return _this.emitter.emit(eventName, ...args);\n    };\n    // adding listener so process does not crash\n    // best practice is for developer to register their own listener\n    this.on('error', () => {});\n  }\n  shouldOpen() {\n    return this.state === CLIENT_STATE.INITIALIZED || this.state === CLIENT_STATE.DISCONNECTED;\n  }\n\n  /**\n   * Subscribes to a ParseQuery\n   *\n   * If you provide the sessionToken, when the LiveQuery server gets ParseObject's\n   * updates from parse server, it'll try to check whether the sessionToken fulfills\n   * the ParseObject's ACL. The LiveQuery server will only send updates to clients whose\n   * sessionToken is fit for the ParseObject's ACL. You can check the LiveQuery protocol\n   * <a href=\"https://github.com/parse-community/parse-server/wiki/Parse-LiveQuery-Protocol-Specification\">here</a> for more details. The subscription you get is the same subscription you get\n   * from our Standard API.\n   *\n   * @param {ParseQuery} query - the ParseQuery you want to subscribe to\n   * @param {string} sessionToken (optional)\n   * @returns {LiveQuerySubscription | undefined}\n   */\n  subscribe(query, sessionToken) {\n    if (!query) {\n      return;\n    }\n    const className = query.className;\n    const queryJSON = query.toJSON();\n    const where = queryJSON.where;\n    const keys = (0, _keys.default)(queryJSON)?.split(',');\n    const watch = queryJSON.watch?.split(',');\n    const subscribeRequest = {\n      op: OP_TYPES.SUBSCRIBE,\n      requestId: this.requestId,\n      query: {\n        className,\n        where,\n        keys,\n        watch\n      },\n      sessionToken: undefined\n    };\n    if (sessionToken) {\n      subscribeRequest.sessionToken = sessionToken;\n    }\n    const subscription = new _LiveQuerySubscription.default(this.requestId, query, sessionToken, this);\n    this.subscriptions.set(this.requestId, subscription);\n    this.requestId += 1;\n    this.connectPromise.then(() => {\n      this.socket.send((0, _stringify.default)(subscribeRequest));\n    }).catch(error => {\n      subscription.subscribePromise.reject(error);\n    });\n    return subscription;\n  }\n\n  /**\n   * After calling unsubscribe you'll stop receiving events from the subscription object.\n   *\n   * @param {object} subscription - subscription you would like to unsubscribe from.\n   * @returns {Promise | undefined}\n   */\n  async unsubscribe(subscription) {\n    if (!subscription) {\n      return;\n    }\n    const unsubscribeRequest = {\n      op: OP_TYPES.UNSUBSCRIBE,\n      requestId: subscription.id\n    };\n    return this.connectPromise.then(() => {\n      return this.socket.send((0, _stringify.default)(unsubscribeRequest));\n    }).then(() => {\n      return subscription.unsubscribePromise;\n    });\n  }\n\n  /**\n   * After open is called, the LiveQueryClient will try to send a connect request\n   * to the LiveQuery server.\n   *\n   */\n  open() {\n    const WebSocketImplementation = _CoreManager.default.getWebSocketController();\n    if (!WebSocketImplementation) {\n      this.emit(CLIENT_EMMITER_TYPES.ERROR, 'Can not find WebSocket implementation');\n      return;\n    }\n    if (this.state !== CLIENT_STATE.RECONNECTING) {\n      this.state = CLIENT_STATE.CONNECTING;\n    }\n    this.socket = new WebSocketImplementation(this.serverURL);\n    this.socket.closingPromise = (0, _promiseUtils.resolvingPromise)();\n\n    // Bind WebSocket callbacks\n    this.socket.onopen = () => {\n      this._handleWebSocketOpen();\n    };\n    this.socket.onmessage = event => {\n      this._handleWebSocketMessage(event);\n    };\n    this.socket.onclose = event => {\n      this.socket.closingPromise?.resolve(event);\n      this._handleWebSocketClose();\n    };\n    this.socket.onerror = error => {\n      this._handleWebSocketError(error);\n    };\n  }\n  resubscribe() {\n    var _context;\n    (0, _forEach.default)(_context = this.subscriptions).call(_context, (subscription, requestId) => {\n      const query = subscription.query;\n      const queryJSON = query.toJSON();\n      const where = queryJSON.where;\n      const keys = (0, _keys.default)(queryJSON)?.split(',');\n      const watch = queryJSON.watch?.split(',');\n      const className = query.className;\n      const sessionToken = subscription.sessionToken;\n      const subscribeRequest = {\n        op: OP_TYPES.SUBSCRIBE,\n        requestId,\n        query: {\n          className,\n          where,\n          keys,\n          watch\n        },\n        sessionToken: undefined\n      };\n      if (sessionToken) {\n        subscribeRequest.sessionToken = sessionToken;\n      }\n      this.connectPromise.then(() => {\n        this.socket.send((0, _stringify.default)(subscribeRequest));\n      });\n    });\n  }\n\n  /**\n   * This method will close the WebSocket connection to this LiveQueryClient,\n   * cancel the auto reconnect and unsubscribe all subscriptions based on it.\n   *\n   * @returns {Promise | undefined} CloseEvent {@link https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/close_event}\n   */\n  async close() {\n    if (this.state === CLIENT_STATE.INITIALIZED || this.state === CLIENT_STATE.DISCONNECTED) {\n      return;\n    }\n    this.state = CLIENT_STATE.DISCONNECTED;\n    this.socket?.close();\n    // Notify each subscription about the close\n    for (const subscription of (0, _values.default)(_context2 = this.subscriptions).call(_context2)) {\n      var _context2;\n      subscription.subscribed = false;\n      subscription.emit(SUBSCRIPTION_EMMITER_TYPES.CLOSE);\n    }\n    this._handleReset();\n    this.emit(CLIENT_EMMITER_TYPES.CLOSE);\n    return this.socket?.closingPromise;\n  }\n\n  // ensure we start with valid state if connect is called again after close\n  _handleReset() {\n    this.attempts = 1;\n    this.id = 0;\n    this.requestId = 1;\n    this.connectPromise = (0, _promiseUtils.resolvingPromise)();\n    this.subscriptions = new _map.default();\n  }\n  _handleWebSocketOpen() {\n    const connectRequest = {\n      op: OP_TYPES.CONNECT,\n      applicationId: this.applicationId,\n      javascriptKey: this.javascriptKey,\n      masterKey: this.masterKey,\n      sessionToken: this.sessionToken,\n      installationId: undefined\n    };\n    if (this.additionalProperties) {\n      connectRequest.installationId = this.installationId;\n    }\n    this.socket.send((0, _stringify.default)(connectRequest));\n  }\n  _handleWebSocketMessage(event) {\n    let data = event.data;\n    if (typeof data === 'string') {\n      data = JSON.parse(data);\n    }\n    let subscription = null;\n    if (data.requestId) {\n      subscription = this.subscriptions.get(data.requestId) || null;\n    }\n    const response = {\n      clientId: data.clientId,\n      installationId: data.installationId\n    };\n    switch (data.op) {\n      case OP_EVENTS.CONNECTED:\n        if (this.state === CLIENT_STATE.RECONNECTING) {\n          this.resubscribe();\n        }\n        this.emit(CLIENT_EMMITER_TYPES.OPEN);\n        this.id = data.clientId;\n        this.connectPromise.resolve();\n        this.state = CLIENT_STATE.CONNECTED;\n        break;\n      case OP_EVENTS.SUBSCRIBED:\n        if (subscription) {\n          this.attempts = 1;\n          subscription.subscribed = true;\n          subscription.subscribePromise.resolve();\n          (0, _setTimeout2.default)(() => subscription.emit(SUBSCRIPTION_EMMITER_TYPES.OPEN, response), 200);\n        }\n        break;\n      case OP_EVENTS.ERROR:\n        {\n          const parseError = new _ParseError.default(data.code, data.error);\n          if (!this.id) {\n            this.connectPromise.reject(parseError);\n            this.state = CLIENT_STATE.DISCONNECTED;\n          }\n          if (data.requestId) {\n            if (subscription) {\n              subscription.subscribePromise.reject(parseError);\n              (0, _setTimeout2.default)(() => subscription.emit(SUBSCRIPTION_EMMITER_TYPES.ERROR, data.error), 200);\n            }\n          } else {\n            this.emit(CLIENT_EMMITER_TYPES.ERROR, data.error);\n          }\n          if (data.error === 'Additional properties not allowed') {\n            this.additionalProperties = false;\n          }\n          if (data.reconnect) {\n            this._handleReconnect();\n          }\n          break;\n        }\n      case OP_EVENTS.UNSUBSCRIBED:\n        {\n          if (subscription) {\n            this.subscriptions.delete(data.requestId);\n            subscription.subscribed = false;\n            subscription.unsubscribePromise.resolve();\n          }\n          break;\n        }\n      case OP_EVENTS.RESULT:\n        {\n          if (subscription) {\n            var _context3;\n            const objects = (0, _map2.default)(_context3 = data.results).call(_context3, json => {\n              if (!json.className && subscription.query) {\n                json.className = subscription.query.className;\n              }\n              return _ParseObject.default.fromJSON(json, false);\n            });\n            subscription.emit(SUBSCRIPTION_EMMITER_TYPES.RESULT, objects);\n          }\n          break;\n        }\n      default:\n        {\n          // create, update, enter, leave, delete cases\n          if (!subscription) {\n            break;\n          }\n          let override = false;\n          if (data.original) {\n            override = true;\n            delete data.original.__type;\n            // Check for removed fields\n            for (const field in data.original) {\n              if (!(field in data.object)) {\n                data.object[field] = undefined;\n              }\n            }\n            data.original = _ParseObject.default.fromJSON(data.original, false);\n          }\n          delete data.object.__type;\n          const parseObject = _ParseObject.default.fromJSON(data.object, !(subscription.query && subscription.query._select) ? override : false);\n          if (data.original) {\n            subscription.emit(data.op, parseObject, data.original, response);\n          } else {\n            subscription.emit(data.op, parseObject, response);\n          }\n          const localDatastore = _CoreManager.default.getLocalDatastore();\n          if (override && localDatastore.isEnabled) {\n            localDatastore._updateObjectIfPinned(parseObject).then(() => {});\n          }\n        }\n    }\n  }\n  _handleWebSocketClose() {\n    if (this.state === CLIENT_STATE.DISCONNECTED) {\n      return;\n    }\n    this.state = CLIENT_STATE.CLOSED;\n    this.emit(CLIENT_EMMITER_TYPES.CLOSE);\n    // Notify each subscription about the close\n    for (const subscription of (0, _values.default)(_context4 = this.subscriptions).call(_context4)) {\n      var _context4;\n      subscription.emit(SUBSCRIPTION_EMMITER_TYPES.CLOSE);\n    }\n    this._handleReconnect();\n  }\n  _handleWebSocketError(error) {\n    this.emit(CLIENT_EMMITER_TYPES.ERROR, error);\n    for (const subscription of (0, _values.default)(_context5 = this.subscriptions).call(_context5)) {\n      var _context5;\n      subscription.emit(SUBSCRIPTION_EMMITER_TYPES.ERROR, error);\n    }\n    this._handleReconnect();\n  }\n  _handleReconnect() {\n    var _context6;\n    // if closed or currently reconnecting we stop attempting to reconnect\n    if (this.state === CLIENT_STATE.DISCONNECTED) {\n      return;\n    }\n    this.state = CLIENT_STATE.RECONNECTING;\n    const time = generateInterval(this.attempts);\n\n    // handle case when both close/error occur at frequent rates we ensure we do not reconnect unnecessarily.\n    // we're unable to distinguish different between close/error when we're unable to reconnect therefore\n    // we try to reconnect in both cases\n    // server side ws and browser WebSocket behave differently in when close/error get triggered\n    if (this.reconnectHandle) {\n      clearTimeout(this.reconnectHandle);\n    }\n    this.reconnectHandle = (0, _setTimeout2.default)((0, _bind.default)(_context6 = () => {\n      this.attempts++;\n      this.connectPromise = (0, _promiseUtils.resolvingPromise)();\n      this.open();\n    }).call(_context6, this), time);\n  }\n}\nvar _default = exports.default = LiveQueryClient;","map":{"version":3,"names":["_Object$defineProperty","require","_interopRequireDefault","exports","value","default","_indexOf","_map","_keys","_stringify","_forEach","_values","_setTimeout2","_map2","_bind","_defineProperty2","_CoreManager","_ParseObject","_LiveQuerySubscription","_promiseUtils","_ParseError","CLIENT_STATE","INITIALIZED","CONNECTING","CONNECTED","CLOSED","RECONNECTING","DISCONNECTED","OP_TYPES","CONNECT","SUBSCRIBE","UNSUBSCRIBE","ERROR","QUERY","OP_EVENTS","SUBSCRIBED","UNSUBSCRIBED","CREATE","UPDATE","ENTER","LEAVE","DELETE","RESULT","CLIENT_EMMITER_TYPES","CLOSE","OPEN","SUBSCRIPTION_EMMITER_TYPES","generateInterval","k","Math","random","min","pow","LiveQueryClient","constructor","_ref","_this","applicationId","serverURL","javascriptKey","masterKey","sessionToken","installationId","call","Error","reconnectHandle","attempts","id","requestId","undefined","additionalProperties","connectPromise","resolvingPromise","subscriptions","state","EventEmitter","getEventEmitter","emitter","on","eventName","listener","emit","_len","arguments","length","args","Array","_key","shouldOpen","subscribe","query","className","queryJSON","toJSON","where","keys","split","watch","subscribeRequest","op","subscription","set","then","socket","send","catch","error","subscribePromise","reject","unsubscribe","unsubscribeRequest","unsubscribePromise","open","WebSocketImplementation","getWebSocketController","closingPromise","onopen","_handleWebSocketOpen","onmessage","event","_handleWebSocketMessage","onclose","resolve","_handleWebSocketClose","onerror","_handleWebSocketError","resubscribe","_context","close","_context2","subscribed","_handleReset","connectRequest","data","JSON","parse","get","response","clientId","parseError","code","reconnect","_handleReconnect","delete","_context3","objects","results","json","fromJSON","override","original","__type","field","object","parseObject","_select","localDatastore","getLocalDatastore","isEnabled","_updateObjectIfPinned","_context4","_context5","_context6","time","clearTimeout","_default"],"sources":["/home/snx/Desktop/CS_School/node_modules/parse/lib/browser/LiveQueryClient.js"],"sourcesContent":["\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _indexOf = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/index-of\"));\nvar _map = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/map\"));\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/keys\"));\nvar _stringify = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/json/stringify\"));\nvar _forEach = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/for-each\"));\nvar _values = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/values\"));\nvar _setTimeout2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/set-timeout\"));\nvar _map2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/map\"));\nvar _bind = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/bind\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\nvar _LiveQuerySubscription = _interopRequireDefault(require(\"./LiveQuerySubscription\"));\nvar _promiseUtils = require(\"./promiseUtils\");\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\n// The LiveQuery client inner state\nconst CLIENT_STATE = {\n  INITIALIZED: 'initialized',\n  CONNECTING: 'connecting',\n  CONNECTED: 'connected',\n  CLOSED: 'closed',\n  RECONNECTING: 'reconnecting',\n  DISCONNECTED: 'disconnected'\n};\n\n// The event type the LiveQuery client should sent to server\nconst OP_TYPES = {\n  CONNECT: 'connect',\n  SUBSCRIBE: 'subscribe',\n  UNSUBSCRIBE: 'unsubscribe',\n  ERROR: 'error',\n  QUERY: 'query'\n};\n\n// The event we get back from LiveQuery server\nconst OP_EVENTS = {\n  CONNECTED: 'connected',\n  SUBSCRIBED: 'subscribed',\n  UNSUBSCRIBED: 'unsubscribed',\n  ERROR: 'error',\n  CREATE: 'create',\n  UPDATE: 'update',\n  ENTER: 'enter',\n  LEAVE: 'leave',\n  DELETE: 'delete',\n  RESULT: 'result'\n};\n\n// The event the LiveQuery client should emit\nconst CLIENT_EMMITER_TYPES = {\n  CLOSE: 'close',\n  ERROR: 'error',\n  OPEN: 'open'\n};\n\n// The event the LiveQuery subscription should emit\nconst SUBSCRIPTION_EMMITER_TYPES = {\n  OPEN: 'open',\n  CLOSE: 'close',\n  ERROR: 'error',\n  CREATE: 'create',\n  UPDATE: 'update',\n  ENTER: 'enter',\n  LEAVE: 'leave',\n  DELETE: 'delete',\n  RESULT: 'result'\n};\n\n// Exponentially-growing random delay\nconst generateInterval = k => {\n  return Math.random() * Math.min(30, Math.pow(2, k) - 1) * 1000;\n};\n\n/**\n * Creates a new LiveQueryClient.\n * <a href=\"https://nodejs.org/api/events.html#events_class_eventemitter\">cloud functions</a>.\n *\n * A wrapper of a standard WebSocket client. We add several useful methods to\n * help you connect/disconnect to LiveQueryServer, subscribe/unsubscribe a ParseQuery easily.\n *\n * javascriptKey and masterKey are used for verifying the LiveQueryClient when it tries\n * to connect to the LiveQuery server\n *\n * We expose three events to help you monitor the status of the LiveQueryClient.\n *\n * <pre>\n * const LiveQueryClient = Parse.LiveQueryClient;\n * const client = new LiveQueryClient({\n *   applicationId: '',\n *   serverURL: '',\n *   javascriptKey: '',\n *   masterKey: ''\n *  });\n * </pre>\n *\n * Open - When we establish the WebSocket connection to the LiveQuery server, you'll get this event.\n * <pre>\n * client.on('open', () => {\n *\n * });</pre>\n *\n * Close - When we lose the WebSocket connection to the LiveQuery server, you'll get this event.\n * <pre>\n * client.on('close', () => {\n *\n * });</pre>\n *\n * Error - When some network error or LiveQuery server error happens, you'll get this event.\n * <pre>\n * client.on('error', (error) => {\n *\n * });</pre>\n *\n * @alias Parse.LiveQueryClient\n */\nclass LiveQueryClient {\n  /**\n   * Creates a new LiveQueryClient instance.\n   *\n   * @param options - Configuration options for the LiveQuery client\n   * @param options.applicationId - The applicationId of your Parse app\n   * @param options.serverURL - The URL of your LiveQuery server (must start with 'ws' or 'wss')\n   * @param options.javascriptKey - (Optional) The JavaScript key for your Parse app\n   * @param options.masterKey - (Optional) Your Parse Master Key (Node.js only!)\n   * @param options.sessionToken - (Optional) Session token for authenticated requests\n   * @param options.installationId - (Optional) Installation ID for the client\n   */\n  constructor(_ref) {\n    var _this = this;\n    let {\n      applicationId,\n      serverURL,\n      javascriptKey,\n      masterKey,\n      sessionToken,\n      installationId\n    } = _ref;\n    (0, _defineProperty2.default)(this, \"attempts\", void 0);\n    (0, _defineProperty2.default)(this, \"id\", void 0);\n    (0, _defineProperty2.default)(this, \"requestId\", void 0);\n    (0, _defineProperty2.default)(this, \"applicationId\", void 0);\n    (0, _defineProperty2.default)(this, \"serverURL\", void 0);\n    (0, _defineProperty2.default)(this, \"javascriptKey\", void 0);\n    (0, _defineProperty2.default)(this, \"masterKey\", void 0);\n    (0, _defineProperty2.default)(this, \"sessionToken\", void 0);\n    (0, _defineProperty2.default)(this, \"installationId\", void 0);\n    (0, _defineProperty2.default)(this, \"additionalProperties\", void 0);\n    (0, _defineProperty2.default)(this, \"connectPromise\", void 0);\n    (0, _defineProperty2.default)(this, \"subscriptions\", void 0);\n    (0, _defineProperty2.default)(this, \"socket\", void 0);\n    (0, _defineProperty2.default)(this, \"state\", void 0);\n    (0, _defineProperty2.default)(this, \"reconnectHandle\", void 0);\n    (0, _defineProperty2.default)(this, \"emitter\", void 0);\n    (0, _defineProperty2.default)(this, \"on\", void 0);\n    (0, _defineProperty2.default)(this, \"emit\", void 0);\n    if (!serverURL || (0, _indexOf.default)(serverURL).call(serverURL, 'ws') !== 0) {\n      throw new Error('You need to set a proper Parse LiveQuery server url before using LiveQueryClient');\n    }\n    this.reconnectHandle = null;\n    this.attempts = 1;\n    this.id = 0;\n    this.requestId = 1;\n    this.serverURL = serverURL;\n    this.applicationId = applicationId;\n    this.javascriptKey = javascriptKey || undefined;\n    this.masterKey = masterKey || undefined;\n    this.sessionToken = sessionToken || undefined;\n    this.installationId = installationId || undefined;\n    this.additionalProperties = true;\n    this.connectPromise = (0, _promiseUtils.resolvingPromise)();\n    this.subscriptions = new _map.default();\n    this.state = CLIENT_STATE.INITIALIZED;\n    const EventEmitter = _CoreManager.default.getEventEmitter();\n    this.emitter = new EventEmitter();\n    this.on = (eventName, listener) => this.emitter.on(eventName, listener);\n    this.emit = function (eventName) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      return _this.emitter.emit(eventName, ...args);\n    };\n    // adding listener so process does not crash\n    // best practice is for developer to register their own listener\n    this.on('error', () => {});\n  }\n  shouldOpen() {\n    return this.state === CLIENT_STATE.INITIALIZED || this.state === CLIENT_STATE.DISCONNECTED;\n  }\n\n  /**\n   * Subscribes to a ParseQuery\n   *\n   * If you provide the sessionToken, when the LiveQuery server gets ParseObject's\n   * updates from parse server, it'll try to check whether the sessionToken fulfills\n   * the ParseObject's ACL. The LiveQuery server will only send updates to clients whose\n   * sessionToken is fit for the ParseObject's ACL. You can check the LiveQuery protocol\n   * <a href=\"https://github.com/parse-community/parse-server/wiki/Parse-LiveQuery-Protocol-Specification\">here</a> for more details. The subscription you get is the same subscription you get\n   * from our Standard API.\n   *\n   * @param {ParseQuery} query - the ParseQuery you want to subscribe to\n   * @param {string} sessionToken (optional)\n   * @returns {LiveQuerySubscription | undefined}\n   */\n  subscribe(query, sessionToken) {\n    if (!query) {\n      return;\n    }\n    const className = query.className;\n    const queryJSON = query.toJSON();\n    const where = queryJSON.where;\n    const keys = (0, _keys.default)(queryJSON)?.split(',');\n    const watch = queryJSON.watch?.split(',');\n    const subscribeRequest = {\n      op: OP_TYPES.SUBSCRIBE,\n      requestId: this.requestId,\n      query: {\n        className,\n        where,\n        keys,\n        watch\n      },\n      sessionToken: undefined\n    };\n    if (sessionToken) {\n      subscribeRequest.sessionToken = sessionToken;\n    }\n    const subscription = new _LiveQuerySubscription.default(this.requestId, query, sessionToken, this);\n    this.subscriptions.set(this.requestId, subscription);\n    this.requestId += 1;\n    this.connectPromise.then(() => {\n      this.socket.send((0, _stringify.default)(subscribeRequest));\n    }).catch(error => {\n      subscription.subscribePromise.reject(error);\n    });\n    return subscription;\n  }\n\n  /**\n   * After calling unsubscribe you'll stop receiving events from the subscription object.\n   *\n   * @param {object} subscription - subscription you would like to unsubscribe from.\n   * @returns {Promise | undefined}\n   */\n  async unsubscribe(subscription) {\n    if (!subscription) {\n      return;\n    }\n    const unsubscribeRequest = {\n      op: OP_TYPES.UNSUBSCRIBE,\n      requestId: subscription.id\n    };\n    return this.connectPromise.then(() => {\n      return this.socket.send((0, _stringify.default)(unsubscribeRequest));\n    }).then(() => {\n      return subscription.unsubscribePromise;\n    });\n  }\n\n  /**\n   * After open is called, the LiveQueryClient will try to send a connect request\n   * to the LiveQuery server.\n   *\n   */\n  open() {\n    const WebSocketImplementation = _CoreManager.default.getWebSocketController();\n    if (!WebSocketImplementation) {\n      this.emit(CLIENT_EMMITER_TYPES.ERROR, 'Can not find WebSocket implementation');\n      return;\n    }\n    if (this.state !== CLIENT_STATE.RECONNECTING) {\n      this.state = CLIENT_STATE.CONNECTING;\n    }\n    this.socket = new WebSocketImplementation(this.serverURL);\n    this.socket.closingPromise = (0, _promiseUtils.resolvingPromise)();\n\n    // Bind WebSocket callbacks\n    this.socket.onopen = () => {\n      this._handleWebSocketOpen();\n    };\n    this.socket.onmessage = event => {\n      this._handleWebSocketMessage(event);\n    };\n    this.socket.onclose = event => {\n      this.socket.closingPromise?.resolve(event);\n      this._handleWebSocketClose();\n    };\n    this.socket.onerror = error => {\n      this._handleWebSocketError(error);\n    };\n  }\n  resubscribe() {\n    var _context;\n    (0, _forEach.default)(_context = this.subscriptions).call(_context, (subscription, requestId) => {\n      const query = subscription.query;\n      const queryJSON = query.toJSON();\n      const where = queryJSON.where;\n      const keys = (0, _keys.default)(queryJSON)?.split(',');\n      const watch = queryJSON.watch?.split(',');\n      const className = query.className;\n      const sessionToken = subscription.sessionToken;\n      const subscribeRequest = {\n        op: OP_TYPES.SUBSCRIBE,\n        requestId,\n        query: {\n          className,\n          where,\n          keys,\n          watch\n        },\n        sessionToken: undefined\n      };\n      if (sessionToken) {\n        subscribeRequest.sessionToken = sessionToken;\n      }\n      this.connectPromise.then(() => {\n        this.socket.send((0, _stringify.default)(subscribeRequest));\n      });\n    });\n  }\n\n  /**\n   * This method will close the WebSocket connection to this LiveQueryClient,\n   * cancel the auto reconnect and unsubscribe all subscriptions based on it.\n   *\n   * @returns {Promise | undefined} CloseEvent {@link https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/close_event}\n   */\n  async close() {\n    if (this.state === CLIENT_STATE.INITIALIZED || this.state === CLIENT_STATE.DISCONNECTED) {\n      return;\n    }\n    this.state = CLIENT_STATE.DISCONNECTED;\n    this.socket?.close();\n    // Notify each subscription about the close\n    for (const subscription of (0, _values.default)(_context2 = this.subscriptions).call(_context2)) {\n      var _context2;\n      subscription.subscribed = false;\n      subscription.emit(SUBSCRIPTION_EMMITER_TYPES.CLOSE);\n    }\n    this._handleReset();\n    this.emit(CLIENT_EMMITER_TYPES.CLOSE);\n    return this.socket?.closingPromise;\n  }\n\n  // ensure we start with valid state if connect is called again after close\n  _handleReset() {\n    this.attempts = 1;\n    this.id = 0;\n    this.requestId = 1;\n    this.connectPromise = (0, _promiseUtils.resolvingPromise)();\n    this.subscriptions = new _map.default();\n  }\n  _handleWebSocketOpen() {\n    const connectRequest = {\n      op: OP_TYPES.CONNECT,\n      applicationId: this.applicationId,\n      javascriptKey: this.javascriptKey,\n      masterKey: this.masterKey,\n      sessionToken: this.sessionToken,\n      installationId: undefined\n    };\n    if (this.additionalProperties) {\n      connectRequest.installationId = this.installationId;\n    }\n    this.socket.send((0, _stringify.default)(connectRequest));\n  }\n  _handleWebSocketMessage(event) {\n    let data = event.data;\n    if (typeof data === 'string') {\n      data = JSON.parse(data);\n    }\n    let subscription = null;\n    if (data.requestId) {\n      subscription = this.subscriptions.get(data.requestId) || null;\n    }\n    const response = {\n      clientId: data.clientId,\n      installationId: data.installationId\n    };\n    switch (data.op) {\n      case OP_EVENTS.CONNECTED:\n        if (this.state === CLIENT_STATE.RECONNECTING) {\n          this.resubscribe();\n        }\n        this.emit(CLIENT_EMMITER_TYPES.OPEN);\n        this.id = data.clientId;\n        this.connectPromise.resolve();\n        this.state = CLIENT_STATE.CONNECTED;\n        break;\n      case OP_EVENTS.SUBSCRIBED:\n        if (subscription) {\n          this.attempts = 1;\n          subscription.subscribed = true;\n          subscription.subscribePromise.resolve();\n          (0, _setTimeout2.default)(() => subscription.emit(SUBSCRIPTION_EMMITER_TYPES.OPEN, response), 200);\n        }\n        break;\n      case OP_EVENTS.ERROR:\n        {\n          const parseError = new _ParseError.default(data.code, data.error);\n          if (!this.id) {\n            this.connectPromise.reject(parseError);\n            this.state = CLIENT_STATE.DISCONNECTED;\n          }\n          if (data.requestId) {\n            if (subscription) {\n              subscription.subscribePromise.reject(parseError);\n              (0, _setTimeout2.default)(() => subscription.emit(SUBSCRIPTION_EMMITER_TYPES.ERROR, data.error), 200);\n            }\n          } else {\n            this.emit(CLIENT_EMMITER_TYPES.ERROR, data.error);\n          }\n          if (data.error === 'Additional properties not allowed') {\n            this.additionalProperties = false;\n          }\n          if (data.reconnect) {\n            this._handleReconnect();\n          }\n          break;\n        }\n      case OP_EVENTS.UNSUBSCRIBED:\n        {\n          if (subscription) {\n            this.subscriptions.delete(data.requestId);\n            subscription.subscribed = false;\n            subscription.unsubscribePromise.resolve();\n          }\n          break;\n        }\n      case OP_EVENTS.RESULT:\n        {\n          if (subscription) {\n            var _context3;\n            const objects = (0, _map2.default)(_context3 = data.results).call(_context3, json => {\n              if (!json.className && subscription.query) {\n                json.className = subscription.query.className;\n              }\n              return _ParseObject.default.fromJSON(json, false);\n            });\n            subscription.emit(SUBSCRIPTION_EMMITER_TYPES.RESULT, objects);\n          }\n          break;\n        }\n      default:\n        {\n          // create, update, enter, leave, delete cases\n          if (!subscription) {\n            break;\n          }\n          let override = false;\n          if (data.original) {\n            override = true;\n            delete data.original.__type;\n            // Check for removed fields\n            for (const field in data.original) {\n              if (!(field in data.object)) {\n                data.object[field] = undefined;\n              }\n            }\n            data.original = _ParseObject.default.fromJSON(data.original, false);\n          }\n          delete data.object.__type;\n          const parseObject = _ParseObject.default.fromJSON(data.object, !(subscription.query && subscription.query._select) ? override : false);\n          if (data.original) {\n            subscription.emit(data.op, parseObject, data.original, response);\n          } else {\n            subscription.emit(data.op, parseObject, response);\n          }\n          const localDatastore = _CoreManager.default.getLocalDatastore();\n          if (override && localDatastore.isEnabled) {\n            localDatastore._updateObjectIfPinned(parseObject).then(() => {});\n          }\n        }\n    }\n  }\n  _handleWebSocketClose() {\n    if (this.state === CLIENT_STATE.DISCONNECTED) {\n      return;\n    }\n    this.state = CLIENT_STATE.CLOSED;\n    this.emit(CLIENT_EMMITER_TYPES.CLOSE);\n    // Notify each subscription about the close\n    for (const subscription of (0, _values.default)(_context4 = this.subscriptions).call(_context4)) {\n      var _context4;\n      subscription.emit(SUBSCRIPTION_EMMITER_TYPES.CLOSE);\n    }\n    this._handleReconnect();\n  }\n  _handleWebSocketError(error) {\n    this.emit(CLIENT_EMMITER_TYPES.ERROR, error);\n    for (const subscription of (0, _values.default)(_context5 = this.subscriptions).call(_context5)) {\n      var _context5;\n      subscription.emit(SUBSCRIPTION_EMMITER_TYPES.ERROR, error);\n    }\n    this._handleReconnect();\n  }\n  _handleReconnect() {\n    var _context6;\n    // if closed or currently reconnecting we stop attempting to reconnect\n    if (this.state === CLIENT_STATE.DISCONNECTED) {\n      return;\n    }\n    this.state = CLIENT_STATE.RECONNECTING;\n    const time = generateInterval(this.attempts);\n\n    // handle case when both close/error occur at frequent rates we ensure we do not reconnect unnecessarily.\n    // we're unable to distinguish different between close/error when we're unable to reconnect therefore\n    // we try to reconnect in both cases\n    // server side ws and browser WebSocket behave differently in when close/error get triggered\n    if (this.reconnectHandle) {\n      clearTimeout(this.reconnectHandle);\n    }\n    this.reconnectHandle = (0, _setTimeout2.default)((0, _bind.default)(_context6 = () => {\n      this.attempts++;\n      this.connectPromise = (0, _promiseUtils.resolvingPromise)();\n      this.open();\n    }).call(_context6, this), time);\n  }\n}\nvar _default = exports.default = LiveQueryClient;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}