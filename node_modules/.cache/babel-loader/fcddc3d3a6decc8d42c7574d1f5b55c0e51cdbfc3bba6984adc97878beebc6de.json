{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _stringify = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/json/stringify\"));\nvar _splice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/splice\"));\nvar _findIndex = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/find-index\"));\nvar _setInterval2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/set-interval\"));\nvar _find = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/find\"));\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\nvar _ParseQuery = _interopRequireDefault(require(\"./ParseQuery\"));\nvar _Storage = _interopRequireDefault(require(\"./Storage\"));\nconst QUEUE_KEY = 'Parse/Eventually/Queue';\nlet queueCache = [];\nlet dirtyCache = true;\nlet polling = undefined;\n\n/**\n * Provides utility functions to queue objects that will be\n * saved to the server at a later date.\n *\n * @class Parse.EventuallyQueue\n * @static\n */\nconst EventuallyQueue = {\n  /**\n   * Add object to queue with save operation.\n   *\n   * @function save\n   * @name Parse.EventuallyQueue.save\n   * @param {ParseObject} object Parse.Object to be saved eventually\n   * @param {object} [serverOptions] See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Object.html#save Parse.Object.save} options.\n   * @returns {Promise} A promise that is fulfilled if object is added to queue.\n   * @static\n   * @see Parse.Object#saveEventually\n   */\n  save(object, serverOptions) {\n    return this.enqueue('save', object, serverOptions);\n  },\n  /**\n   * Add object to queue with save operation.\n   *\n   * @function destroy\n   * @name Parse.EventuallyQueue.destroy\n   * @param {ParseObject} object Parse.Object to be destroyed eventually\n   * @param {object} [serverOptions] See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Object.html#destroy Parse.Object.destroy} options\n   * @returns {Promise} A promise that is fulfilled if object is added to queue.\n   * @static\n   * @see Parse.Object#destroyEventually\n   */\n  destroy(object, serverOptions) {\n    return this.enqueue('destroy', object, serverOptions);\n  },\n  /**\n   * Generate unique identifier to avoid duplicates and maintain previous state.\n   *\n   * @param {string} action save / destroy\n   * @param {object} object Parse.Object to be queued\n   * @returns {string}\n   * @static\n   * @ignore\n   */\n  generateQueueId(action, object) {\n    object._getId();\n    const {\n      className,\n      id,\n      _localId\n    } = object;\n    const uniqueId = object.get('hash') || _localId;\n    return [action, className, id, uniqueId].join('_');\n  },\n  /**\n   * Build queue object and add to queue.\n   *\n   * @param {string} action save / destroy\n   * @param {object} object Parse.Object to be queued\n   * @param {object} [serverOptions]\n   * @returns {Promise} A promise that is fulfilled if object is added to queue.\n   * @static\n   * @ignore\n   */\n  async enqueue(action, object, serverOptions) {\n    const queueData = await this.getQueue();\n    const queueId = this.generateQueueId(action, object);\n    let index = this.queueItemExists(queueData, queueId);\n    if (index > -1) {\n      // Add cached values to new object if they don't exist\n      for (const prop in queueData[index].object) {\n        if (typeof object.get(prop) === 'undefined') {\n          object.set(prop, queueData[index].object[prop]);\n        }\n      }\n    } else {\n      index = queueData.length;\n    }\n    queueData[index] = {\n      queueId,\n      action,\n      object: object.toJSON(),\n      serverOptions: serverOptions || {},\n      id: object.id,\n      className: object.className,\n      hash: object.get('hash'),\n      createdAt: new Date()\n    };\n    return this.setQueue(queueData);\n  },\n  store(data) {\n    return _Storage.default.setItemAsync(QUEUE_KEY, (0, _stringify.default)(data));\n  },\n  load() {\n    return _Storage.default.getItemAsync(QUEUE_KEY);\n  },\n  /**\n   * Sets the in-memory queue from local storage and returns.\n   *\n   * @function getQueue\n   * @name Parse.EventuallyQueue.getQueue\n   * @returns {Promise<Queue>}\n   * @static\n   */\n  async getQueue() {\n    if (dirtyCache) {\n      queueCache = JSON.parse((await this.load()) || '[]');\n      dirtyCache = false;\n    }\n    return queueCache;\n  },\n  /**\n   * Saves the queue to local storage\n   *\n   * @param {Queue} queue Queue containing Parse.Object data.\n   * @returns {Promise} A promise that is fulfilled when queue is stored.\n   * @static\n   * @ignore\n   */\n  setQueue(queue) {\n    queueCache = queue;\n    return this.store(queueCache);\n  },\n  /**\n   * Removes Parse.Object data from queue.\n   *\n   * @param {string} queueId Unique identifier for Parse.Object data.\n   * @returns {Promise} A promise that is fulfilled when queue is stored.\n   * @static\n   * @ignore\n   */\n  async remove(queueId) {\n    const queueData = await this.getQueue();\n    const index = this.queueItemExists(queueData, queueId);\n    if (index > -1) {\n      (0, _splice.default)(queueData).call(queueData, index, 1);\n      await this.setQueue(queueData);\n    }\n  },\n  /**\n   * Removes all objects from queue.\n   *\n   * @function clear\n   * @name Parse.EventuallyQueue.clear\n   * @returns {Promise} A promise that is fulfilled when queue is cleared.\n   * @static\n   */\n  clear() {\n    queueCache = [];\n    return this.store([]);\n  },\n  /**\n   * Return the index of a queueId in the queue. Returns -1 if not found.\n   *\n   * @param {Queue} queue Queue containing Parse.Object data.\n   * @param {string} queueId Unique identifier for Parse.Object data.\n   * @returns {number}\n   * @static\n   * @ignore\n   */\n  queueItemExists(queue, queueId) {\n    return (0, _findIndex.default)(queue).call(queue, data => data.queueId === queueId);\n  },\n  /**\n   * Return the number of objects in the queue.\n   *\n   * @function length\n   * @name Parse.EventuallyQueue.length\n   * @returns {Promise<number>}\n   * @static\n   */\n  async length() {\n    const queueData = await this.getQueue();\n    return queueData.length;\n  },\n  /**\n   * Sends the queue to the server.\n   *\n   * @function sendQueue\n   * @name Parse.EventuallyQueue.sendQueue\n   * @returns {Promise<boolean>} Returns true if queue was sent successfully.\n   * @static\n   */\n  async sendQueue() {\n    const queue = await this.getQueue();\n    const queueData = [...queue];\n    if (queueData.length === 0) {\n      return false;\n    }\n    for (let i = 0; i < queueData.length; i += 1) {\n      const queueObject = queueData[i];\n      const {\n        id,\n        hash,\n        className\n      } = queueObject;\n      const ObjectType = _ParseObject.default.extend(className);\n      if (id) {\n        await this.process.byId(ObjectType, queueObject);\n      } else if (hash) {\n        await this.process.byHash(ObjectType, queueObject);\n      } else {\n        await this.process.create(ObjectType, queueObject);\n      }\n    }\n    return true;\n  },\n  /**\n   * Build queue object and add to queue.\n   *\n   * @param {ParseObject} object Parse.Object to be processed\n   * @param {QueueObject} queueObject Parse.Object data from the queue\n   * @returns {Promise} A promise that is fulfilled when operation is performed.\n   * @static\n   * @ignore\n   */\n  async sendQueueCallback(object, queueObject) {\n    if (!object) {\n      return this.remove(queueObject.queueId);\n    }\n    switch (queueObject.action) {\n      case 'save':\n        // Queued update was overwritten by other request. Do not save\n        if (typeof object.updatedAt !== 'undefined' && object.updatedAt > new Date(queueObject.object.createdAt)) {\n          return this.remove(queueObject.queueId);\n        }\n        try {\n          await object.save(queueObject.object, queueObject.serverOptions);\n          await this.remove(queueObject.queueId);\n        } catch (e) {\n          if (e.code !== _ParseError.default.CONNECTION_FAILED) {\n            await this.remove(queueObject.queueId);\n          }\n        }\n        break;\n      case 'destroy':\n        try {\n          await object.destroy(queueObject.serverOptions);\n          await this.remove(queueObject.queueId);\n        } catch (e) {\n          if (e.code !== _ParseError.default.CONNECTION_FAILED) {\n            await this.remove(queueObject.queueId);\n          }\n        }\n        break;\n    }\n  },\n  /**\n   * Start polling server for network connection.\n   * Will send queue if connection is established.\n   *\n   * @function poll\n   * @name Parse.EventuallyQueue.poll\n   * @param [ms] Milliseconds to ping the server. Default 2000ms\n   * @static\n   */\n  poll(ms) {\n    if (polling) {\n      return;\n    }\n    polling = (0, _setInterval2.default)(() => {\n      const RESTController = _CoreManager.default.getRESTController();\n      RESTController.request('GET', 'health').then(_ref => {\n        let {\n          status\n        } = _ref;\n        if (status === 'ok') {\n          this.stopPoll();\n          return this.sendQueue();\n        }\n      }).catch(e => e);\n    }, ms || 2000);\n  },\n  /**\n   * Turns off polling.\n   *\n   * @function stopPoll\n   * @name Parse.EventuallyQueue.stopPoll\n   * @static\n   */\n  stopPoll() {\n    clearInterval(polling);\n    polling = undefined;\n  },\n  /**\n   * Return true if pinging the server.\n   *\n   * @function isPolling\n   * @name Parse.EventuallyQueue.isPolling\n   * @returns {boolean}\n   * @static\n   */\n  isPolling() {\n    return !!polling;\n  },\n  _setPolling(flag) {\n    polling = flag;\n  },\n  process: {\n    create(ObjectType, queueObject) {\n      const object = new ObjectType();\n      return EventuallyQueue.sendQueueCallback(object, queueObject);\n    },\n    async byId(ObjectType, queueObject) {\n      const {\n        sessionToken\n      } = queueObject.serverOptions;\n      const query = new _ParseQuery.default(ObjectType);\n      query.equalTo('objectId', queueObject.id);\n      const results = await (0, _find.default)(query).call(query, {\n        sessionToken\n      });\n      return EventuallyQueue.sendQueueCallback(results[0], queueObject);\n    },\n    async byHash(ObjectType, queueObject) {\n      const {\n        sessionToken\n      } = queueObject.serverOptions;\n      const query = new _ParseQuery.default(ObjectType);\n      query.equalTo('hash', queueObject.hash);\n      const results = await (0, _find.default)(query).call(query, {\n        sessionToken\n      });\n      if (results.length > 0) {\n        return EventuallyQueue.sendQueueCallback(results[0], queueObject);\n      }\n      return EventuallyQueue.process.create(ObjectType, queueObject);\n    }\n  }\n};\nvar _default = exports.default = EventuallyQueue;","map":{"version":3,"names":["_Object$defineProperty","require","_interopRequireDefault","exports","value","default","_stringify","_splice","_findIndex","_setInterval2","_find","_CoreManager","_ParseError","_ParseObject","_ParseQuery","_Storage","QUEUE_KEY","queueCache","dirtyCache","polling","undefined","EventuallyQueue","save","object","serverOptions","enqueue","destroy","generateQueueId","action","_getId","className","id","_localId","uniqueId","get","join","queueData","getQueue","queueId","index","queueItemExists","prop","set","length","toJSON","hash","createdAt","Date","setQueue","store","data","setItemAsync","load","getItemAsync","JSON","parse","queue","remove","call","clear","sendQueue","i","queueObject","ObjectType","extend","process","byId","byHash","create","sendQueueCallback","updatedAt","e","code","CONNECTION_FAILED","poll","ms","RESTController","getRESTController","request","then","_ref","status","stopPoll","catch","clearInterval","isPolling","_setPolling","flag","sessionToken","query","equalTo","results","_default"],"sources":["/home/snx/Desktop/CS_School/node_modules/parse/lib/browser/EventuallyQueue.js"],"sourcesContent":["\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _stringify = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/json/stringify\"));\nvar _splice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/splice\"));\nvar _findIndex = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/find-index\"));\nvar _setInterval2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/set-interval\"));\nvar _find = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/find\"));\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\nvar _ParseQuery = _interopRequireDefault(require(\"./ParseQuery\"));\nvar _Storage = _interopRequireDefault(require(\"./Storage\"));\nconst QUEUE_KEY = 'Parse/Eventually/Queue';\nlet queueCache = [];\nlet dirtyCache = true;\nlet polling = undefined;\n\n/**\n * Provides utility functions to queue objects that will be\n * saved to the server at a later date.\n *\n * @class Parse.EventuallyQueue\n * @static\n */\nconst EventuallyQueue = {\n  /**\n   * Add object to queue with save operation.\n   *\n   * @function save\n   * @name Parse.EventuallyQueue.save\n   * @param {ParseObject} object Parse.Object to be saved eventually\n   * @param {object} [serverOptions] See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Object.html#save Parse.Object.save} options.\n   * @returns {Promise} A promise that is fulfilled if object is added to queue.\n   * @static\n   * @see Parse.Object#saveEventually\n   */\n  save(object, serverOptions) {\n    return this.enqueue('save', object, serverOptions);\n  },\n  /**\n   * Add object to queue with save operation.\n   *\n   * @function destroy\n   * @name Parse.EventuallyQueue.destroy\n   * @param {ParseObject} object Parse.Object to be destroyed eventually\n   * @param {object} [serverOptions] See {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.Object.html#destroy Parse.Object.destroy} options\n   * @returns {Promise} A promise that is fulfilled if object is added to queue.\n   * @static\n   * @see Parse.Object#destroyEventually\n   */\n  destroy(object, serverOptions) {\n    return this.enqueue('destroy', object, serverOptions);\n  },\n  /**\n   * Generate unique identifier to avoid duplicates and maintain previous state.\n   *\n   * @param {string} action save / destroy\n   * @param {object} object Parse.Object to be queued\n   * @returns {string}\n   * @static\n   * @ignore\n   */\n  generateQueueId(action, object) {\n    object._getId();\n    const {\n      className,\n      id,\n      _localId\n    } = object;\n    const uniqueId = object.get('hash') || _localId;\n    return [action, className, id, uniqueId].join('_');\n  },\n  /**\n   * Build queue object and add to queue.\n   *\n   * @param {string} action save / destroy\n   * @param {object} object Parse.Object to be queued\n   * @param {object} [serverOptions]\n   * @returns {Promise} A promise that is fulfilled if object is added to queue.\n   * @static\n   * @ignore\n   */\n  async enqueue(action, object, serverOptions) {\n    const queueData = await this.getQueue();\n    const queueId = this.generateQueueId(action, object);\n    let index = this.queueItemExists(queueData, queueId);\n    if (index > -1) {\n      // Add cached values to new object if they don't exist\n      for (const prop in queueData[index].object) {\n        if (typeof object.get(prop) === 'undefined') {\n          object.set(prop, queueData[index].object[prop]);\n        }\n      }\n    } else {\n      index = queueData.length;\n    }\n    queueData[index] = {\n      queueId,\n      action,\n      object: object.toJSON(),\n      serverOptions: serverOptions || {},\n      id: object.id,\n      className: object.className,\n      hash: object.get('hash'),\n      createdAt: new Date()\n    };\n    return this.setQueue(queueData);\n  },\n  store(data) {\n    return _Storage.default.setItemAsync(QUEUE_KEY, (0, _stringify.default)(data));\n  },\n  load() {\n    return _Storage.default.getItemAsync(QUEUE_KEY);\n  },\n  /**\n   * Sets the in-memory queue from local storage and returns.\n   *\n   * @function getQueue\n   * @name Parse.EventuallyQueue.getQueue\n   * @returns {Promise<Queue>}\n   * @static\n   */\n  async getQueue() {\n    if (dirtyCache) {\n      queueCache = JSON.parse((await this.load()) || '[]');\n      dirtyCache = false;\n    }\n    return queueCache;\n  },\n  /**\n   * Saves the queue to local storage\n   *\n   * @param {Queue} queue Queue containing Parse.Object data.\n   * @returns {Promise} A promise that is fulfilled when queue is stored.\n   * @static\n   * @ignore\n   */\n  setQueue(queue) {\n    queueCache = queue;\n    return this.store(queueCache);\n  },\n  /**\n   * Removes Parse.Object data from queue.\n   *\n   * @param {string} queueId Unique identifier for Parse.Object data.\n   * @returns {Promise} A promise that is fulfilled when queue is stored.\n   * @static\n   * @ignore\n   */\n  async remove(queueId) {\n    const queueData = await this.getQueue();\n    const index = this.queueItemExists(queueData, queueId);\n    if (index > -1) {\n      (0, _splice.default)(queueData).call(queueData, index, 1);\n      await this.setQueue(queueData);\n    }\n  },\n  /**\n   * Removes all objects from queue.\n   *\n   * @function clear\n   * @name Parse.EventuallyQueue.clear\n   * @returns {Promise} A promise that is fulfilled when queue is cleared.\n   * @static\n   */\n  clear() {\n    queueCache = [];\n    return this.store([]);\n  },\n  /**\n   * Return the index of a queueId in the queue. Returns -1 if not found.\n   *\n   * @param {Queue} queue Queue containing Parse.Object data.\n   * @param {string} queueId Unique identifier for Parse.Object data.\n   * @returns {number}\n   * @static\n   * @ignore\n   */\n  queueItemExists(queue, queueId) {\n    return (0, _findIndex.default)(queue).call(queue, data => data.queueId === queueId);\n  },\n  /**\n   * Return the number of objects in the queue.\n   *\n   * @function length\n   * @name Parse.EventuallyQueue.length\n   * @returns {Promise<number>}\n   * @static\n   */\n  async length() {\n    const queueData = await this.getQueue();\n    return queueData.length;\n  },\n  /**\n   * Sends the queue to the server.\n   *\n   * @function sendQueue\n   * @name Parse.EventuallyQueue.sendQueue\n   * @returns {Promise<boolean>} Returns true if queue was sent successfully.\n   * @static\n   */\n  async sendQueue() {\n    const queue = await this.getQueue();\n    const queueData = [...queue];\n    if (queueData.length === 0) {\n      return false;\n    }\n    for (let i = 0; i < queueData.length; i += 1) {\n      const queueObject = queueData[i];\n      const {\n        id,\n        hash,\n        className\n      } = queueObject;\n      const ObjectType = _ParseObject.default.extend(className);\n      if (id) {\n        await this.process.byId(ObjectType, queueObject);\n      } else if (hash) {\n        await this.process.byHash(ObjectType, queueObject);\n      } else {\n        await this.process.create(ObjectType, queueObject);\n      }\n    }\n    return true;\n  },\n  /**\n   * Build queue object and add to queue.\n   *\n   * @param {ParseObject} object Parse.Object to be processed\n   * @param {QueueObject} queueObject Parse.Object data from the queue\n   * @returns {Promise} A promise that is fulfilled when operation is performed.\n   * @static\n   * @ignore\n   */\n  async sendQueueCallback(object, queueObject) {\n    if (!object) {\n      return this.remove(queueObject.queueId);\n    }\n    switch (queueObject.action) {\n      case 'save':\n        // Queued update was overwritten by other request. Do not save\n        if (typeof object.updatedAt !== 'undefined' && object.updatedAt > new Date(queueObject.object.createdAt)) {\n          return this.remove(queueObject.queueId);\n        }\n        try {\n          await object.save(queueObject.object, queueObject.serverOptions);\n          await this.remove(queueObject.queueId);\n        } catch (e) {\n          if (e.code !== _ParseError.default.CONNECTION_FAILED) {\n            await this.remove(queueObject.queueId);\n          }\n        }\n        break;\n      case 'destroy':\n        try {\n          await object.destroy(queueObject.serverOptions);\n          await this.remove(queueObject.queueId);\n        } catch (e) {\n          if (e.code !== _ParseError.default.CONNECTION_FAILED) {\n            await this.remove(queueObject.queueId);\n          }\n        }\n        break;\n    }\n  },\n  /**\n   * Start polling server for network connection.\n   * Will send queue if connection is established.\n   *\n   * @function poll\n   * @name Parse.EventuallyQueue.poll\n   * @param [ms] Milliseconds to ping the server. Default 2000ms\n   * @static\n   */\n  poll(ms) {\n    if (polling) {\n      return;\n    }\n    polling = (0, _setInterval2.default)(() => {\n      const RESTController = _CoreManager.default.getRESTController();\n      RESTController.request('GET', 'health').then(_ref => {\n        let {\n          status\n        } = _ref;\n        if (status === 'ok') {\n          this.stopPoll();\n          return this.sendQueue();\n        }\n      }).catch(e => e);\n    }, ms || 2000);\n  },\n  /**\n   * Turns off polling.\n   *\n   * @function stopPoll\n   * @name Parse.EventuallyQueue.stopPoll\n   * @static\n   */\n  stopPoll() {\n    clearInterval(polling);\n    polling = undefined;\n  },\n  /**\n   * Return true if pinging the server.\n   *\n   * @function isPolling\n   * @name Parse.EventuallyQueue.isPolling\n   * @returns {boolean}\n   * @static\n   */\n  isPolling() {\n    return !!polling;\n  },\n  _setPolling(flag) {\n    polling = flag;\n  },\n  process: {\n    create(ObjectType, queueObject) {\n      const object = new ObjectType();\n      return EventuallyQueue.sendQueueCallback(object, queueObject);\n    },\n    async byId(ObjectType, queueObject) {\n      const {\n        sessionToken\n      } = queueObject.serverOptions;\n      const query = new _ParseQuery.default(ObjectType);\n      query.equalTo('objectId', queueObject.id);\n      const results = await (0, _find.default)(query).call(query, {\n        sessionToken\n      });\n      return EventuallyQueue.sendQueueCallback(results[0], queueObject);\n    },\n    async byHash(ObjectType, queueObject) {\n      const {\n        sessionToken\n      } = queueObject.serverOptions;\n      const query = new _ParseQuery.default(ObjectType);\n      query.equalTo('hash', queueObject.hash);\n      const results = await (0, _find.default)(query).call(query, {\n        sessionToken\n      });\n      if (results.length > 0) {\n        return EventuallyQueue.sendQueueCallback(results[0], queueObject);\n      }\n      return EventuallyQueue.process.create(ObjectType, queueObject);\n    }\n  }\n};\nvar _default = exports.default = EventuallyQueue;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}