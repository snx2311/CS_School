{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty2 = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n_Object$defineProperty2(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/promise\"));\nvar _defineProperty = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\"));\nvar _stringify = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/json/stringify\"));\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\nvar _isRevocableSession = _interopRequireDefault(require(\"./isRevocableSession\"));\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\nvar _Storage = _interopRequireDefault(require(\"./Storage\"));\nconst CURRENT_USER_KEY = 'currentUser';\nlet canUseCurrentUser = !_CoreManager.default.get('IS_NODE');\nlet currentUserCacheMatchesDisk = false;\nlet currentUserCache = null;\nconst authProviders = {};\n\n/**\n * <p>A Parse.User object is a local representation of a user persisted to the\n * Parse cloud. This class is a subclass of a Parse.Object, and retains the\n * same functionality of a Parse.Object, but also extends it with various\n * user specific methods, like authentication, signing up, and validation of\n * uniqueness.</p>\n *\n * @alias Parse.User\n * @augments Parse.Object\n */\nclass ParseUser extends _ParseObject.default {\n  /**\n   * @param {object} attributes The initial set of data to store in the user.\n   */\n  constructor(attributes) {\n    super('_User');\n    if (attributes && typeof attributes === 'object') {\n      try {\n        this.set(attributes || {});\n      } catch (_) {\n        throw new Error(\"Can't create an invalid Parse User\");\n      }\n    }\n  }\n\n  /**\n   * Request a revocable session token to replace the older style of token.\n   *\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   * </ul>\n   * @returns {Promise} A promise that is resolved when the replacement\n   *   token has been fetched.\n   */\n  _upgradeToRevocableSession(options) {\n    const upgradeOptions = _ParseObject.default._getRequestOptions(options);\n    const controller = _CoreManager.default.getUserController();\n    return controller.upgradeToRevocableSession(this, upgradeOptions);\n  }\n\n  /**\n   * Parse allows you to link your users with {@link https://docs.parseplatform.org/parse-server/guide/#oauth-and-3rd-party-authentication 3rd party authentication}, enabling\n   * your users to sign up or log into your application using their existing identities.\n   * Since 2.9.0\n   *\n   * @see {@link https://docs.parseplatform.org/js/guide/#linking-users Linking Users}\n   * @param {string | AuthProvider} provider Name of auth provider or {@link https://parseplatform.org/Parse-SDK-JS/api/master/AuthProvider.html AuthProvider}\n   * @param {object} options\n   * @param {object} [options.authData] AuthData to link with\n   * <ul>\n   *   <li>If provider is string, options is {@link http://docs.parseplatform.org/parse-server/guide/#supported-3rd-party-authentications authData}\n   *   <li>If provider is AuthProvider, options is saveOpts\n   * </ul>\n   * @param {object} saveOpts useMasterKey / sessionToken\n   * @returns {Promise} A promise that is fulfilled with the user is linked\n   */\n  linkWith(provider, options) {\n    let saveOpts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    saveOpts.sessionToken = saveOpts.sessionToken || this.getSessionToken() || '';\n    let authType;\n    if (typeof provider === 'string') {\n      authType = provider;\n      if (authProviders[provider]) {\n        provider = authProviders[provider];\n      } else {\n        const authProvider = {\n          restoreAuthentication() {\n            return true;\n          },\n          getAuthType() {\n            return authType;\n          }\n        };\n        authProviders[authProvider.getAuthType()] = authProvider;\n        provider = authProvider;\n      }\n    } else {\n      authType = provider.getAuthType();\n    }\n    if (options && Object.hasOwn(options, 'authData')) {\n      const authData = this.get('authData') || {};\n      if (typeof authData !== 'object') {\n        throw new Error('Invalid type: authData field should be an object');\n      }\n      authData[authType] = options.authData;\n      const oldAnonymousData = authData.anonymous;\n      this.stripAnonymity();\n      const controller = _CoreManager.default.getUserController();\n      return controller.linkWith(this, authData, saveOpts).catch(e => {\n        delete authData[authType];\n        this.restoreAnonimity(oldAnonymousData);\n        throw e;\n      });\n    } else {\n      return new _promise.default((resolve, reject) => {\n        provider.authenticate({\n          success: (provider, result) => {\n            const opts = {};\n            opts.authData = result;\n            this.linkWith(provider, opts, saveOpts).then(() => {\n              resolve(this);\n            }, error => {\n              reject(error);\n            });\n          },\n          error: (_provider, error) => {\n            reject(error);\n          }\n        });\n      });\n    }\n  }\n\n  /**\n   * @param provider\n   * @param options\n   * @param {object} [options.authData]\n   * @param saveOpts\n   * @deprecated since 2.9.0 see {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.User.html#linkWith linkWith}\n   * @returns {Promise}\n   */\n  _linkWith(provider, options) {\n    let saveOpts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return this.linkWith(provider, options, saveOpts);\n  }\n\n  /**\n   * Synchronizes auth data for a provider (e.g. puts the access token in the\n   * right place to be used by the Facebook SDK).\n   *\n   * @param provider\n   */\n  _synchronizeAuthData(provider) {\n    if (!this.isCurrent() || !provider) {\n      return;\n    }\n    let authType;\n    if (typeof provider === 'string') {\n      authType = provider;\n      provider = authProviders[authType];\n    } else {\n      authType = provider.getAuthType();\n    }\n    const authData = this.get('authData');\n    if (!provider || !authData || typeof authData !== 'object') {\n      return;\n    }\n    const success = provider.restoreAuthentication(authData[authType]);\n    if (!success) {\n      this._unlinkFrom(provider);\n    }\n  }\n\n  /**\n   * Synchronizes authData for all providers.\n   */\n  _synchronizeAllAuthData() {\n    const authData = this.get('authData');\n    if (typeof authData !== 'object') {\n      return;\n    }\n    for (const key in authData) {\n      this._synchronizeAuthData(key);\n    }\n  }\n\n  /**\n   * Removes null values from authData (which exist temporarily for unlinking)\n   */\n  _cleanupAuthData() {\n    if (!this.isCurrent()) {\n      return;\n    }\n    const authData = this.get('authData');\n    if (typeof authData !== 'object') {\n      return;\n    }\n    for (const key in authData) {\n      if (!authData[key]) {\n        delete authData[key];\n      }\n    }\n  }\n\n  /**\n   * Unlinks a user from a service.\n   *\n   * @param {string | AuthProvider} provider Name of auth provider or {@link https://parseplatform.org/Parse-SDK-JS/api/master/AuthProvider.html AuthProvider}\n   * @param {object} options MasterKey / SessionToken\n   * @returns {Promise} A promise that is fulfilled when the unlinking\n   *     finishes.\n   */\n  _unlinkFrom(provider, options) {\n    return this.linkWith(provider, {\n      authData: null\n    }, options).then(() => {\n      this._synchronizeAuthData(provider);\n      return _promise.default.resolve(this);\n    });\n  }\n\n  /**\n   * Checks whether a user is linked to a service.\n   *\n   * @param {object} provider service to link to\n   * @returns {boolean} true if link was successful\n   */\n  _isLinked(provider) {\n    let authType;\n    if (typeof provider === 'string') {\n      authType = provider;\n    } else {\n      authType = provider.getAuthType();\n    }\n    const authData = this.get('authData') || {};\n    if (typeof authData !== 'object') {\n      return false;\n    }\n    return !!authData[authType];\n  }\n\n  /**\n   * Deauthenticates all providers.\n   */\n  _logOutWithAll() {\n    const authData = this.get('authData');\n    if (typeof authData !== 'object') {\n      return;\n    }\n    for (const key in authData) {\n      this._logOutWith(key);\n    }\n  }\n\n  /**\n   * Deauthenticates a single provider (e.g. removing access tokens from the\n   * Facebook SDK).\n   *\n   * @param {object} provider service to logout of\n   */\n  _logOutWith(provider) {\n    if (!this.isCurrent()) {\n      return;\n    }\n    if (typeof provider === 'string') {\n      provider = authProviders[provider];\n    }\n    if (provider && provider.deauthenticate) {\n      provider.deauthenticate();\n    }\n  }\n\n  /**\n   * Class instance method used to maintain specific keys when a fetch occurs.\n   * Used to ensure that the session token is not lost.\n   *\n   * @returns {object} sessionToken\n   */\n  _preserveFieldsOnFetch() {\n    return {\n      sessionToken: this.get('sessionToken')\n    };\n  }\n\n  /**\n   * Returns true if <code>current</code> would return this user.\n   *\n   * @returns {boolean} true if user is cached on disk\n   */\n  isCurrent() {\n    const current = ParseUser.current();\n    return !!current && current.id === this.id;\n  }\n\n  /**\n   * Returns true if <code>current</code> would return this user.\n   *\n   * @returns {Promise<boolean>} true if user is cached on disk\n   */\n  async isCurrentAsync() {\n    const current = await ParseUser.currentAsync();\n    return !!current && current.id === this.id;\n  }\n  stripAnonymity() {\n    const authData = this.get('authData');\n    if (authData && typeof authData === 'object' && Object.hasOwn(authData, 'anonymous')) {\n      // We need to set anonymous to null instead of deleting it in order to remove it from Parse.\n      authData.anonymous = null;\n    }\n  }\n  restoreAnonimity(anonymousData) {\n    if (anonymousData) {\n      const authData = this.get('authData');\n      authData.anonymous = anonymousData;\n    }\n  }\n\n  /**\n   * Returns get(\"username\").\n   *\n   * @returns {string}\n   */\n  getUsername() {\n    const username = this.get('username');\n    if (username == null || typeof username === 'string') {\n      return username;\n    }\n    return '';\n  }\n\n  /**\n   * Calls set(\"username\", username, options) and returns the result.\n   *\n   * @param {string} username\n   */\n  setUsername(username) {\n    this.stripAnonymity();\n    this.set('username', username);\n  }\n\n  /**\n   * Calls set(\"password\", password, options) and returns the result.\n   *\n   * @param {string} password User's Password\n   */\n  setPassword(password) {\n    this.set('password', password);\n  }\n\n  /**\n   * Returns get(\"email\").\n   *\n   * @returns {string} User's Email\n   */\n  getEmail() {\n    const email = this.get('email');\n    if (email == null || typeof email === 'string') {\n      return email;\n    }\n    return '';\n  }\n\n  /**\n   * Calls set(\"email\", email) and returns the result.\n   *\n   * @param {string} email\n   * @returns {boolean}\n   */\n  setEmail(email) {\n    return this.set('email', email);\n  }\n\n  /**\n   * Returns the session token for this user, if the user has been logged in,\n   * or if it is the result of a query with the master key. Otherwise, returns\n   * undefined.\n   *\n   * @returns {string} the session token, or undefined\n   */\n  getSessionToken() {\n    const token = this.get('sessionToken');\n    if (token == null || typeof token === 'string') {\n      return token;\n    }\n    return '';\n  }\n\n  /**\n   * Checks whether this user is the current user and has been authenticated.\n   *\n   * @returns {boolean} whether this user is the current user and is logged in.\n   */\n  authenticated() {\n    const current = ParseUser.current();\n    return !!this.get('sessionToken') && !!current && current.id === this.id;\n  }\n\n  /**\n   * Signs up a new user. You should call this instead of save for\n   * new Parse.Users. This will create a new Parse.User on the server, and\n   * also persist the session on disk so that you can access the user using\n   * <code>current</code>.\n   *\n   * <p>A username and password must be set before calling signUp.</p>\n   *\n   * @param {object} attrs Extra fields to set on the new user, or null.\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>installationId: the installationId which made the request\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeLogin` and `afterLogin` triggers.\n   * </ul>\n   * @returns {Promise} A promise that is fulfilled when the signup\n   *     finishes.\n   */\n  signUp(attrs, options) {\n    const signupOptions = _ParseObject.default._getRequestOptions(options);\n    const controller = _CoreManager.default.getUserController();\n    return controller.signUp(this, attrs, signupOptions);\n  }\n\n  /**\n   * Logs in a Parse.User. On success, this saves the session to disk,\n   * so you can retrieve the currently logged in user using\n   * <code>current</code>.\n   *\n   * <p>A username and password must be set before calling logIn.</p>\n   *\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>usePost: Use POST method to make the request (default: true)\n   *   <li>installationId: the installationId which made the request\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeLogin` and `afterLogin` triggers.\n   * </ul>\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the login is complete.\n   */\n  logIn() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const loginOptions = _ParseObject.default._getRequestOptions(options);\n    if (!Object.hasOwn(loginOptions, 'usePost')) {\n      loginOptions.usePost = true;\n    }\n    const controller = _CoreManager.default.getUserController();\n    return controller.logIn(this, loginOptions);\n  }\n\n  /**\n   * Wrap the default save behavior with functionality to save to local\n   * storage if this is current user.\n   *\n   * @param {...any} args\n   * @returns {Promise}\n   */\n  async save() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    await super.save.apply(this, args);\n    const current = await this.isCurrentAsync();\n    if (current) {\n      return _CoreManager.default.getUserController().updateUserOnDisk(this);\n    }\n    return this;\n  }\n\n  /**\n   * Wrap the default destroy behavior with functionality that logs out\n   * the current user when it is destroyed\n   *\n   * @param {...any} args\n   * @returns {Parse.User}\n   */\n  async destroy() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    await super.destroy.apply(this, args);\n    const current = await this.isCurrentAsync();\n    if (current) {\n      return _CoreManager.default.getUserController().removeUserFromDisk();\n    }\n    return this;\n  }\n\n  /**\n   * Wrap the default fetch behavior with functionality to save to local\n   * storage if this is current user.\n   *\n   * @param {...any} args\n   * @returns {Parse.User}\n   */\n  async fetch() {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    await super.fetch.apply(this, args);\n    const current = await this.isCurrentAsync();\n    if (current) {\n      return _CoreManager.default.getUserController().updateUserOnDisk(this);\n    }\n    return this;\n  }\n\n  /**\n   * Wrap the default fetchWithInclude behavior with functionality to save to local\n   * storage if this is current user.\n   *\n   * @param {...any} args\n   * @returns {Parse.User}\n   */\n  async fetchWithInclude() {\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n    await super.fetchWithInclude.apply(this, args);\n    const current = await this.isCurrentAsync();\n    if (current) {\n      return _CoreManager.default.getUserController().updateUserOnDisk(this);\n    }\n    return this;\n  }\n\n  /**\n   * Verify whether a given password is the password of the current user.\n   *\n   * @param {string} password The password to be verified.\n   * @param {object} options The options.\n   * @param {boolean} [options.ignoreEmailVerification] Set to `true` to bypass email verification and verify\n   * the password regardless of whether the email has been verified. This requires the master key.\n   * @returns {Promise} A promise that is fulfilled with a user when the password is correct.\n   */\n  verifyPassword(password, options) {\n    const username = this.getUsername() || '';\n    return ParseUser.verifyPassword(username, password, options);\n  }\n  static readOnlyAttributes() {\n    return ['sessionToken'];\n  }\n\n  /**\n   * Adds functionality to the existing Parse.User class.\n   *\n   * @param {object} protoProps A set of properties to add to the prototype\n   * @param {object} classProps A set of static properties to add to the class\n   * @static\n   * @returns {Parse.User} The newly extended Parse.User class\n   */\n  static extend(protoProps, classProps) {\n    if (protoProps) {\n      for (const prop in protoProps) {\n        if (prop !== 'className') {\n          (0, _defineProperty.default)(ParseUser.prototype, prop, {\n            value: protoProps[prop],\n            enumerable: false,\n            writable: true,\n            configurable: true\n          });\n        }\n      }\n    }\n    if (classProps) {\n      for (const prop in classProps) {\n        if (prop !== 'className') {\n          (0, _defineProperty.default)(ParseUser, prop, {\n            value: classProps[prop],\n            enumerable: false,\n            writable: true,\n            configurable: true\n          });\n        }\n      }\n    }\n    return ParseUser;\n  }\n\n  /**\n   * Retrieves the currently logged in ParseUser with a valid session,\n   * either from memory or localStorage, if necessary.\n   *\n   * @static\n   * @returns {Parse.User} The currently logged in Parse.User.\n   */\n  static current() {\n    if (!canUseCurrentUser) {\n      return null;\n    }\n    const controller = _CoreManager.default.getUserController();\n    return controller.currentUser();\n  }\n\n  /**\n   * Retrieves the currently logged in ParseUser from asynchronous Storage.\n   *\n   * @static\n   * @returns {Promise} A Promise that is resolved with the currently\n   *   logged in Parse User\n   */\n  static currentAsync() {\n    if (!canUseCurrentUser) {\n      return _promise.default.resolve(null);\n    }\n    const controller = _CoreManager.default.getUserController();\n    return controller.currentUserAsync();\n  }\n\n  /**\n   * Signs up a new user with a username (or email) and password.\n   * This will create a new Parse.User on the server, and also persist the\n   * session in localStorage so that you can access the user using\n   * {@link #current}.\n   *\n   * @param {string} username The username (or email) to sign up with.\n   * @param {string} password The password to sign up with.\n   * @param {object} attrs Extra fields to set on the new user.\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the signup completes.\n   */\n  static signUp(username, password, attrs, options) {\n    attrs = attrs || {};\n    attrs.username = username;\n    attrs.password = password;\n    const user = new this(attrs);\n    return user.signUp({}, options);\n  }\n\n  /**\n   * Logs in a user with a username (or email) and password. On success, this\n   * saves the session to disk, so you can retrieve the currently logged in\n   * user using <code>current</code>.\n   *\n   * @param {string} username The username (or email) to log in with.\n   * @param {string} password The password to log in with.\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the login completes.\n   */\n  static logIn(username, password, options) {\n    if (typeof username !== 'string') {\n      return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Username must be a string.'));\n    } else if (typeof password !== 'string') {\n      return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Password must be a string.'));\n    }\n    const user = new this();\n    user._finishFetch({\n      username,\n      password\n    });\n    return user.logIn(options);\n  }\n\n  /**\n   * Logs in a user with a username (or email) and password, and authData. On success, this\n   * saves the session to disk, so you can retrieve the currently logged in\n   * user using <code>current</code>.\n   *\n   * @param {string} username The username (or email) to log in with.\n   * @param {string} password The password to log in with.\n   * @param {object} authData The authData to log in with.\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the login completes.\n   */\n  static logInWithAdditionalAuth(username, password, authData, options) {\n    if (typeof username !== 'string') {\n      return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Username must be a string.'));\n    }\n    if (typeof password !== 'string') {\n      return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Password must be a string.'));\n    }\n    if (Object.prototype.toString.call(authData) !== '[object Object]') {\n      return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Auth must be an object.'));\n    }\n    const user = new this();\n    user._finishFetch({\n      username,\n      password,\n      authData\n    });\n    return user.logIn(options);\n  }\n\n  /**\n   * Logs in a user with an objectId. On success, this saves the session\n   * to disk, so you can retrieve the currently logged in user using\n   * <code>current</code>.\n   *\n   * @param {string} userId The objectId for the user.\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the login completes.\n   */\n  static loginAs(userId) {\n    if (!userId) {\n      throw new _ParseError.default(_ParseError.default.USERNAME_MISSING, 'Cannot log in as user with an empty user id');\n    }\n    const controller = _CoreManager.default.getUserController();\n    const user = new this();\n    return controller.loginAs(user, userId);\n  }\n\n  /**\n   * Logs in a user with a session token. On success, this saves the session\n   * to disk, so you can retrieve the currently logged in user using\n   * <code>current</code>.\n   *\n   * @param {string} sessionToken The sessionToken to log in with.\n   * @param {object} options\n   * @param {boolean} [options.useMasterKey]\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the login completes.\n   */\n  static become(sessionToken, options) {\n    if (!canUseCurrentUser) {\n      throw new Error('It is not memory-safe to become a user in a server environment');\n    }\n    const becomeOptions = _ParseObject.default._getRequestOptions(options);\n    becomeOptions.sessionToken = sessionToken;\n    const controller = _CoreManager.default.getUserController();\n    const user = new this();\n    return controller.become(user, becomeOptions);\n  }\n\n  /**\n   * Retrieves a user with a session token.\n   *\n   * @param {string} sessionToken The sessionToken to get user with.\n   * @param {object} options\n   * @param {boolean} [options.useMasterKey]\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user is fetched.\n   */\n  static me(sessionToken, options) {\n    const controller = _CoreManager.default.getUserController();\n    const meOptions = _ParseObject.default._getRequestOptions(options);\n    meOptions.sessionToken = sessionToken;\n    const user = new this();\n    return controller.me(user, meOptions);\n  }\n\n  /**\n   * Logs in a user with a session token. On success, this saves the session\n   * to disk, so you can retrieve the currently logged in user using\n   * <code>current</code>. If there is no session token the user will not logged in.\n   *\n   * @param {object} userJSON The JSON map of the User's data\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the login completes.\n   */\n  static hydrate(userJSON) {\n    const controller = _CoreManager.default.getUserController();\n    const user = new this();\n    return controller.hydrate(user, userJSON);\n  }\n\n  /**\n   * Static version of {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.User.html#linkWith linkWith}\n   *\n   * @param provider\n   * @param options\n   * @param {object} [options.authData]\n   * @param saveOpts\n   * @static\n   * @returns {Promise}\n   */\n  static logInWith(provider, options, saveOpts) {\n    const user = new this();\n    return user.linkWith(provider, options, saveOpts);\n  }\n\n  /**\n   * Logs out the currently logged in user session. This will remove the\n   * session from disk, log out of linked services, and future calls to\n   * <code>current</code> will return <code>null</code>.\n   *\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is resolved when the session is\n   *   destroyed on the server.\n   */\n  static logOut(options) {\n    const controller = _CoreManager.default.getUserController();\n    return controller.logOut(options);\n  }\n\n  /**\n   * Requests a password reset email to be sent to the specified email address\n   * associated with the user account. This email allows the user to securely\n   * reset their password on the Parse site.\n   *\n   * @param {string} email The email address associated with the user that\n   *     forgot their password.\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   * </ul>\n   * @static\n   * @returns {Promise}\n   */\n  static requestPasswordReset(email, options) {\n    const requestOptions = _ParseObject.default._getRequestOptions(options);\n    const controller = _CoreManager.default.getUserController();\n    return controller.requestPasswordReset(email, requestOptions);\n  }\n\n  /**\n   * Request an email verification.\n   *\n   * @param {string} email The email address associated with the user that\n   *     needs to verify their email.\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   * </ul>\n   * @static\n   * @returns {Promise}\n   */\n  static requestEmailVerification(email, options) {\n    const requestOptions = _ParseObject.default._getRequestOptions(options);\n    const controller = _CoreManager.default.getUserController();\n    return controller.requestEmailVerification(email, requestOptions);\n  }\n\n  /**\n   * Verify whether a given password is the password of the current user.\n   * @static\n   *\n   * @param {string} username  The username of the user whose password should be verified.\n   * @param {string} password The password to be verified.\n   * @param {object} options The options.\n   * @param {boolean} [options.ignoreEmailVerification] Set to `true` to bypass email verification and verify\n   * the password regardless of whether the email has been verified. This requires the master key.\n   * @returns {Promise} A promise that is fulfilled with a user when the password is correct.\n   */\n  static verifyPassword(username, password, options) {\n    if (typeof username !== 'string') {\n      return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Username must be a string.'));\n    }\n    if (typeof password !== 'string') {\n      return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Password must be a string.'));\n    }\n    const controller = _CoreManager.default.getUserController();\n    return controller.verifyPassword(username, password, options || {});\n  }\n\n  /**\n   * Allow someone to define a custom User class without className\n   * being rewritten to _User. The default behavior is to rewrite\n   * User to _User for legacy reasons. This allows developers to\n   * override that behavior.\n   *\n   * @param {boolean} isAllowed Whether or not to allow custom User class\n   * @static\n   */\n  static allowCustomUserClass(isAllowed) {\n    _CoreManager.default.set('PERFORM_USER_REWRITE', !isAllowed);\n  }\n\n  /**\n   * Allows a legacy application to start using revocable sessions. If the\n   * current session token is not revocable, a request will be made for a new,\n   * revocable session.\n   * It is not necessary to call this method from cloud code unless you are\n   * handling user signup or login from the server side. In a cloud code call,\n   * this function will not attempt to upgrade the current token.\n   *\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is resolved when the process has\n   *   completed. If a replacement session token is requested, the promise\n   *   will be resolved after a new token has been fetched.\n   */\n  static enableRevocableSession(options) {\n    options = options || {};\n    _CoreManager.default.set('FORCE_REVOCABLE_SESSION', true);\n    if (canUseCurrentUser) {\n      const current = ParseUser.current();\n      if (current) {\n        return current._upgradeToRevocableSession(options);\n      }\n    }\n    return _promise.default.resolve();\n  }\n\n  /**\n   * Enables the use of become or the current user in a server\n   * environment. These features are disabled by default, since they depend on\n   * global objects that are not memory-safe for most servers.\n   *\n   * @static\n   */\n  static enableUnsafeCurrentUser() {\n    canUseCurrentUser = true;\n  }\n\n  /**\n   * Disables the use of become or the current user in any environment.\n   * These features are disabled on servers by default, since they depend on\n   * global objects that are not memory-safe for most servers.\n   *\n   * @static\n   */\n  static disableUnsafeCurrentUser() {\n    canUseCurrentUser = false;\n  }\n\n  /**\n   * When registering users with {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.User.html#linkWith linkWith} a basic auth provider\n   * is automatically created for you.\n   *\n   * For advanced authentication, you can register an Auth provider to\n   * implement custom authentication, deauthentication.\n   *\n   * @param provider\n   * @see {@link https://parseplatform.org/Parse-SDK-JS/api/master/AuthProvider.html AuthProvider}\n   * @see {@link https://docs.parseplatform.org/js/guide/#custom-authentication-module Custom Authentication Module}\n   * @static\n   */\n  static _registerAuthenticationProvider(provider) {\n    authProviders[provider.getAuthType()] = provider;\n    // Synchronize the current user with the auth provider.\n    ParseUser.currentAsync().then(current => {\n      if (current) {\n        current._synchronizeAuthData(provider.getAuthType());\n      }\n    });\n  }\n\n  /**\n   * @param provider\n   * @param options\n   * @param {object} [options.authData]\n   * @param saveOpts\n   * @deprecated since 2.9.0 see {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.User.html#logInWith logInWith}\n   * @static\n   * @returns {Promise}\n   */\n  static _logInWith(provider, options, saveOpts) {\n    const user = new this();\n    return user.linkWith(provider, options, saveOpts);\n  }\n  static _clearCache() {\n    currentUserCache = null;\n    currentUserCacheMatchesDisk = false;\n  }\n  static _setCurrentUserCache(user) {\n    currentUserCache = user;\n  }\n}\n_ParseObject.default.registerSubclass('_User', ParseUser);\nconst DefaultController = {\n  updateUserOnDisk(user) {\n    const path = _Storage.default.generatePath(CURRENT_USER_KEY);\n    const json = user.toJSON();\n    delete json.password;\n    json.className = '_User';\n    let userData = (0, _stringify.default)(json);\n    if (_CoreManager.default.get('ENCRYPTED_USER')) {\n      const crypto = _CoreManager.default.getCryptoController();\n      userData = crypto.encrypt(json, _CoreManager.default.get('ENCRYPTED_KEY'));\n    }\n    return _Storage.default.setItemAsync(path, userData).then(() => {\n      return user;\n    });\n  },\n  removeUserFromDisk() {\n    const path = _Storage.default.generatePath(CURRENT_USER_KEY);\n    currentUserCacheMatchesDisk = true;\n    currentUserCache = null;\n    return _Storage.default.removeItemAsync(path);\n  },\n  setCurrentUser(user) {\n    currentUserCache = user;\n    user._cleanupAuthData();\n    user._synchronizeAllAuthData();\n    return DefaultController.updateUserOnDisk(user);\n  },\n  currentUser() {\n    if (currentUserCache) {\n      return currentUserCache;\n    }\n    if (currentUserCacheMatchesDisk) {\n      return null;\n    }\n    if (_Storage.default.async()) {\n      throw new Error('Cannot call currentUser() when using a platform with an async ' + 'storage system. Call currentUserAsync() instead.');\n    }\n    const path = _Storage.default.generatePath(CURRENT_USER_KEY);\n    let userData = _Storage.default.getItem(path);\n    currentUserCacheMatchesDisk = true;\n    if (!userData) {\n      currentUserCache = null;\n      return null;\n    }\n    if (_CoreManager.default.get('ENCRYPTED_USER')) {\n      const crypto = _CoreManager.default.getCryptoController();\n      userData = crypto.decrypt(userData, _CoreManager.default.get('ENCRYPTED_KEY'));\n    }\n    userData = JSON.parse(userData);\n    if (!userData.className) {\n      userData.className = '_User';\n    }\n    if (userData._id) {\n      if (userData.objectId !== userData._id) {\n        userData.objectId = userData._id;\n      }\n      delete userData._id;\n    }\n    if (userData._sessionToken) {\n      userData.sessionToken = userData._sessionToken;\n      delete userData._sessionToken;\n    }\n    const current = _ParseObject.default.fromJSON(userData);\n    currentUserCache = current;\n    current._synchronizeAllAuthData();\n    return current;\n  },\n  currentUserAsync() {\n    if (currentUserCache) {\n      return _promise.default.resolve(currentUserCache);\n    }\n    if (currentUserCacheMatchesDisk) {\n      return _promise.default.resolve(null);\n    }\n    const path = _Storage.default.generatePath(CURRENT_USER_KEY);\n    return _Storage.default.getItemAsync(path).then(userData => {\n      currentUserCacheMatchesDisk = true;\n      if (!userData) {\n        currentUserCache = null;\n        return _promise.default.resolve(null);\n      }\n      if (_CoreManager.default.get('ENCRYPTED_USER')) {\n        const crypto = _CoreManager.default.getCryptoController();\n        userData = crypto.decrypt(userData.toString(), _CoreManager.default.get('ENCRYPTED_KEY'));\n      }\n      userData = JSON.parse(userData);\n      if (!userData.className) {\n        userData.className = '_User';\n      }\n      if (userData._id) {\n        if (userData.objectId !== userData._id) {\n          userData.objectId = userData._id;\n        }\n        delete userData._id;\n      }\n      if (userData._sessionToken) {\n        userData.sessionToken = userData._sessionToken;\n        delete userData._sessionToken;\n      }\n      const current = _ParseObject.default.fromJSON(userData);\n      currentUserCache = current;\n      current._synchronizeAllAuthData();\n      return _promise.default.resolve(current);\n    });\n  },\n  signUp(user, attrs, options) {\n    const username = attrs && attrs.username || user.get('username');\n    const password = attrs && attrs.password || user.get('password');\n    if (!username || !username.length) {\n      return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Cannot sign up user with an empty username.'));\n    }\n    if (!password || !password.length) {\n      return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Cannot sign up user with an empty password.'));\n    }\n    return user.save(attrs, options).then(() => {\n      // Clear the password field\n      user._finishFetch({\n        password: undefined\n      });\n      if (canUseCurrentUser) {\n        return DefaultController.setCurrentUser(user);\n      }\n      return user;\n    });\n  },\n  logIn(user, options) {\n    const RESTController = _CoreManager.default.getRESTController();\n    const stateController = _CoreManager.default.getObjectStateController();\n    const auth = {\n      username: user.get('username'),\n      password: user.get('password'),\n      authData: user.get('authData')\n    };\n    return RESTController.request(options.usePost ? 'POST' : 'GET', 'login', auth, options).then(response => {\n      user._migrateId(response.objectId);\n      user._setExisted(true);\n      stateController.setPendingOp(user._getStateIdentifier(), 'username', undefined);\n      stateController.setPendingOp(user._getStateIdentifier(), 'password', undefined);\n      response.password = undefined;\n      user._finishFetch(response);\n      if (!canUseCurrentUser) {\n        // We can't set the current user, so just return the one we logged in\n        return _promise.default.resolve(user);\n      }\n      return DefaultController.setCurrentUser(user);\n    });\n  },\n  loginAs(user, userId) {\n    const RESTController = _CoreManager.default.getRESTController();\n    return RESTController.request('POST', 'loginAs', {\n      userId\n    }, {\n      useMasterKey: true\n    }).then(response => {\n      user._finishFetch(response);\n      user._setExisted(true);\n      if (!canUseCurrentUser) {\n        return _promise.default.resolve(user);\n      }\n      return DefaultController.setCurrentUser(user);\n    });\n  },\n  become(user, options) {\n    const RESTController = _CoreManager.default.getRESTController();\n    return RESTController.request('GET', 'users/me', {}, options).then(response => {\n      user._finishFetch(response);\n      user._setExisted(true);\n      return DefaultController.setCurrentUser(user);\n    });\n  },\n  hydrate(user, userJSON) {\n    user._finishFetch(userJSON);\n    user._setExisted(true);\n    if (userJSON.sessionToken && canUseCurrentUser) {\n      return DefaultController.setCurrentUser(user);\n    } else {\n      return _promise.default.resolve(user);\n    }\n  },\n  me(user, options) {\n    const RESTController = _CoreManager.default.getRESTController();\n    return RESTController.request('GET', 'users/me', {}, options).then(response => {\n      user._finishFetch(response);\n      user._setExisted(true);\n      return user;\n    });\n  },\n  logOut(options) {\n    const RESTController = _CoreManager.default.getRESTController();\n    if (options?.sessionToken) {\n      return RESTController.request('POST', 'logout', {}, options);\n    }\n    return DefaultController.currentUserAsync().then(currentUser => {\n      const path = _Storage.default.generatePath(CURRENT_USER_KEY);\n      let promise = _Storage.default.removeItemAsync(path);\n      if (currentUser !== null) {\n        const currentSession = currentUser.getSessionToken();\n        if (currentSession && (0, _isRevocableSession.default)(currentSession)) {\n          promise = promise.then(() => {\n            return RESTController.request('POST', 'logout', {}, {\n              sessionToken: currentSession\n            });\n          });\n        }\n        currentUser._logOutWithAll();\n        currentUser._finishFetch({\n          sessionToken: undefined\n        });\n      }\n      currentUserCacheMatchesDisk = true;\n      currentUserCache = null;\n      return promise;\n    });\n  },\n  requestPasswordReset(email, options) {\n    const RESTController = _CoreManager.default.getRESTController();\n    return RESTController.request('POST', 'requestPasswordReset', {\n      email\n    }, options);\n  },\n  async upgradeToRevocableSession(user, options) {\n    const token = user.getSessionToken();\n    if (!token) {\n      return _promise.default.reject(new _ParseError.default(_ParseError.default.SESSION_MISSING, 'Cannot upgrade a user with no session token'));\n    }\n    options.sessionToken = token;\n    const RESTController = _CoreManager.default.getRESTController();\n    const result = await RESTController.request('POST', 'upgradeToRevocableSession', {}, options);\n    user._finishFetch({\n      sessionToken: result?.sessionToken || ''\n    });\n    const current = await user.isCurrentAsync();\n    if (current) {\n      return DefaultController.setCurrentUser(user);\n    }\n    return _promise.default.resolve(user);\n  },\n  linkWith(user, authData, options) {\n    return user.save({\n      authData\n    }, options).then(() => {\n      if (canUseCurrentUser) {\n        return DefaultController.setCurrentUser(user);\n      }\n      return user;\n    });\n  },\n  verifyPassword(username, password, options) {\n    const RESTController = _CoreManager.default.getRESTController();\n    const data = {\n      username,\n      password,\n      ...(options.ignoreEmailVerification !== undefined && {\n        ignoreEmailVerification: options.ignoreEmailVerification\n      })\n    };\n    return RESTController.request('GET', 'verifyPassword', data, options);\n  },\n  requestEmailVerification(email, options) {\n    const RESTController = _CoreManager.default.getRESTController();\n    return RESTController.request('POST', 'verificationEmailRequest', {\n      email\n    }, options);\n  }\n};\n_CoreManager.default.setParseUser(ParseUser);\n_CoreManager.default.setUserController(DefaultController);\nvar _default = exports.default = ParseUser;","map":{"version":3,"names":["_Object$defineProperty2","require","_interopRequireDefault","exports","value","default","_promise","_defineProperty","_stringify","_CoreManager","_isRevocableSession","_ParseError","_ParseObject","_Storage","CURRENT_USER_KEY","canUseCurrentUser","get","currentUserCacheMatchesDisk","currentUserCache","authProviders","ParseUser","constructor","attributes","set","_","Error","_upgradeToRevocableSession","options","upgradeOptions","_getRequestOptions","controller","getUserController","upgradeToRevocableSession","linkWith","provider","saveOpts","arguments","length","undefined","sessionToken","getSessionToken","authType","authProvider","restoreAuthentication","getAuthType","Object","hasOwn","authData","oldAnonymousData","anonymous","stripAnonymity","catch","e","restoreAnonimity","resolve","reject","authenticate","success","result","opts","then","error","_provider","_linkWith","_synchronizeAuthData","isCurrent","_unlinkFrom","_synchronizeAllAuthData","key","_cleanupAuthData","_isLinked","_logOutWithAll","_logOutWith","deauthenticate","_preserveFieldsOnFetch","current","id","isCurrentAsync","currentAsync","anonymousData","getUsername","username","setUsername","setPassword","password","getEmail","email","setEmail","token","authenticated","signUp","attrs","signupOptions","logIn","loginOptions","usePost","save","_len","args","Array","_key","apply","updateUserOnDisk","destroy","_len2","_key2","removeUserFromDisk","fetch","_len3","_key3","fetchWithInclude","_len4","_key4","verifyPassword","readOnlyAttributes","extend","protoProps","classProps","prop","prototype","enumerable","writable","configurable","currentUser","currentUserAsync","user","OTHER_CAUSE","_finishFetch","logInWithAdditionalAuth","toString","call","loginAs","userId","USERNAME_MISSING","become","becomeOptions","me","meOptions","hydrate","userJSON","logInWith","logOut","requestPasswordReset","requestOptions","requestEmailVerification","allowCustomUserClass","isAllowed","enableRevocableSession","enableUnsafeCurrentUser","disableUnsafeCurrentUser","_registerAuthenticationProvider","_logInWith","_clearCache","_setCurrentUserCache","registerSubclass","DefaultController","path","generatePath","json","toJSON","className","userData","crypto","getCryptoController","encrypt","setItemAsync","removeItemAsync","setCurrentUser","async","getItem","decrypt","JSON","parse","_id","objectId","_sessionToken","fromJSON","getItemAsync","RESTController","getRESTController","stateController","getObjectStateController","auth","request","response","_migrateId","_setExisted","setPendingOp","_getStateIdentifier","useMasterKey","promise","currentSession","SESSION_MISSING","data","ignoreEmailVerification","setParseUser","setUserController","_default"],"sources":["/home/snx/Desktop/CS_School/node_modules/parse/lib/browser/ParseUser.js"],"sourcesContent":["\"use strict\";\n\nvar _Object$defineProperty2 = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n_Object$defineProperty2(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/promise\"));\nvar _defineProperty = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\"));\nvar _stringify = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/json/stringify\"));\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\nvar _isRevocableSession = _interopRequireDefault(require(\"./isRevocableSession\"));\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\nvar _Storage = _interopRequireDefault(require(\"./Storage\"));\nconst CURRENT_USER_KEY = 'currentUser';\nlet canUseCurrentUser = !_CoreManager.default.get('IS_NODE');\nlet currentUserCacheMatchesDisk = false;\nlet currentUserCache = null;\nconst authProviders = {};\n\n/**\n * <p>A Parse.User object is a local representation of a user persisted to the\n * Parse cloud. This class is a subclass of a Parse.Object, and retains the\n * same functionality of a Parse.Object, but also extends it with various\n * user specific methods, like authentication, signing up, and validation of\n * uniqueness.</p>\n *\n * @alias Parse.User\n * @augments Parse.Object\n */\nclass ParseUser extends _ParseObject.default {\n  /**\n   * @param {object} attributes The initial set of data to store in the user.\n   */\n  constructor(attributes) {\n    super('_User');\n    if (attributes && typeof attributes === 'object') {\n      try {\n        this.set(attributes || {});\n      } catch (_) {\n        throw new Error(\"Can't create an invalid Parse User\");\n      }\n    }\n  }\n\n  /**\n   * Request a revocable session token to replace the older style of token.\n   *\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   * </ul>\n   * @returns {Promise} A promise that is resolved when the replacement\n   *   token has been fetched.\n   */\n  _upgradeToRevocableSession(options) {\n    const upgradeOptions = _ParseObject.default._getRequestOptions(options);\n    const controller = _CoreManager.default.getUserController();\n    return controller.upgradeToRevocableSession(this, upgradeOptions);\n  }\n\n  /**\n   * Parse allows you to link your users with {@link https://docs.parseplatform.org/parse-server/guide/#oauth-and-3rd-party-authentication 3rd party authentication}, enabling\n   * your users to sign up or log into your application using their existing identities.\n   * Since 2.9.0\n   *\n   * @see {@link https://docs.parseplatform.org/js/guide/#linking-users Linking Users}\n   * @param {string | AuthProvider} provider Name of auth provider or {@link https://parseplatform.org/Parse-SDK-JS/api/master/AuthProvider.html AuthProvider}\n   * @param {object} options\n   * @param {object} [options.authData] AuthData to link with\n   * <ul>\n   *   <li>If provider is string, options is {@link http://docs.parseplatform.org/parse-server/guide/#supported-3rd-party-authentications authData}\n   *   <li>If provider is AuthProvider, options is saveOpts\n   * </ul>\n   * @param {object} saveOpts useMasterKey / sessionToken\n   * @returns {Promise} A promise that is fulfilled with the user is linked\n   */\n  linkWith(provider, options) {\n    let saveOpts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    saveOpts.sessionToken = saveOpts.sessionToken || this.getSessionToken() || '';\n    let authType;\n    if (typeof provider === 'string') {\n      authType = provider;\n      if (authProviders[provider]) {\n        provider = authProviders[provider];\n      } else {\n        const authProvider = {\n          restoreAuthentication() {\n            return true;\n          },\n          getAuthType() {\n            return authType;\n          }\n        };\n        authProviders[authProvider.getAuthType()] = authProvider;\n        provider = authProvider;\n      }\n    } else {\n      authType = provider.getAuthType();\n    }\n    if (options && Object.hasOwn(options, 'authData')) {\n      const authData = this.get('authData') || {};\n      if (typeof authData !== 'object') {\n        throw new Error('Invalid type: authData field should be an object');\n      }\n      authData[authType] = options.authData;\n      const oldAnonymousData = authData.anonymous;\n      this.stripAnonymity();\n      const controller = _CoreManager.default.getUserController();\n      return controller.linkWith(this, authData, saveOpts).catch(e => {\n        delete authData[authType];\n        this.restoreAnonimity(oldAnonymousData);\n        throw e;\n      });\n    } else {\n      return new _promise.default((resolve, reject) => {\n        provider.authenticate({\n          success: (provider, result) => {\n            const opts = {};\n            opts.authData = result;\n            this.linkWith(provider, opts, saveOpts).then(() => {\n              resolve(this);\n            }, error => {\n              reject(error);\n            });\n          },\n          error: (_provider, error) => {\n            reject(error);\n          }\n        });\n      });\n    }\n  }\n\n  /**\n   * @param provider\n   * @param options\n   * @param {object} [options.authData]\n   * @param saveOpts\n   * @deprecated since 2.9.0 see {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.User.html#linkWith linkWith}\n   * @returns {Promise}\n   */\n  _linkWith(provider, options) {\n    let saveOpts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return this.linkWith(provider, options, saveOpts);\n  }\n\n  /**\n   * Synchronizes auth data for a provider (e.g. puts the access token in the\n   * right place to be used by the Facebook SDK).\n   *\n   * @param provider\n   */\n  _synchronizeAuthData(provider) {\n    if (!this.isCurrent() || !provider) {\n      return;\n    }\n    let authType;\n    if (typeof provider === 'string') {\n      authType = provider;\n      provider = authProviders[authType];\n    } else {\n      authType = provider.getAuthType();\n    }\n    const authData = this.get('authData');\n    if (!provider || !authData || typeof authData !== 'object') {\n      return;\n    }\n    const success = provider.restoreAuthentication(authData[authType]);\n    if (!success) {\n      this._unlinkFrom(provider);\n    }\n  }\n\n  /**\n   * Synchronizes authData for all providers.\n   */\n  _synchronizeAllAuthData() {\n    const authData = this.get('authData');\n    if (typeof authData !== 'object') {\n      return;\n    }\n    for (const key in authData) {\n      this._synchronizeAuthData(key);\n    }\n  }\n\n  /**\n   * Removes null values from authData (which exist temporarily for unlinking)\n   */\n  _cleanupAuthData() {\n    if (!this.isCurrent()) {\n      return;\n    }\n    const authData = this.get('authData');\n    if (typeof authData !== 'object') {\n      return;\n    }\n    for (const key in authData) {\n      if (!authData[key]) {\n        delete authData[key];\n      }\n    }\n  }\n\n  /**\n   * Unlinks a user from a service.\n   *\n   * @param {string | AuthProvider} provider Name of auth provider or {@link https://parseplatform.org/Parse-SDK-JS/api/master/AuthProvider.html AuthProvider}\n   * @param {object} options MasterKey / SessionToken\n   * @returns {Promise} A promise that is fulfilled when the unlinking\n   *     finishes.\n   */\n  _unlinkFrom(provider, options) {\n    return this.linkWith(provider, {\n      authData: null\n    }, options).then(() => {\n      this._synchronizeAuthData(provider);\n      return _promise.default.resolve(this);\n    });\n  }\n\n  /**\n   * Checks whether a user is linked to a service.\n   *\n   * @param {object} provider service to link to\n   * @returns {boolean} true if link was successful\n   */\n  _isLinked(provider) {\n    let authType;\n    if (typeof provider === 'string') {\n      authType = provider;\n    } else {\n      authType = provider.getAuthType();\n    }\n    const authData = this.get('authData') || {};\n    if (typeof authData !== 'object') {\n      return false;\n    }\n    return !!authData[authType];\n  }\n\n  /**\n   * Deauthenticates all providers.\n   */\n  _logOutWithAll() {\n    const authData = this.get('authData');\n    if (typeof authData !== 'object') {\n      return;\n    }\n    for (const key in authData) {\n      this._logOutWith(key);\n    }\n  }\n\n  /**\n   * Deauthenticates a single provider (e.g. removing access tokens from the\n   * Facebook SDK).\n   *\n   * @param {object} provider service to logout of\n   */\n  _logOutWith(provider) {\n    if (!this.isCurrent()) {\n      return;\n    }\n    if (typeof provider === 'string') {\n      provider = authProviders[provider];\n    }\n    if (provider && provider.deauthenticate) {\n      provider.deauthenticate();\n    }\n  }\n\n  /**\n   * Class instance method used to maintain specific keys when a fetch occurs.\n   * Used to ensure that the session token is not lost.\n   *\n   * @returns {object} sessionToken\n   */\n  _preserveFieldsOnFetch() {\n    return {\n      sessionToken: this.get('sessionToken')\n    };\n  }\n\n  /**\n   * Returns true if <code>current</code> would return this user.\n   *\n   * @returns {boolean} true if user is cached on disk\n   */\n  isCurrent() {\n    const current = ParseUser.current();\n    return !!current && current.id === this.id;\n  }\n\n  /**\n   * Returns true if <code>current</code> would return this user.\n   *\n   * @returns {Promise<boolean>} true if user is cached on disk\n   */\n  async isCurrentAsync() {\n    const current = await ParseUser.currentAsync();\n    return !!current && current.id === this.id;\n  }\n  stripAnonymity() {\n    const authData = this.get('authData');\n    if (authData && typeof authData === 'object' && Object.hasOwn(authData, 'anonymous')) {\n      // We need to set anonymous to null instead of deleting it in order to remove it from Parse.\n      authData.anonymous = null;\n    }\n  }\n  restoreAnonimity(anonymousData) {\n    if (anonymousData) {\n      const authData = this.get('authData');\n      authData.anonymous = anonymousData;\n    }\n  }\n\n  /**\n   * Returns get(\"username\").\n   *\n   * @returns {string}\n   */\n  getUsername() {\n    const username = this.get('username');\n    if (username == null || typeof username === 'string') {\n      return username;\n    }\n    return '';\n  }\n\n  /**\n   * Calls set(\"username\", username, options) and returns the result.\n   *\n   * @param {string} username\n   */\n  setUsername(username) {\n    this.stripAnonymity();\n    this.set('username', username);\n  }\n\n  /**\n   * Calls set(\"password\", password, options) and returns the result.\n   *\n   * @param {string} password User's Password\n   */\n  setPassword(password) {\n    this.set('password', password);\n  }\n\n  /**\n   * Returns get(\"email\").\n   *\n   * @returns {string} User's Email\n   */\n  getEmail() {\n    const email = this.get('email');\n    if (email == null || typeof email === 'string') {\n      return email;\n    }\n    return '';\n  }\n\n  /**\n   * Calls set(\"email\", email) and returns the result.\n   *\n   * @param {string} email\n   * @returns {boolean}\n   */\n  setEmail(email) {\n    return this.set('email', email);\n  }\n\n  /**\n   * Returns the session token for this user, if the user has been logged in,\n   * or if it is the result of a query with the master key. Otherwise, returns\n   * undefined.\n   *\n   * @returns {string} the session token, or undefined\n   */\n  getSessionToken() {\n    const token = this.get('sessionToken');\n    if (token == null || typeof token === 'string') {\n      return token;\n    }\n    return '';\n  }\n\n  /**\n   * Checks whether this user is the current user and has been authenticated.\n   *\n   * @returns {boolean} whether this user is the current user and is logged in.\n   */\n  authenticated() {\n    const current = ParseUser.current();\n    return !!this.get('sessionToken') && !!current && current.id === this.id;\n  }\n\n  /**\n   * Signs up a new user. You should call this instead of save for\n   * new Parse.Users. This will create a new Parse.User on the server, and\n   * also persist the session on disk so that you can access the user using\n   * <code>current</code>.\n   *\n   * <p>A username and password must be set before calling signUp.</p>\n   *\n   * @param {object} attrs Extra fields to set on the new user, or null.\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>installationId: the installationId which made the request\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeLogin` and `afterLogin` triggers.\n   * </ul>\n   * @returns {Promise} A promise that is fulfilled when the signup\n   *     finishes.\n   */\n  signUp(attrs, options) {\n    const signupOptions = _ParseObject.default._getRequestOptions(options);\n    const controller = _CoreManager.default.getUserController();\n    return controller.signUp(this, attrs, signupOptions);\n  }\n\n  /**\n   * Logs in a Parse.User. On success, this saves the session to disk,\n   * so you can retrieve the currently logged in user using\n   * <code>current</code>.\n   *\n   * <p>A username and password must be set before calling logIn.</p>\n   *\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>usePost: Use POST method to make the request (default: true)\n   *   <li>installationId: the installationId which made the request\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeLogin` and `afterLogin` triggers.\n   * </ul>\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the login is complete.\n   */\n  logIn() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const loginOptions = _ParseObject.default._getRequestOptions(options);\n    if (!Object.hasOwn(loginOptions, 'usePost')) {\n      loginOptions.usePost = true;\n    }\n    const controller = _CoreManager.default.getUserController();\n    return controller.logIn(this, loginOptions);\n  }\n\n  /**\n   * Wrap the default save behavior with functionality to save to local\n   * storage if this is current user.\n   *\n   * @param {...any} args\n   * @returns {Promise}\n   */\n  async save() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    await super.save.apply(this, args);\n    const current = await this.isCurrentAsync();\n    if (current) {\n      return _CoreManager.default.getUserController().updateUserOnDisk(this);\n    }\n    return this;\n  }\n\n  /**\n   * Wrap the default destroy behavior with functionality that logs out\n   * the current user when it is destroyed\n   *\n   * @param {...any} args\n   * @returns {Parse.User}\n   */\n  async destroy() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    await super.destroy.apply(this, args);\n    const current = await this.isCurrentAsync();\n    if (current) {\n      return _CoreManager.default.getUserController().removeUserFromDisk();\n    }\n    return this;\n  }\n\n  /**\n   * Wrap the default fetch behavior with functionality to save to local\n   * storage if this is current user.\n   *\n   * @param {...any} args\n   * @returns {Parse.User}\n   */\n  async fetch() {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n    await super.fetch.apply(this, args);\n    const current = await this.isCurrentAsync();\n    if (current) {\n      return _CoreManager.default.getUserController().updateUserOnDisk(this);\n    }\n    return this;\n  }\n\n  /**\n   * Wrap the default fetchWithInclude behavior with functionality to save to local\n   * storage if this is current user.\n   *\n   * @param {...any} args\n   * @returns {Parse.User}\n   */\n  async fetchWithInclude() {\n    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      args[_key4] = arguments[_key4];\n    }\n    await super.fetchWithInclude.apply(this, args);\n    const current = await this.isCurrentAsync();\n    if (current) {\n      return _CoreManager.default.getUserController().updateUserOnDisk(this);\n    }\n    return this;\n  }\n\n  /**\n   * Verify whether a given password is the password of the current user.\n   *\n   * @param {string} password The password to be verified.\n   * @param {object} options The options.\n   * @param {boolean} [options.ignoreEmailVerification] Set to `true` to bypass email verification and verify\n   * the password regardless of whether the email has been verified. This requires the master key.\n   * @returns {Promise} A promise that is fulfilled with a user when the password is correct.\n   */\n  verifyPassword(password, options) {\n    const username = this.getUsername() || '';\n    return ParseUser.verifyPassword(username, password, options);\n  }\n  static readOnlyAttributes() {\n    return ['sessionToken'];\n  }\n\n  /**\n   * Adds functionality to the existing Parse.User class.\n   *\n   * @param {object} protoProps A set of properties to add to the prototype\n   * @param {object} classProps A set of static properties to add to the class\n   * @static\n   * @returns {Parse.User} The newly extended Parse.User class\n   */\n  static extend(protoProps, classProps) {\n    if (protoProps) {\n      for (const prop in protoProps) {\n        if (prop !== 'className') {\n          (0, _defineProperty.default)(ParseUser.prototype, prop, {\n            value: protoProps[prop],\n            enumerable: false,\n            writable: true,\n            configurable: true\n          });\n        }\n      }\n    }\n    if (classProps) {\n      for (const prop in classProps) {\n        if (prop !== 'className') {\n          (0, _defineProperty.default)(ParseUser, prop, {\n            value: classProps[prop],\n            enumerable: false,\n            writable: true,\n            configurable: true\n          });\n        }\n      }\n    }\n    return ParseUser;\n  }\n\n  /**\n   * Retrieves the currently logged in ParseUser with a valid session,\n   * either from memory or localStorage, if necessary.\n   *\n   * @static\n   * @returns {Parse.User} The currently logged in Parse.User.\n   */\n  static current() {\n    if (!canUseCurrentUser) {\n      return null;\n    }\n    const controller = _CoreManager.default.getUserController();\n    return controller.currentUser();\n  }\n\n  /**\n   * Retrieves the currently logged in ParseUser from asynchronous Storage.\n   *\n   * @static\n   * @returns {Promise} A Promise that is resolved with the currently\n   *   logged in Parse User\n   */\n  static currentAsync() {\n    if (!canUseCurrentUser) {\n      return _promise.default.resolve(null);\n    }\n    const controller = _CoreManager.default.getUserController();\n    return controller.currentUserAsync();\n  }\n\n  /**\n   * Signs up a new user with a username (or email) and password.\n   * This will create a new Parse.User on the server, and also persist the\n   * session in localStorage so that you can access the user using\n   * {@link #current}.\n   *\n   * @param {string} username The username (or email) to sign up with.\n   * @param {string} password The password to sign up with.\n   * @param {object} attrs Extra fields to set on the new user.\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the signup completes.\n   */\n  static signUp(username, password, attrs, options) {\n    attrs = attrs || {};\n    attrs.username = username;\n    attrs.password = password;\n    const user = new this(attrs);\n    return user.signUp({}, options);\n  }\n\n  /**\n   * Logs in a user with a username (or email) and password. On success, this\n   * saves the session to disk, so you can retrieve the currently logged in\n   * user using <code>current</code>.\n   *\n   * @param {string} username The username (or email) to log in with.\n   * @param {string} password The password to log in with.\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the login completes.\n   */\n  static logIn(username, password, options) {\n    if (typeof username !== 'string') {\n      return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Username must be a string.'));\n    } else if (typeof password !== 'string') {\n      return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Password must be a string.'));\n    }\n    const user = new this();\n    user._finishFetch({\n      username,\n      password\n    });\n    return user.logIn(options);\n  }\n\n  /**\n   * Logs in a user with a username (or email) and password, and authData. On success, this\n   * saves the session to disk, so you can retrieve the currently logged in\n   * user using <code>current</code>.\n   *\n   * @param {string} username The username (or email) to log in with.\n   * @param {string} password The password to log in with.\n   * @param {object} authData The authData to log in with.\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the login completes.\n   */\n  static logInWithAdditionalAuth(username, password, authData, options) {\n    if (typeof username !== 'string') {\n      return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Username must be a string.'));\n    }\n    if (typeof password !== 'string') {\n      return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Password must be a string.'));\n    }\n    if (Object.prototype.toString.call(authData) !== '[object Object]') {\n      return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Auth must be an object.'));\n    }\n    const user = new this();\n    user._finishFetch({\n      username,\n      password,\n      authData\n    });\n    return user.logIn(options);\n  }\n\n  /**\n   * Logs in a user with an objectId. On success, this saves the session\n   * to disk, so you can retrieve the currently logged in user using\n   * <code>current</code>.\n   *\n   * @param {string} userId The objectId for the user.\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the login completes.\n   */\n  static loginAs(userId) {\n    if (!userId) {\n      throw new _ParseError.default(_ParseError.default.USERNAME_MISSING, 'Cannot log in as user with an empty user id');\n    }\n    const controller = _CoreManager.default.getUserController();\n    const user = new this();\n    return controller.loginAs(user, userId);\n  }\n\n  /**\n   * Logs in a user with a session token. On success, this saves the session\n   * to disk, so you can retrieve the currently logged in user using\n   * <code>current</code>.\n   *\n   * @param {string} sessionToken The sessionToken to log in with.\n   * @param {object} options\n   * @param {boolean} [options.useMasterKey]\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the login completes.\n   */\n  static become(sessionToken, options) {\n    if (!canUseCurrentUser) {\n      throw new Error('It is not memory-safe to become a user in a server environment');\n    }\n    const becomeOptions = _ParseObject.default._getRequestOptions(options);\n    becomeOptions.sessionToken = sessionToken;\n    const controller = _CoreManager.default.getUserController();\n    const user = new this();\n    return controller.become(user, becomeOptions);\n  }\n\n  /**\n   * Retrieves a user with a session token.\n   *\n   * @param {string} sessionToken The sessionToken to get user with.\n   * @param {object} options\n   * @param {boolean} [options.useMasterKey]\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user is fetched.\n   */\n  static me(sessionToken, options) {\n    const controller = _CoreManager.default.getUserController();\n    const meOptions = _ParseObject.default._getRequestOptions(options);\n    meOptions.sessionToken = sessionToken;\n    const user = new this();\n    return controller.me(user, meOptions);\n  }\n\n  /**\n   * Logs in a user with a session token. On success, this saves the session\n   * to disk, so you can retrieve the currently logged in user using\n   * <code>current</code>. If there is no session token the user will not logged in.\n   *\n   * @param {object} userJSON The JSON map of the User's data\n   * @static\n   * @returns {Promise} A promise that is fulfilled with the user when\n   *     the login completes.\n   */\n  static hydrate(userJSON) {\n    const controller = _CoreManager.default.getUserController();\n    const user = new this();\n    return controller.hydrate(user, userJSON);\n  }\n\n  /**\n   * Static version of {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.User.html#linkWith linkWith}\n   *\n   * @param provider\n   * @param options\n   * @param {object} [options.authData]\n   * @param saveOpts\n   * @static\n   * @returns {Promise}\n   */\n  static logInWith(provider, options, saveOpts) {\n    const user = new this();\n    return user.linkWith(provider, options, saveOpts);\n  }\n\n  /**\n   * Logs out the currently logged in user session. This will remove the\n   * session from disk, log out of linked services, and future calls to\n   * <code>current</code> will return <code>null</code>.\n   *\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is resolved when the session is\n   *   destroyed on the server.\n   */\n  static logOut(options) {\n    const controller = _CoreManager.default.getUserController();\n    return controller.logOut(options);\n  }\n\n  /**\n   * Requests a password reset email to be sent to the specified email address\n   * associated with the user account. This email allows the user to securely\n   * reset their password on the Parse site.\n   *\n   * @param {string} email The email address associated with the user that\n   *     forgot their password.\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   * </ul>\n   * @static\n   * @returns {Promise}\n   */\n  static requestPasswordReset(email, options) {\n    const requestOptions = _ParseObject.default._getRequestOptions(options);\n    const controller = _CoreManager.default.getUserController();\n    return controller.requestPasswordReset(email, requestOptions);\n  }\n\n  /**\n   * Request an email verification.\n   *\n   * @param {string} email The email address associated with the user that\n   *     needs to verify their email.\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   * </ul>\n   * @static\n   * @returns {Promise}\n   */\n  static requestEmailVerification(email, options) {\n    const requestOptions = _ParseObject.default._getRequestOptions(options);\n    const controller = _CoreManager.default.getUserController();\n    return controller.requestEmailVerification(email, requestOptions);\n  }\n\n  /**\n   * Verify whether a given password is the password of the current user.\n   * @static\n   *\n   * @param {string} username  The username of the user whose password should be verified.\n   * @param {string} password The password to be verified.\n   * @param {object} options The options.\n   * @param {boolean} [options.ignoreEmailVerification] Set to `true` to bypass email verification and verify\n   * the password regardless of whether the email has been verified. This requires the master key.\n   * @returns {Promise} A promise that is fulfilled with a user when the password is correct.\n   */\n  static verifyPassword(username, password, options) {\n    if (typeof username !== 'string') {\n      return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Username must be a string.'));\n    }\n    if (typeof password !== 'string') {\n      return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Password must be a string.'));\n    }\n    const controller = _CoreManager.default.getUserController();\n    return controller.verifyPassword(username, password, options || {});\n  }\n\n  /**\n   * Allow someone to define a custom User class without className\n   * being rewritten to _User. The default behavior is to rewrite\n   * User to _User for legacy reasons. This allows developers to\n   * override that behavior.\n   *\n   * @param {boolean} isAllowed Whether or not to allow custom User class\n   * @static\n   */\n  static allowCustomUserClass(isAllowed) {\n    _CoreManager.default.set('PERFORM_USER_REWRITE', !isAllowed);\n  }\n\n  /**\n   * Allows a legacy application to start using revocable sessions. If the\n   * current session token is not revocable, a request will be made for a new,\n   * revocable session.\n   * It is not necessary to call this method from cloud code unless you are\n   * handling user signup or login from the server side. In a cloud code call,\n   * this function will not attempt to upgrade the current token.\n   *\n   * @param {object} options\n   * @static\n   * @returns {Promise} A promise that is resolved when the process has\n   *   completed. If a replacement session token is requested, the promise\n   *   will be resolved after a new token has been fetched.\n   */\n  static enableRevocableSession(options) {\n    options = options || {};\n    _CoreManager.default.set('FORCE_REVOCABLE_SESSION', true);\n    if (canUseCurrentUser) {\n      const current = ParseUser.current();\n      if (current) {\n        return current._upgradeToRevocableSession(options);\n      }\n    }\n    return _promise.default.resolve();\n  }\n\n  /**\n   * Enables the use of become or the current user in a server\n   * environment. These features are disabled by default, since they depend on\n   * global objects that are not memory-safe for most servers.\n   *\n   * @static\n   */\n  static enableUnsafeCurrentUser() {\n    canUseCurrentUser = true;\n  }\n\n  /**\n   * Disables the use of become or the current user in any environment.\n   * These features are disabled on servers by default, since they depend on\n   * global objects that are not memory-safe for most servers.\n   *\n   * @static\n   */\n  static disableUnsafeCurrentUser() {\n    canUseCurrentUser = false;\n  }\n\n  /**\n   * When registering users with {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.User.html#linkWith linkWith} a basic auth provider\n   * is automatically created for you.\n   *\n   * For advanced authentication, you can register an Auth provider to\n   * implement custom authentication, deauthentication.\n   *\n   * @param provider\n   * @see {@link https://parseplatform.org/Parse-SDK-JS/api/master/AuthProvider.html AuthProvider}\n   * @see {@link https://docs.parseplatform.org/js/guide/#custom-authentication-module Custom Authentication Module}\n   * @static\n   */\n  static _registerAuthenticationProvider(provider) {\n    authProviders[provider.getAuthType()] = provider;\n    // Synchronize the current user with the auth provider.\n    ParseUser.currentAsync().then(current => {\n      if (current) {\n        current._synchronizeAuthData(provider.getAuthType());\n      }\n    });\n  }\n\n  /**\n   * @param provider\n   * @param options\n   * @param {object} [options.authData]\n   * @param saveOpts\n   * @deprecated since 2.9.0 see {@link https://parseplatform.org/Parse-SDK-JS/api/master/Parse.User.html#logInWith logInWith}\n   * @static\n   * @returns {Promise}\n   */\n  static _logInWith(provider, options, saveOpts) {\n    const user = new this();\n    return user.linkWith(provider, options, saveOpts);\n  }\n  static _clearCache() {\n    currentUserCache = null;\n    currentUserCacheMatchesDisk = false;\n  }\n  static _setCurrentUserCache(user) {\n    currentUserCache = user;\n  }\n}\n_ParseObject.default.registerSubclass('_User', ParseUser);\nconst DefaultController = {\n  updateUserOnDisk(user) {\n    const path = _Storage.default.generatePath(CURRENT_USER_KEY);\n    const json = user.toJSON();\n    delete json.password;\n    json.className = '_User';\n    let userData = (0, _stringify.default)(json);\n    if (_CoreManager.default.get('ENCRYPTED_USER')) {\n      const crypto = _CoreManager.default.getCryptoController();\n      userData = crypto.encrypt(json, _CoreManager.default.get('ENCRYPTED_KEY'));\n    }\n    return _Storage.default.setItemAsync(path, userData).then(() => {\n      return user;\n    });\n  },\n  removeUserFromDisk() {\n    const path = _Storage.default.generatePath(CURRENT_USER_KEY);\n    currentUserCacheMatchesDisk = true;\n    currentUserCache = null;\n    return _Storage.default.removeItemAsync(path);\n  },\n  setCurrentUser(user) {\n    currentUserCache = user;\n    user._cleanupAuthData();\n    user._synchronizeAllAuthData();\n    return DefaultController.updateUserOnDisk(user);\n  },\n  currentUser() {\n    if (currentUserCache) {\n      return currentUserCache;\n    }\n    if (currentUserCacheMatchesDisk) {\n      return null;\n    }\n    if (_Storage.default.async()) {\n      throw new Error('Cannot call currentUser() when using a platform with an async ' + 'storage system. Call currentUserAsync() instead.');\n    }\n    const path = _Storage.default.generatePath(CURRENT_USER_KEY);\n    let userData = _Storage.default.getItem(path);\n    currentUserCacheMatchesDisk = true;\n    if (!userData) {\n      currentUserCache = null;\n      return null;\n    }\n    if (_CoreManager.default.get('ENCRYPTED_USER')) {\n      const crypto = _CoreManager.default.getCryptoController();\n      userData = crypto.decrypt(userData, _CoreManager.default.get('ENCRYPTED_KEY'));\n    }\n    userData = JSON.parse(userData);\n    if (!userData.className) {\n      userData.className = '_User';\n    }\n    if (userData._id) {\n      if (userData.objectId !== userData._id) {\n        userData.objectId = userData._id;\n      }\n      delete userData._id;\n    }\n    if (userData._sessionToken) {\n      userData.sessionToken = userData._sessionToken;\n      delete userData._sessionToken;\n    }\n    const current = _ParseObject.default.fromJSON(userData);\n    currentUserCache = current;\n    current._synchronizeAllAuthData();\n    return current;\n  },\n  currentUserAsync() {\n    if (currentUserCache) {\n      return _promise.default.resolve(currentUserCache);\n    }\n    if (currentUserCacheMatchesDisk) {\n      return _promise.default.resolve(null);\n    }\n    const path = _Storage.default.generatePath(CURRENT_USER_KEY);\n    return _Storage.default.getItemAsync(path).then(userData => {\n      currentUserCacheMatchesDisk = true;\n      if (!userData) {\n        currentUserCache = null;\n        return _promise.default.resolve(null);\n      }\n      if (_CoreManager.default.get('ENCRYPTED_USER')) {\n        const crypto = _CoreManager.default.getCryptoController();\n        userData = crypto.decrypt(userData.toString(), _CoreManager.default.get('ENCRYPTED_KEY'));\n      }\n      userData = JSON.parse(userData);\n      if (!userData.className) {\n        userData.className = '_User';\n      }\n      if (userData._id) {\n        if (userData.objectId !== userData._id) {\n          userData.objectId = userData._id;\n        }\n        delete userData._id;\n      }\n      if (userData._sessionToken) {\n        userData.sessionToken = userData._sessionToken;\n        delete userData._sessionToken;\n      }\n      const current = _ParseObject.default.fromJSON(userData);\n      currentUserCache = current;\n      current._synchronizeAllAuthData();\n      return _promise.default.resolve(current);\n    });\n  },\n  signUp(user, attrs, options) {\n    const username = attrs && attrs.username || user.get('username');\n    const password = attrs && attrs.password || user.get('password');\n    if (!username || !username.length) {\n      return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Cannot sign up user with an empty username.'));\n    }\n    if (!password || !password.length) {\n      return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Cannot sign up user with an empty password.'));\n    }\n    return user.save(attrs, options).then(() => {\n      // Clear the password field\n      user._finishFetch({\n        password: undefined\n      });\n      if (canUseCurrentUser) {\n        return DefaultController.setCurrentUser(user);\n      }\n      return user;\n    });\n  },\n  logIn(user, options) {\n    const RESTController = _CoreManager.default.getRESTController();\n    const stateController = _CoreManager.default.getObjectStateController();\n    const auth = {\n      username: user.get('username'),\n      password: user.get('password'),\n      authData: user.get('authData')\n    };\n    return RESTController.request(options.usePost ? 'POST' : 'GET', 'login', auth, options).then(response => {\n      user._migrateId(response.objectId);\n      user._setExisted(true);\n      stateController.setPendingOp(user._getStateIdentifier(), 'username', undefined);\n      stateController.setPendingOp(user._getStateIdentifier(), 'password', undefined);\n      response.password = undefined;\n      user._finishFetch(response);\n      if (!canUseCurrentUser) {\n        // We can't set the current user, so just return the one we logged in\n        return _promise.default.resolve(user);\n      }\n      return DefaultController.setCurrentUser(user);\n    });\n  },\n  loginAs(user, userId) {\n    const RESTController = _CoreManager.default.getRESTController();\n    return RESTController.request('POST', 'loginAs', {\n      userId\n    }, {\n      useMasterKey: true\n    }).then(response => {\n      user._finishFetch(response);\n      user._setExisted(true);\n      if (!canUseCurrentUser) {\n        return _promise.default.resolve(user);\n      }\n      return DefaultController.setCurrentUser(user);\n    });\n  },\n  become(user, options) {\n    const RESTController = _CoreManager.default.getRESTController();\n    return RESTController.request('GET', 'users/me', {}, options).then(response => {\n      user._finishFetch(response);\n      user._setExisted(true);\n      return DefaultController.setCurrentUser(user);\n    });\n  },\n  hydrate(user, userJSON) {\n    user._finishFetch(userJSON);\n    user._setExisted(true);\n    if (userJSON.sessionToken && canUseCurrentUser) {\n      return DefaultController.setCurrentUser(user);\n    } else {\n      return _promise.default.resolve(user);\n    }\n  },\n  me(user, options) {\n    const RESTController = _CoreManager.default.getRESTController();\n    return RESTController.request('GET', 'users/me', {}, options).then(response => {\n      user._finishFetch(response);\n      user._setExisted(true);\n      return user;\n    });\n  },\n  logOut(options) {\n    const RESTController = _CoreManager.default.getRESTController();\n    if (options?.sessionToken) {\n      return RESTController.request('POST', 'logout', {}, options);\n    }\n    return DefaultController.currentUserAsync().then(currentUser => {\n      const path = _Storage.default.generatePath(CURRENT_USER_KEY);\n      let promise = _Storage.default.removeItemAsync(path);\n      if (currentUser !== null) {\n        const currentSession = currentUser.getSessionToken();\n        if (currentSession && (0, _isRevocableSession.default)(currentSession)) {\n          promise = promise.then(() => {\n            return RESTController.request('POST', 'logout', {}, {\n              sessionToken: currentSession\n            });\n          });\n        }\n        currentUser._logOutWithAll();\n        currentUser._finishFetch({\n          sessionToken: undefined\n        });\n      }\n      currentUserCacheMatchesDisk = true;\n      currentUserCache = null;\n      return promise;\n    });\n  },\n  requestPasswordReset(email, options) {\n    const RESTController = _CoreManager.default.getRESTController();\n    return RESTController.request('POST', 'requestPasswordReset', {\n      email\n    }, options);\n  },\n  async upgradeToRevocableSession(user, options) {\n    const token = user.getSessionToken();\n    if (!token) {\n      return _promise.default.reject(new _ParseError.default(_ParseError.default.SESSION_MISSING, 'Cannot upgrade a user with no session token'));\n    }\n    options.sessionToken = token;\n    const RESTController = _CoreManager.default.getRESTController();\n    const result = await RESTController.request('POST', 'upgradeToRevocableSession', {}, options);\n    user._finishFetch({\n      sessionToken: result?.sessionToken || ''\n    });\n    const current = await user.isCurrentAsync();\n    if (current) {\n      return DefaultController.setCurrentUser(user);\n    }\n    return _promise.default.resolve(user);\n  },\n  linkWith(user, authData, options) {\n    return user.save({\n      authData\n    }, options).then(() => {\n      if (canUseCurrentUser) {\n        return DefaultController.setCurrentUser(user);\n      }\n      return user;\n    });\n  },\n  verifyPassword(username, password, options) {\n    const RESTController = _CoreManager.default.getRESTController();\n    const data = {\n      username,\n      password,\n      ...(options.ignoreEmailVerification !== undefined && {\n        ignoreEmailVerification: options.ignoreEmailVerification\n      })\n    };\n    return RESTController.request('GET', 'verifyPassword', data, options);\n  },\n  requestEmailVerification(email, options) {\n    const RESTController = _CoreManager.default.getRESTController();\n    return RESTController.request('POST', 'verificationEmailRequest', {\n      email\n    }, options);\n  }\n};\n_CoreManager.default.setParseUser(ParseUser);\n_CoreManager.default.setUserController(DefaultController);\nvar _default = exports.default = ParseUser;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}