{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _entries = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/entries\"));\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\nconst DEVICE_TYPES = {\n  IOS: 'ios',\n  MACOS: 'macos',\n  TVOS: 'tvos',\n  FCM: 'fcm',\n  ANDROID: 'android',\n  WEB: 'web'\n};\n\n/**\n * Parse.Installation is a local representation of installation data that can be saved and retrieved from the Parse cloud.\n * This class is a subclass of a Parse.Object, and retains the same functionality of a Parse.Object, but also extends it with installation-specific features.\n *\n * <p>A valid Parse.Installation can only be instantiated via <code>Parse.Installation.currentInstallation()</code>\n *\n * Parse.Installation objects which have a valid <code>deviceToken</code> and are saved to the Parse cloud can be used to target push notifications.\n * </p>\n *\n * @alias Parse.Installation\n */\nclass ParseInstallation extends _ParseObject.default {\n  /**\n   * @param {object} attributes The initial set of data to store in the object.\n   */\n  constructor(attributes) {\n    super('_Installation');\n    if (attributes && typeof attributes === 'object') {\n      try {\n        this.set(attributes || {});\n      } catch (_) {\n        throw new Error(\"Can't create an invalid Installation\");\n      }\n    }\n  }\n\n  /**\n   * A unique identifier for this installation’s client application. In iOS, this is the Bundle Identifier.\n   *\n   * @property {string} appIdentifier\n   * @static\n   * @returns {string}\n   */\n  get appIdentifier() {\n    return this.get('appIdentifier');\n  }\n\n  /**\n   * The version string of the client application to which this installation belongs.\n   *\n   * @property {string} appVersion\n   * @static\n   * @returns {string}\n   */\n  get appVersion() {\n    return this.get('appVersion');\n  }\n\n  /**\n   * The display name of the client application to which this installation belongs.\n   *\n   * @property {string} appName\n   * @static\n   * @returns {string}\n   */\n  get appName() {\n    return this.get('appName');\n  }\n\n  /**\n   * The current value of the icon badge for iOS apps.\n   * Changes to this value on the server will be used\n   * for future badge-increment push notifications.\n   *\n   * @property {number} badge\n   * @static\n   * @returns {number}\n   */\n  get badge() {\n    return this.get('badge');\n  }\n\n  /**\n   * An array of the channels to which a device is currently subscribed.\n   *\n   * @property {string[]} channels\n   * @static\n   * @returns {string[]}\n   */\n  get channels() {\n    return this.get('channels');\n  }\n\n  /**\n   * Token used to deliver push notifications to the device.\n   *\n   * @property {string} deviceToken\n   * @static\n   * @returns {string}\n   */\n  get deviceToken() {\n    return this.get('deviceToken');\n  }\n\n  /**\n   * The type of device, “ios”, “android”, “web”, etc.\n   *\n   * @property {string} deviceType\n   * @static\n   * @returns {string}\n   */\n  get deviceType() {\n    return this.get('deviceType');\n  }\n\n  /**\n   * Gets the GCM sender identifier for this installation\n   *\n   * @property {string} GCMSenderId\n   * @static\n   * @returns {string}\n   */\n  get GCMSenderId() {\n    return this.get('GCMSenderId');\n  }\n\n  /**\n   * Universally Unique Identifier (UUID) for the device used by Parse. It must be unique across all of an app’s installations.\n   *\n   * @property {string} installationId\n   * @static\n   * @returns {string}\n   */\n  get installationId() {\n    return this.get('installationId');\n  }\n\n  /**\n   * Gets the local identifier for this installation\n   *\n   * @property {string} localeIdentifier\n   * @static\n   * @returns {string}\n   */\n  get localeIdentifier() {\n    return this.get('localeIdentifier');\n  }\n\n  /**\n   * Gets the parse server version for this installation\n   *\n   * @property {string} parseVersion\n   * @static\n   * @returns {string}\n   */\n  get parseVersion() {\n    return this.get('parseVersion');\n  }\n\n  /**\n   * This field is reserved for directing Parse to the push delivery network to be used.\n   *\n   * @property {string} pushType\n   * @static\n   * @returns {string}\n   */\n  get pushType() {\n    return this.get('pushType');\n  }\n\n  /**\n   * Gets the time zone for this installation\n   *\n   * @property {string} timeZone\n   * @static\n   * @returns {string}\n   */\n  get timeZone() {\n    return this.get('timeZone');\n  }\n\n  /**\n   * Returns the device types for used for Push Notifications.\n   *\n   * <pre>\n   * Parse.Installation.DEVICE_TYPES.IOS\n   * Parse.Installation.DEVICE_TYPES.MACOS\n   * Parse.Installation.DEVICE_TYPES.TVOS\n   * Parse.Installation.DEVICE_TYPES.FCM\n   * Parse.Installation.DEVICE_TYPES.ANDROID\n   * Parse.Installation.DEVICE_TYPES.WEB\n   * </pre\n   *\n   * @property {object} DEVICE_TYPES\n   * @static\n   * @returns {object}\n   */\n  static get DEVICE_TYPES() {\n    return DEVICE_TYPES;\n  }\n\n  /**\n   * Wrap the default fetch behavior with functionality to update local storage.\n   * If the installation is deleted on the server, retry the fetch as a save operation.\n   *\n   * @param {...any} args\n   * @returns {Promise}\n   */\n  async fetch() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    try {\n      await super.fetch.apply(this, args);\n    } catch (e) {\n      if (e.code !== _ParseError.default.OBJECT_NOT_FOUND) {\n        throw e;\n      }\n      // The installation was deleted from the server.\n      // We always want fetch to succeed.\n      delete this.id;\n      this._getId(); // Generate localId\n      this._markAllFieldsDirty();\n      await super.save.apply(this, args);\n    }\n    await _CoreManager.default.getInstallationController().updateInstallationOnDisk(this);\n    return this;\n  }\n\n  /**\n   * Wrap the default save behavior with functionality to update the local storage.\n   * If the installation is deleted on the server, retry saving a new installation.\n   *\n   * @param {...any} args\n   * @returns {Promise}\n   */\n  async save() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    try {\n      await super.save.apply(this, args);\n    } catch (e) {\n      if (e.code !== _ParseError.default.OBJECT_NOT_FOUND) {\n        throw e;\n      }\n      // The installation was deleted from the server.\n      // We always want save to succeed.\n      delete this.id;\n      this._getId(); // Generate localId\n      this._markAllFieldsDirty();\n      await super.save.apply(this, args);\n    }\n    await _CoreManager.default.getInstallationController().updateInstallationOnDisk(this);\n    return this;\n  }\n  _markAllFieldsDirty() {\n    for (const [key, value] of (0, _entries.default)(this.attributes)) {\n      this.set(key, value);\n    }\n  }\n\n  /**\n   * Get the current Parse.Installation from disk. If doesn't exists, create an new installation.\n   *\n   * <pre>\n   * const installation = await Parse.Installation.currentInstallation();\n   * installation.set('deviceToken', '123');\n   * await installation.save();\n   * </pre>\n   *\n   * @returns {Promise} A promise that resolves to the local installation object.\n   */\n  static currentInstallation() {\n    return _CoreManager.default.getInstallationController().currentInstallation();\n  }\n}\n_ParseObject.default.registerSubclass('_Installation', ParseInstallation);\nvar _default = exports.default = ParseInstallation;","map":{"version":3,"names":["_Object$defineProperty","require","_interopRequireDefault","exports","value","default","_entries","_CoreManager","_ParseError","_ParseObject","DEVICE_TYPES","IOS","MACOS","TVOS","FCM","ANDROID","WEB","ParseInstallation","constructor","attributes","set","_","Error","appIdentifier","get","appVersion","appName","badge","channels","deviceToken","deviceType","GCMSenderId","installationId","localeIdentifier","parseVersion","pushType","timeZone","fetch","_len","arguments","length","args","Array","_key","apply","e","code","OBJECT_NOT_FOUND","id","_getId","_markAllFieldsDirty","save","getInstallationController","updateInstallationOnDisk","_len2","_key2","key","currentInstallation","registerSubclass","_default"],"sources":["/home/snx/Desktop/CS_School/node_modules/parse/lib/browser/ParseInstallation.js"],"sourcesContent":["\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _entries = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/entries\"));\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\nconst DEVICE_TYPES = {\n  IOS: 'ios',\n  MACOS: 'macos',\n  TVOS: 'tvos',\n  FCM: 'fcm',\n  ANDROID: 'android',\n  WEB: 'web'\n};\n\n/**\n * Parse.Installation is a local representation of installation data that can be saved and retrieved from the Parse cloud.\n * This class is a subclass of a Parse.Object, and retains the same functionality of a Parse.Object, but also extends it with installation-specific features.\n *\n * <p>A valid Parse.Installation can only be instantiated via <code>Parse.Installation.currentInstallation()</code>\n *\n * Parse.Installation objects which have a valid <code>deviceToken</code> and are saved to the Parse cloud can be used to target push notifications.\n * </p>\n *\n * @alias Parse.Installation\n */\nclass ParseInstallation extends _ParseObject.default {\n  /**\n   * @param {object} attributes The initial set of data to store in the object.\n   */\n  constructor(attributes) {\n    super('_Installation');\n    if (attributes && typeof attributes === 'object') {\n      try {\n        this.set(attributes || {});\n      } catch (_) {\n        throw new Error(\"Can't create an invalid Installation\");\n      }\n    }\n  }\n\n  /**\n   * A unique identifier for this installation’s client application. In iOS, this is the Bundle Identifier.\n   *\n   * @property {string} appIdentifier\n   * @static\n   * @returns {string}\n   */\n  get appIdentifier() {\n    return this.get('appIdentifier');\n  }\n\n  /**\n   * The version string of the client application to which this installation belongs.\n   *\n   * @property {string} appVersion\n   * @static\n   * @returns {string}\n   */\n  get appVersion() {\n    return this.get('appVersion');\n  }\n\n  /**\n   * The display name of the client application to which this installation belongs.\n   *\n   * @property {string} appName\n   * @static\n   * @returns {string}\n   */\n  get appName() {\n    return this.get('appName');\n  }\n\n  /**\n   * The current value of the icon badge for iOS apps.\n   * Changes to this value on the server will be used\n   * for future badge-increment push notifications.\n   *\n   * @property {number} badge\n   * @static\n   * @returns {number}\n   */\n  get badge() {\n    return this.get('badge');\n  }\n\n  /**\n   * An array of the channels to which a device is currently subscribed.\n   *\n   * @property {string[]} channels\n   * @static\n   * @returns {string[]}\n   */\n  get channels() {\n    return this.get('channels');\n  }\n\n  /**\n   * Token used to deliver push notifications to the device.\n   *\n   * @property {string} deviceToken\n   * @static\n   * @returns {string}\n   */\n  get deviceToken() {\n    return this.get('deviceToken');\n  }\n\n  /**\n   * The type of device, “ios”, “android”, “web”, etc.\n   *\n   * @property {string} deviceType\n   * @static\n   * @returns {string}\n   */\n  get deviceType() {\n    return this.get('deviceType');\n  }\n\n  /**\n   * Gets the GCM sender identifier for this installation\n   *\n   * @property {string} GCMSenderId\n   * @static\n   * @returns {string}\n   */\n  get GCMSenderId() {\n    return this.get('GCMSenderId');\n  }\n\n  /**\n   * Universally Unique Identifier (UUID) for the device used by Parse. It must be unique across all of an app’s installations.\n   *\n   * @property {string} installationId\n   * @static\n   * @returns {string}\n   */\n  get installationId() {\n    return this.get('installationId');\n  }\n\n  /**\n   * Gets the local identifier for this installation\n   *\n   * @property {string} localeIdentifier\n   * @static\n   * @returns {string}\n   */\n  get localeIdentifier() {\n    return this.get('localeIdentifier');\n  }\n\n  /**\n   * Gets the parse server version for this installation\n   *\n   * @property {string} parseVersion\n   * @static\n   * @returns {string}\n   */\n  get parseVersion() {\n    return this.get('parseVersion');\n  }\n\n  /**\n   * This field is reserved for directing Parse to the push delivery network to be used.\n   *\n   * @property {string} pushType\n   * @static\n   * @returns {string}\n   */\n  get pushType() {\n    return this.get('pushType');\n  }\n\n  /**\n   * Gets the time zone for this installation\n   *\n   * @property {string} timeZone\n   * @static\n   * @returns {string}\n   */\n  get timeZone() {\n    return this.get('timeZone');\n  }\n\n  /**\n   * Returns the device types for used for Push Notifications.\n   *\n   * <pre>\n   * Parse.Installation.DEVICE_TYPES.IOS\n   * Parse.Installation.DEVICE_TYPES.MACOS\n   * Parse.Installation.DEVICE_TYPES.TVOS\n   * Parse.Installation.DEVICE_TYPES.FCM\n   * Parse.Installation.DEVICE_TYPES.ANDROID\n   * Parse.Installation.DEVICE_TYPES.WEB\n   * </pre\n   *\n   * @property {object} DEVICE_TYPES\n   * @static\n   * @returns {object}\n   */\n  static get DEVICE_TYPES() {\n    return DEVICE_TYPES;\n  }\n\n  /**\n   * Wrap the default fetch behavior with functionality to update local storage.\n   * If the installation is deleted on the server, retry the fetch as a save operation.\n   *\n   * @param {...any} args\n   * @returns {Promise}\n   */\n  async fetch() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    try {\n      await super.fetch.apply(this, args);\n    } catch (e) {\n      if (e.code !== _ParseError.default.OBJECT_NOT_FOUND) {\n        throw e;\n      }\n      // The installation was deleted from the server.\n      // We always want fetch to succeed.\n      delete this.id;\n      this._getId(); // Generate localId\n      this._markAllFieldsDirty();\n      await super.save.apply(this, args);\n    }\n    await _CoreManager.default.getInstallationController().updateInstallationOnDisk(this);\n    return this;\n  }\n\n  /**\n   * Wrap the default save behavior with functionality to update the local storage.\n   * If the installation is deleted on the server, retry saving a new installation.\n   *\n   * @param {...any} args\n   * @returns {Promise}\n   */\n  async save() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    try {\n      await super.save.apply(this, args);\n    } catch (e) {\n      if (e.code !== _ParseError.default.OBJECT_NOT_FOUND) {\n        throw e;\n      }\n      // The installation was deleted from the server.\n      // We always want save to succeed.\n      delete this.id;\n      this._getId(); // Generate localId\n      this._markAllFieldsDirty();\n      await super.save.apply(this, args);\n    }\n    await _CoreManager.default.getInstallationController().updateInstallationOnDisk(this);\n    return this;\n  }\n  _markAllFieldsDirty() {\n    for (const [key, value] of (0, _entries.default)(this.attributes)) {\n      this.set(key, value);\n    }\n  }\n\n  /**\n   * Get the current Parse.Installation from disk. If doesn't exists, create an new installation.\n   *\n   * <pre>\n   * const installation = await Parse.Installation.currentInstallation();\n   * installation.set('deviceToken', '123');\n   * await installation.save();\n   * </pre>\n   *\n   * @returns {Promise} A promise that resolves to the local installation object.\n   */\n  static currentInstallation() {\n    return _CoreManager.default.getInstallationController().currentInstallation();\n  }\n}\n_ParseObject.default.registerSubclass('_Installation', ParseInstallation);\nvar _default = exports.default = ParseInstallation;"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,sBAAsB,GAAGC,OAAO,CAAC,8DAA8D,CAAC;AACpG,IAAIC,sBAAsB,GAAGD,OAAO,CAAC,sDAAsD,CAAC;AAC5FD,sBAAsB,CAACG,OAAO,EAAE,YAAY,EAAE;EAC5CC,KAAK,EAAE;AACT,CAAC,CAAC;AACFD,OAAO,CAACE,OAAO,GAAG,KAAK,CAAC;AACxB,IAAIC,QAAQ,GAAGJ,sBAAsB,CAACD,OAAO,CAAC,sDAAsD,CAAC,CAAC;AACtG,IAAIM,YAAY,GAAGL,sBAAsB,CAACD,OAAO,CAAC,eAAe,CAAC,CAAC;AACnE,IAAIO,WAAW,GAAGN,sBAAsB,CAACD,OAAO,CAAC,cAAc,CAAC,CAAC;AACjE,IAAIQ,YAAY,GAAGP,sBAAsB,CAACD,OAAO,CAAC,eAAe,CAAC,CAAC;AACnE,MAAMS,YAAY,GAAG;EACnBC,GAAG,EAAE,KAAK;EACVC,KAAK,EAAE,OAAO;EACdC,IAAI,EAAE,MAAM;EACZC,GAAG,EAAE,KAAK;EACVC,OAAO,EAAE,SAAS;EAClBC,GAAG,EAAE;AACP,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,iBAAiB,SAASR,YAAY,CAACJ,OAAO,CAAC;EACnD;AACF;AACA;EACEa,WAAWA,CAACC,UAAU,EAAE;IACtB,KAAK,CAAC,eAAe,CAAC;IACtB,IAAIA,UAAU,IAAI,OAAOA,UAAU,KAAK,QAAQ,EAAE;MAChD,IAAI;QACF,IAAI,CAACC,GAAG,CAACD,UAAU,IAAI,CAAC,CAAC,CAAC;MAC5B,CAAC,CAAC,OAAOE,CAAC,EAAE;QACV,MAAM,IAAIC,KAAK,CAAC,sCAAsC,CAAC;MACzD;IACF;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAIC,aAAaA,CAAA,EAAG;IAClB,OAAO,IAAI,CAACC,GAAG,CAAC,eAAe,CAAC;EAClC;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAIC,UAAUA,CAAA,EAAG;IACf,OAAO,IAAI,CAACD,GAAG,CAAC,YAAY,CAAC;EAC/B;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAIE,OAAOA,CAAA,EAAG;IACZ,OAAO,IAAI,CAACF,GAAG,CAAC,SAAS,CAAC;EAC5B;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,IAAIG,KAAKA,CAAA,EAAG;IACV,OAAO,IAAI,CAACH,GAAG,CAAC,OAAO,CAAC;EAC1B;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAII,QAAQA,CAAA,EAAG;IACb,OAAO,IAAI,CAACJ,GAAG,CAAC,UAAU,CAAC;EAC7B;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAIK,WAAWA,CAAA,EAAG;IAChB,OAAO,IAAI,CAACL,GAAG,CAAC,aAAa,CAAC;EAChC;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAIM,UAAUA,CAAA,EAAG;IACf,OAAO,IAAI,CAACN,GAAG,CAAC,YAAY,CAAC;EAC/B;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAIO,WAAWA,CAAA,EAAG;IAChB,OAAO,IAAI,CAACP,GAAG,CAAC,aAAa,CAAC;EAChC;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAIQ,cAAcA,CAAA,EAAG;IACnB,OAAO,IAAI,CAACR,GAAG,CAAC,gBAAgB,CAAC;EACnC;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAIS,gBAAgBA,CAAA,EAAG;IACrB,OAAO,IAAI,CAACT,GAAG,CAAC,kBAAkB,CAAC;EACrC;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAIU,YAAYA,CAAA,EAAG;IACjB,OAAO,IAAI,CAACV,GAAG,CAAC,cAAc,CAAC;EACjC;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAIW,QAAQA,CAAA,EAAG;IACb,OAAO,IAAI,CAACX,GAAG,CAAC,UAAU,CAAC;EAC7B;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,IAAIY,QAAQA,CAAA,EAAG;IACb,OAAO,IAAI,CAACZ,GAAG,CAAC,UAAU,CAAC;EAC7B;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,WAAWd,YAAYA,CAAA,EAAG;IACxB,OAAOA,YAAY;EACrB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,MAAM2B,KAAKA,CAAA,EAAG;IACZ,KAAK,IAAIC,IAAI,GAAGC,SAAS,CAACC,MAAM,EAAEC,IAAI,GAAG,IAAIC,KAAK,CAACJ,IAAI,CAAC,EAAEK,IAAI,GAAG,CAAC,EAAEA,IAAI,GAAGL,IAAI,EAAEK,IAAI,EAAE,EAAE;MACvFF,IAAI,CAACE,IAAI,CAAC,GAAGJ,SAAS,CAACI,IAAI,CAAC;IAC9B;IACA,IAAI;MACF,MAAM,KAAK,CAACN,KAAK,CAACO,KAAK,CAAC,IAAI,EAAEH,IAAI,CAAC;IACrC,CAAC,CAAC,OAAOI,CAAC,EAAE;MACV,IAAIA,CAAC,CAACC,IAAI,KAAKtC,WAAW,CAACH,OAAO,CAAC0C,gBAAgB,EAAE;QACnD,MAAMF,CAAC;MACT;MACA;MACA;MACA,OAAO,IAAI,CAACG,EAAE;MACd,IAAI,CAACC,MAAM,CAAC,CAAC,CAAC,CAAC;MACf,IAAI,CAACC,mBAAmB,CAAC,CAAC;MAC1B,MAAM,KAAK,CAACC,IAAI,CAACP,KAAK,CAAC,IAAI,EAAEH,IAAI,CAAC;IACpC;IACA,MAAMlC,YAAY,CAACF,OAAO,CAAC+C,yBAAyB,CAAC,CAAC,CAACC,wBAAwB,CAAC,IAAI,CAAC;IACrF,OAAO,IAAI;EACb;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE,MAAMF,IAAIA,CAAA,EAAG;IACX,KAAK,IAAIG,KAAK,GAAGf,SAAS,CAACC,MAAM,EAAEC,IAAI,GAAG,IAAIC,KAAK,CAACY,KAAK,CAAC,EAAEC,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGD,KAAK,EAAEC,KAAK,EAAE,EAAE;MAC7Fd,IAAI,CAACc,KAAK,CAAC,GAAGhB,SAAS,CAACgB,KAAK,CAAC;IAChC;IACA,IAAI;MACF,MAAM,KAAK,CAACJ,IAAI,CAACP,KAAK,CAAC,IAAI,EAAEH,IAAI,CAAC;IACpC,CAAC,CAAC,OAAOI,CAAC,EAAE;MACV,IAAIA,CAAC,CAACC,IAAI,KAAKtC,WAAW,CAACH,OAAO,CAAC0C,gBAAgB,EAAE;QACnD,MAAMF,CAAC;MACT;MACA;MACA;MACA,OAAO,IAAI,CAACG,EAAE;MACd,IAAI,CAACC,MAAM,CAAC,CAAC,CAAC,CAAC;MACf,IAAI,CAACC,mBAAmB,CAAC,CAAC;MAC1B,MAAM,KAAK,CAACC,IAAI,CAACP,KAAK,CAAC,IAAI,EAAEH,IAAI,CAAC;IACpC;IACA,MAAMlC,YAAY,CAACF,OAAO,CAAC+C,yBAAyB,CAAC,CAAC,CAACC,wBAAwB,CAAC,IAAI,CAAC;IACrF,OAAO,IAAI;EACb;EACAH,mBAAmBA,CAAA,EAAG;IACpB,KAAK,MAAM,CAACM,GAAG,EAAEpD,KAAK,CAAC,IAAI,CAAC,CAAC,EAAEE,QAAQ,CAACD,OAAO,EAAE,IAAI,CAACc,UAAU,CAAC,EAAE;MACjE,IAAI,CAACC,GAAG,CAACoC,GAAG,EAAEpD,KAAK,CAAC;IACtB;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,OAAOqD,mBAAmBA,CAAA,EAAG;IAC3B,OAAOlD,YAAY,CAACF,OAAO,CAAC+C,yBAAyB,CAAC,CAAC,CAACK,mBAAmB,CAAC,CAAC;EAC/E;AACF;AACAhD,YAAY,CAACJ,OAAO,CAACqD,gBAAgB,CAAC,eAAe,EAAEzC,iBAAiB,CAAC;AACzE,IAAI0C,QAAQ,GAAGxD,OAAO,CAACE,OAAO,GAAGY,iBAAiB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}