{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _isArray = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\nvar _ParseGeoPoint = _interopRequireDefault(require(\"./ParseGeoPoint\"));\n/**\n * Creates a new Polygon with any of the following forms:<br>\n *   <pre>\n *   new Polygon([[0,0],[0,1],[1,1],[1,0]])\n *   new Polygon([GeoPoint, GeoPoint, GeoPoint])\n *   </pre>\n *\n * <p>Represents a coordinates that may be associated\n * with a key in a ParseObject or used as a reference point for geo queries.\n * This allows proximity-based queries on the key.</p>\n *\n * <p>Example:<pre>\n *   var polygon = new Parse.Polygon([[0,0],[0,1],[1,1],[1,0]]);\n *   var object = new Parse.Object(\"PlaceObject\");\n *   object.set(\"area\", polygon);\n *   object.save();</pre></p>\n *\n * @alias Parse.Polygon\n */\nclass ParsePolygon {\n  /**\n   * @param {(Coordinates | Parse.GeoPoint[])} coordinates An Array of coordinate pairs\n   */\n  constructor(coordinates) {\n    (0, _defineProperty2.default)(this, \"_coordinates\", void 0);\n    this._coordinates = ParsePolygon._validate(coordinates);\n  }\n\n  /**\n   * Coordinates value for this Polygon.\n   * Throws an exception if not valid type.\n   *\n   * @property {(Coordinates | Parse.GeoPoint[])} coordinates list of coordinates\n   * @returns {Coordinates}\n   */\n  get coordinates() {\n    return this._coordinates;\n  }\n  set coordinates(coords) {\n    this._coordinates = ParsePolygon._validate(coords);\n  }\n\n  /**\n   * Returns a JSON representation of the Polygon, suitable for Parse.\n   *\n   * @returns {object}\n   */\n  toJSON() {\n    ParsePolygon._validate(this._coordinates);\n    return {\n      __type: 'Polygon',\n      coordinates: this._coordinates\n    };\n  }\n\n  /**\n   * Checks if two polygons are equal\n   *\n   * @param {(Parse.Polygon | object)} other\n   * @returns {boolean}\n   */\n  equals(other) {\n    if (!(other instanceof ParsePolygon) || this.coordinates.length !== other.coordinates.length) {\n      return false;\n    }\n    let isEqual = true;\n    for (let i = 1; i < this._coordinates.length; i += 1) {\n      if (this._coordinates[i][0] != other.coordinates[i][0] || this._coordinates[i][1] != other.coordinates[i][1]) {\n        isEqual = false;\n        break;\n      }\n    }\n    return isEqual;\n  }\n\n  /**\n   *\n   * @param {Parse.GeoPoint} point\n   * @returns {boolean} Returns if the point is contained in the polygon\n   */\n  containsPoint(point) {\n    let minX = this._coordinates[0][0];\n    let maxX = this._coordinates[0][0];\n    let minY = this._coordinates[0][1];\n    let maxY = this._coordinates[0][1];\n    for (let i = 1; i < this._coordinates.length; i += 1) {\n      const p = this._coordinates[i];\n      minX = Math.min(p[0], minX);\n      maxX = Math.max(p[0], maxX);\n      minY = Math.min(p[1], minY);\n      maxY = Math.max(p[1], maxY);\n    }\n    const outside = point.latitude < minX || point.latitude > maxX || point.longitude < minY || point.longitude > maxY;\n    if (outside) {\n      return false;\n    }\n    let inside = false;\n    for (let i = 0, j = this._coordinates.length - 1; i < this._coordinates.length; j = i++) {\n      const startX = this._coordinates[i][0];\n      const startY = this._coordinates[i][1];\n      const endX = this._coordinates[j][0];\n      const endY = this._coordinates[j][1];\n      const intersect = startY > point.longitude != endY > point.longitude && point.latitude < (endX - startX) * (point.longitude - startY) / (endY - startY) + startX;\n      if (intersect) {\n        inside = !inside;\n      }\n    }\n    return inside;\n  }\n\n  /**\n   * Validates that the list of coordinates can form a valid polygon\n   *\n   * @param {Array} coords the list of coordinates to validate as a polygon\n   * @throws {TypeError}\n   * @returns {number[][]} Array of coordinates if validated.\n   */\n  static _validate(coords) {\n    if (!(0, _isArray.default)(coords)) {\n      throw new TypeError('Coordinates must be an Array');\n    }\n    if (coords.length < 3) {\n      throw new TypeError('Polygon must have at least 3 GeoPoints or Points');\n    }\n    const points = [];\n    for (let i = 0; i < coords.length; i += 1) {\n      const coord = coords[i];\n      let geoPoint;\n      if (coord instanceof _ParseGeoPoint.default) {\n        geoPoint = coord;\n      } else if ((0, _isArray.default)(coord) && coord.length === 2) {\n        geoPoint = new _ParseGeoPoint.default(coord[0], coord[1]);\n      } else {\n        throw new TypeError('Coordinates must be an Array of GeoPoints or Points');\n      }\n      points.push([geoPoint.latitude, geoPoint.longitude]);\n    }\n    return points;\n  }\n}\nvar _default = exports.default = ParsePolygon;","map":{"version":3,"names":["_Object$defineProperty","require","_interopRequireDefault","exports","value","default","_isArray","_defineProperty2","_ParseGeoPoint","ParsePolygon","constructor","coordinates","_coordinates","_validate","coords","toJSON","__type","equals","other","length","isEqual","i","containsPoint","point","minX","maxX","minY","maxY","p","Math","min","max","outside","latitude","longitude","inside","j","startX","startY","endX","endY","intersect","TypeError","points","coord","geoPoint","push","_default"],"sources":["/home/snx/Desktop/CS_School/node_modules/parse/lib/browser/ParsePolygon.js"],"sourcesContent":["\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _isArray = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\nvar _ParseGeoPoint = _interopRequireDefault(require(\"./ParseGeoPoint\"));\n/**\n * Creates a new Polygon with any of the following forms:<br>\n *   <pre>\n *   new Polygon([[0,0],[0,1],[1,1],[1,0]])\n *   new Polygon([GeoPoint, GeoPoint, GeoPoint])\n *   </pre>\n *\n * <p>Represents a coordinates that may be associated\n * with a key in a ParseObject or used as a reference point for geo queries.\n * This allows proximity-based queries on the key.</p>\n *\n * <p>Example:<pre>\n *   var polygon = new Parse.Polygon([[0,0],[0,1],[1,1],[1,0]]);\n *   var object = new Parse.Object(\"PlaceObject\");\n *   object.set(\"area\", polygon);\n *   object.save();</pre></p>\n *\n * @alias Parse.Polygon\n */\nclass ParsePolygon {\n  /**\n   * @param {(Coordinates | Parse.GeoPoint[])} coordinates An Array of coordinate pairs\n   */\n  constructor(coordinates) {\n    (0, _defineProperty2.default)(this, \"_coordinates\", void 0);\n    this._coordinates = ParsePolygon._validate(coordinates);\n  }\n\n  /**\n   * Coordinates value for this Polygon.\n   * Throws an exception if not valid type.\n   *\n   * @property {(Coordinates | Parse.GeoPoint[])} coordinates list of coordinates\n   * @returns {Coordinates}\n   */\n  get coordinates() {\n    return this._coordinates;\n  }\n  set coordinates(coords) {\n    this._coordinates = ParsePolygon._validate(coords);\n  }\n\n  /**\n   * Returns a JSON representation of the Polygon, suitable for Parse.\n   *\n   * @returns {object}\n   */\n  toJSON() {\n    ParsePolygon._validate(this._coordinates);\n    return {\n      __type: 'Polygon',\n      coordinates: this._coordinates\n    };\n  }\n\n  /**\n   * Checks if two polygons are equal\n   *\n   * @param {(Parse.Polygon | object)} other\n   * @returns {boolean}\n   */\n  equals(other) {\n    if (!(other instanceof ParsePolygon) || this.coordinates.length !== other.coordinates.length) {\n      return false;\n    }\n    let isEqual = true;\n    for (let i = 1; i < this._coordinates.length; i += 1) {\n      if (this._coordinates[i][0] != other.coordinates[i][0] || this._coordinates[i][1] != other.coordinates[i][1]) {\n        isEqual = false;\n        break;\n      }\n    }\n    return isEqual;\n  }\n\n  /**\n   *\n   * @param {Parse.GeoPoint} point\n   * @returns {boolean} Returns if the point is contained in the polygon\n   */\n  containsPoint(point) {\n    let minX = this._coordinates[0][0];\n    let maxX = this._coordinates[0][0];\n    let minY = this._coordinates[0][1];\n    let maxY = this._coordinates[0][1];\n    for (let i = 1; i < this._coordinates.length; i += 1) {\n      const p = this._coordinates[i];\n      minX = Math.min(p[0], minX);\n      maxX = Math.max(p[0], maxX);\n      minY = Math.min(p[1], minY);\n      maxY = Math.max(p[1], maxY);\n    }\n    const outside = point.latitude < minX || point.latitude > maxX || point.longitude < minY || point.longitude > maxY;\n    if (outside) {\n      return false;\n    }\n    let inside = false;\n    for (let i = 0, j = this._coordinates.length - 1; i < this._coordinates.length; j = i++) {\n      const startX = this._coordinates[i][0];\n      const startY = this._coordinates[i][1];\n      const endX = this._coordinates[j][0];\n      const endY = this._coordinates[j][1];\n      const intersect = startY > point.longitude != endY > point.longitude && point.latitude < (endX - startX) * (point.longitude - startY) / (endY - startY) + startX;\n      if (intersect) {\n        inside = !inside;\n      }\n    }\n    return inside;\n  }\n\n  /**\n   * Validates that the list of coordinates can form a valid polygon\n   *\n   * @param {Array} coords the list of coordinates to validate as a polygon\n   * @throws {TypeError}\n   * @returns {number[][]} Array of coordinates if validated.\n   */\n  static _validate(coords) {\n    if (!(0, _isArray.default)(coords)) {\n      throw new TypeError('Coordinates must be an Array');\n    }\n    if (coords.length < 3) {\n      throw new TypeError('Polygon must have at least 3 GeoPoints or Points');\n    }\n    const points = [];\n    for (let i = 0; i < coords.length; i += 1) {\n      const coord = coords[i];\n      let geoPoint;\n      if (coord instanceof _ParseGeoPoint.default) {\n        geoPoint = coord;\n      } else if ((0, _isArray.default)(coord) && coord.length === 2) {\n        geoPoint = new _ParseGeoPoint.default(coord[0], coord[1]);\n      } else {\n        throw new TypeError('Coordinates must be an Array of GeoPoints or Points');\n      }\n      points.push([geoPoint.latitude, geoPoint.longitude]);\n    }\n    return points;\n  }\n}\nvar _default = exports.default = ParsePolygon;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}