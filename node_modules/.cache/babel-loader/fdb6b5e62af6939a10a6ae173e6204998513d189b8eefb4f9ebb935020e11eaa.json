{"ast":null,"code":"\"use strict\";\n\nvar _WeakMap = require(\"@babel/runtime-corejs3/core-js-stable/weak-map\");\nvar _Object$defineProperty2 = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\nvar _Object$getOwnPropertyDescriptor = require(\"@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor\");\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n_Object$defineProperty2(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\nvar _create = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/create\"));\nvar _indexOf = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/index-of\"));\nvar _for = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/symbol/for\"));\nvar _stringify = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/json/stringify\"));\nvar _freeze = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/freeze\"));\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/keys\"));\nvar _forEach = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/for-each\"));\nvar _includes = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/includes\"));\nvar _getPrototypeOf = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/get-prototype-of\"));\nvar _concat = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/concat\"));\nvar _some = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/some\"));\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/promise\"));\nvar _isArray = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\"));\nvar _defineProperty3 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\"));\nvar _find = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/find\"));\nvar _map = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/map\"));\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\nvar _canBeSerialized = _interopRequireDefault(require(\"./canBeSerialized\"));\nvar _decode = _interopRequireDefault(require(\"./decode\"));\nvar _encode = _interopRequireDefault(require(\"./encode\"));\nvar _escape = _interopRequireDefault(require(\"./escape\"));\nvar _ParseACL = _interopRequireDefault(require(\"./ParseACL\"));\nvar _parseDate = _interopRequireDefault(require(\"./parseDate\"));\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\nvar _ParseFile = _interopRequireDefault(require(\"./ParseFile\"));\nvar _promiseUtils = require(\"./promiseUtils\");\nvar _LocalDatastoreUtils = require(\"./LocalDatastoreUtils\");\nvar _uuid = _interopRequireDefault(require(\"./uuid\"));\nvar _ParseOp = require(\"./ParseOp\");\nvar _ParseRelation = _interopRequireDefault(require(\"./ParseRelation\"));\nvar SingleInstanceStateController = _interopRequireWildcard(require(\"./SingleInstanceStateController\"));\nvar _unique = _interopRequireDefault(require(\"./unique\"));\nvar UniqueInstanceStateController = _interopRequireWildcard(require(\"./UniqueInstanceStateController\"));\nvar _unsavedChildren = _interopRequireDefault(require(\"./unsavedChildren\"));\nfunction _interopRequireWildcard(e, t) {\n  if (\"function\" == typeof _WeakMap) var r = new _WeakMap(),\n    n = new _WeakMap();\n  return (_interopRequireWildcard = function (e, t) {\n    if (!t && e && e.__esModule) return e;\n    var o,\n      i,\n      f = {\n        __proto__: null,\n        default: e\n      };\n    if (null === e || \"object\" != typeof e && \"function\" != typeof e) return f;\n    if (o = t ? n : r) {\n      if (o.has(e)) return o.get(e);\n      o.set(e, f);\n    }\n    for (const t in e) \"default\" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = _Object$defineProperty2) && _Object$getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]);\n    return f;\n  })(e, t);\n}\n// Mapping of class names to constructors, so we can populate objects from the\n// server with appropriate subclasses of ParseObject\nconst classMap = (0, _create.default)(null);\n\n// Global counter for generating unique Ids for non-single-instance objects\nlet objectCount = 0;\n// On web clients, objects are single-instance: any two objects with the same Id\n// will have the same attributes. However, this may be dangerous default\n// behavior in a server scenario\nlet singleInstance = !_CoreManager.default.get('IS_NODE');\nif (singleInstance) {\n  _CoreManager.default.setObjectStateController(SingleInstanceStateController);\n} else {\n  _CoreManager.default.setObjectStateController(UniqueInstanceStateController);\n}\nfunction getServerUrlPath() {\n  let serverUrl = _CoreManager.default.get('SERVER_URL');\n  if (serverUrl[serverUrl.length - 1] !== '/') {\n    serverUrl += '/';\n  }\n  const url = serverUrl.replace(/https?:\\/\\//, '');\n  return url.substr((0, _indexOf.default)(url).call(url, '/'));\n}\n\n/**\n * Creates a new model with defined attributes.\n *\n * <p>You won't normally call this method directly.  It is recommended that\n * you use a subclass of <code>Parse.Object</code> instead, created by calling\n * <code>extend</code>.</p>\n *\n * <p>However, if you don't want to use a subclass, or aren't sure which\n * subclass is appropriate, you can use this form:<pre>\n *     var object = new Parse.Object(\"ClassName\");\n * </pre>\n * That is basically equivalent to:<pre>\n *     var MyClass = Parse.Object.extend(\"ClassName\");\n *     var object = new MyClass();\n * </pre></p>\n *\n * @alias Parse.Object\n */\nclass ParseObject {\n  /**\n   * @param {string} className The class name for the object\n   * @param {object} attributes The initial set of data to store in the object.\n   * @param {object} options The options for this object instance.\n   * @param {boolean} [options.ignoreValidation] Set to `true` ignore any attribute validation errors.\n   */\n  constructor(className, attributes, options) {\n    /**\n     * The ID of this object, unique within its class.\n     *\n     * @property {string} id\n     */\n    (0, _defineProperty2.default)(this, \"id\", void 0);\n    (0, _defineProperty2.default)(this, \"_localId\", void 0);\n    (0, _defineProperty2.default)(this, \"_objCount\", void 0);\n    (0, _defineProperty2.default)(this, \"className\", void 0);\n    // Enable legacy initializers\n    if (typeof this.initialize === 'function') {\n      this.initialize.apply(this, arguments);\n    }\n    let toSet = null;\n    this._objCount = objectCount++;\n    if (typeof className === 'string') {\n      this.className = className;\n      if (attributes && typeof attributes === 'object') {\n        toSet = attributes;\n      }\n    } else if (className && typeof className === 'object') {\n      this.className = className.className;\n      toSet = {};\n      for (const attr in className) {\n        if (attr !== 'className') {\n          toSet[attr] = className[attr];\n        }\n      }\n      if (attributes && typeof attributes === 'object') {\n        options = attributes;\n      }\n    }\n    if (toSet) {\n      try {\n        this.set(toSet, options);\n      } catch (_) {\n        throw new Error(\"Can't create an invalid Parse Object\");\n      }\n    }\n    if (_CoreManager.default.get('NODE_LOGGING')) {\n      this[(0, _for.default)('nodejs.util.inspect.custom')] = function () {\n        return `ParseObject: className: ${this.className}, id: ${this.id}\\nAttributes: ${(0, _stringify.default)(this.attributes, null, 2)}`;\n      };\n    }\n  }\n  /* Prototype getters / setters */\n\n  get attributes() {\n    const stateController = _CoreManager.default.getObjectStateController();\n    return (0, _freeze.default)(stateController.estimateAttributes(this._getStateIdentifier()));\n  }\n\n  /**\n   * The first time this object was saved on the server.\n   *\n   * @property {Date} createdAt\n   * @returns {Date}\n   */\n  get createdAt() {\n    return this._getServerData().createdAt;\n  }\n\n  /**\n   * The last time this object was updated on the server.\n   *\n   * @property {Date} updatedAt\n   * @returns {Date}\n   */\n  get updatedAt() {\n    return this._getServerData().updatedAt;\n  }\n\n  /* Private methods */\n\n  /**\n   * Returns a local or server Id used uniquely identify this object\n   *\n   * @returns {string}\n   */\n  _getId() {\n    if (typeof this.id === 'string') {\n      return this.id;\n    }\n    if (typeof this._localId === 'string') {\n      return this._localId;\n    }\n    const localId = 'local' + (0, _uuid.default)();\n    this._localId = localId;\n    return localId;\n  }\n\n  /**\n   * Returns a unique identifier used to pull data from the State Controller.\n   *\n   * @returns {Parse.Object|object}\n   */\n  _getStateIdentifier() {\n    if (singleInstance) {\n      let id = this.id;\n      if (!id) {\n        id = this._getId();\n      }\n      return {\n        id,\n        className: this.className\n      };\n    } else {\n      return this;\n    }\n  }\n  _getServerData() {\n    const stateController = _CoreManager.default.getObjectStateController();\n    return stateController.getServerData(this._getStateIdentifier());\n  }\n  _clearServerData() {\n    const serverData = this._getServerData();\n    const unset = {};\n    for (const attr in serverData) {\n      unset[attr] = undefined;\n    }\n    const stateController = _CoreManager.default.getObjectStateController();\n    stateController.setServerData(this._getStateIdentifier(), unset);\n  }\n  _getPendingOps() {\n    const stateController = _CoreManager.default.getObjectStateController();\n    return stateController.getPendingOps(this._getStateIdentifier());\n  }\n\n  /**\n   * @param {Array<string>} [keysToClear] - if specified, only ops matching\n   * these fields will be cleared\n   */\n  _clearPendingOps(keysToClear) {\n    const pending = this._getPendingOps();\n    const latest = pending[pending.length - 1];\n    const keys = keysToClear || (0, _keys.default)(latest);\n    (0, _forEach.default)(keys).call(keys, key => {\n      delete latest[key];\n    });\n  }\n  _getDirtyObjectAttributes() {\n    const attributes = this.attributes;\n    const stateController = _CoreManager.default.getObjectStateController();\n    const objectCache = stateController.getObjectCache(this._getStateIdentifier());\n    const dirty = {};\n    for (const attr in attributes) {\n      const val = attributes[attr];\n      if (val && typeof val === 'object' && !(val instanceof ParseObject) && !(val instanceof _ParseFile.default) && !(val instanceof _ParseRelation.default)) {\n        // Due to the way browsers construct maps, the key order will not change\n        // unless the object is changed\n        try {\n          const json = (0, _encode.default)(val, false, true);\n          const stringified = (0, _stringify.default)(json);\n          if (objectCache[attr] !== stringified) {\n            dirty[attr] = val;\n          }\n        } catch (_) {\n          // Error occurred, possibly by a nested unsaved pointer in a mutable container\n          // No matter how it happened, it indicates a change in the attribute\n          dirty[attr] = val;\n        }\n      }\n    }\n    return dirty;\n  }\n  _toFullJSON(seen, offline) {\n    const json = this.toJSON(seen, offline);\n    json.__type = 'Object';\n    json.className = this.className;\n    return json;\n  }\n  _getSaveJSON() {\n    const pending = this._getPendingOps();\n    const dirtyObjects = this._getDirtyObjectAttributes();\n    const json = {};\n    for (var attr in dirtyObjects) {\n      let isDotNotation = false;\n      for (let i = 0; i < pending.length; i += 1) {\n        for (const field in pending[i]) {\n          // Dot notation operations are handled later\n          if ((0, _includes.default)(field).call(field, '.')) {\n            const fieldName = field.split('.')[0];\n            if (fieldName === attr) {\n              isDotNotation = true;\n              break;\n            }\n          }\n        }\n      }\n      if (!isDotNotation) {\n        json[attr] = new _ParseOp.SetOp(dirtyObjects[attr]).toJSON();\n      }\n    }\n    for (attr in pending[0]) {\n      json[attr] = pending[0][attr].toJSON();\n    }\n    return json;\n  }\n  _getSaveParams() {\n    let method = this.id ? 'PUT' : 'POST';\n    const body = this._getSaveJSON();\n    let path = 'classes/' + this.className;\n    if (_CoreManager.default.get('ALLOW_CUSTOM_OBJECT_ID')) {\n      if (!this.createdAt) {\n        method = 'POST';\n        body.objectId = this.id;\n      } else {\n        method = 'PUT';\n        path += '/' + this.id;\n      }\n    } else if (this.id) {\n      path += '/' + this.id;\n    } else if (this.className === '_User') {\n      path = 'users';\n    }\n    return {\n      method,\n      body,\n      path\n    };\n  }\n  _finishFetch(serverData) {\n    if (!this.id && serverData.objectId) {\n      this.id = serverData.objectId;\n    }\n    const stateController = _CoreManager.default.getObjectStateController();\n    stateController.initializeState(this._getStateIdentifier());\n    const decoded = {};\n    for (const attr in serverData) {\n      if (attr === 'ACL') {\n        decoded[attr] = new _ParseACL.default(serverData[attr]);\n      } else if (attr !== 'objectId') {\n        decoded[attr] = (0, _decode.default)(serverData[attr]);\n        if (decoded[attr] instanceof _ParseRelation.default) {\n          decoded[attr]._ensureParentAndKey(this, attr);\n        }\n      }\n    }\n    if (decoded.createdAt && typeof decoded.createdAt === 'string') {\n      decoded.createdAt = (0, _parseDate.default)(decoded.createdAt);\n    }\n    if (decoded.updatedAt && typeof decoded.updatedAt === 'string') {\n      decoded.updatedAt = (0, _parseDate.default)(decoded.updatedAt);\n    }\n    if (!decoded.updatedAt && decoded.createdAt) {\n      decoded.updatedAt = decoded.createdAt;\n    }\n    stateController.commitServerChanges(this._getStateIdentifier(), decoded);\n  }\n  _setExisted(existed) {\n    const stateController = _CoreManager.default.getObjectStateController();\n    const state = stateController.getState(this._getStateIdentifier());\n    if (state) {\n      state.existed = existed;\n    }\n  }\n  _migrateId(serverId) {\n    if (this._localId && serverId) {\n      if (singleInstance) {\n        const stateController = _CoreManager.default.getObjectStateController();\n        const oldState = stateController.removeState(this._getStateIdentifier());\n        this.id = serverId;\n        delete this._localId;\n        if (oldState) {\n          stateController.initializeState(this._getStateIdentifier(), oldState);\n        }\n      } else {\n        this.id = serverId;\n        delete this._localId;\n      }\n    }\n  }\n  _handleSaveResponse(response, status) {\n    const changes = {};\n    const stateController = _CoreManager.default.getObjectStateController();\n    const pending = stateController.popPendingState(this._getStateIdentifier());\n    for (var attr in pending) {\n      if (pending[attr] instanceof _ParseOp.RelationOp) {\n        changes[attr] = pending[attr].applyTo(undefined, this, attr);\n      } else if (!(attr in response)) {\n        // Only SetOps and UnsetOps should not come back with results\n        changes[attr] = pending[attr].applyTo(undefined);\n      }\n    }\n    for (attr in response) {\n      if ((attr === 'createdAt' || attr === 'updatedAt') && typeof response[attr] === 'string') {\n        changes[attr] = (0, _parseDate.default)(response[attr]);\n      } else if (attr === 'ACL') {\n        changes[attr] = new _ParseACL.default(response[attr]);\n      } else if (attr !== 'objectId') {\n        const val = (0, _decode.default)(response[attr]);\n        if (val && (0, _getPrototypeOf.default)(val) === Object.prototype) {\n          changes[attr] = {\n            ...this.attributes[attr],\n            ...val\n          };\n        } else {\n          changes[attr] = val;\n        }\n        if (changes[attr] instanceof _ParseOp.UnsetOp) {\n          changes[attr] = undefined;\n        }\n      }\n    }\n    if (changes.createdAt && !changes.updatedAt) {\n      changes.updatedAt = changes.createdAt;\n    }\n    this._migrateId(response.objectId);\n    if (status !== 201) {\n      this._setExisted(true);\n    }\n    stateController.commitServerChanges(this._getStateIdentifier(), changes);\n  }\n  _handleSaveError() {\n    const stateController = _CoreManager.default.getObjectStateController();\n    stateController.mergeFirstPendingState(this._getStateIdentifier());\n  }\n  static _getClassMap() {\n    return classMap;\n  }\n  static _getRequestOptions() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const requestOptions = {};\n    if (Object.prototype.toString.call(options) !== '[object Object]') {\n      throw new Error('request options must be of type Object');\n    }\n    const {\n      hasOwn\n    } = Object;\n    if (hasOwn(options, 'useMasterKey')) {\n      requestOptions.useMasterKey = !!options.useMasterKey;\n    }\n    if (hasOwn(options, 'useMaintenanceKey')) {\n      requestOptions.useMaintenanceKey = !!options.useMaintenanceKey;\n    }\n    if (hasOwn(options, 'sessionToken') && typeof options.sessionToken === 'string') {\n      requestOptions.sessionToken = options.sessionToken;\n    }\n    if (hasOwn(options, 'installationId') && typeof options.installationId === 'string') {\n      requestOptions.installationId = options.installationId;\n    }\n    if (hasOwn(options, 'transaction') && typeof options.transaction === 'boolean') {\n      requestOptions.transaction = options.transaction;\n    }\n    if (hasOwn(options, 'batchSize') && typeof options.batchSize === 'number') {\n      requestOptions.batchSize = options.batchSize;\n    }\n    if (hasOwn(options, 'context') && typeof options.context === 'object') {\n      requestOptions.context = options.context;\n    }\n    if (hasOwn(options, 'include')) {\n      requestOptions.include = ParseObject.handleIncludeOptions(options);\n    }\n    if (hasOwn(options, 'usePost')) {\n      requestOptions.usePost = options.usePost;\n    }\n    if (hasOwn(options, 'json')) {\n      requestOptions.json = options.json;\n    }\n    return requestOptions;\n  }\n\n  /* Public methods */\n\n  initialize() {\n    // NOOP\n  }\n\n  /**\n   * Returns a JSON version of the object suitable for saving to Parse.\n   *\n   * @param seen\n   * @param offline\n   * @returns {object}\n   */\n  toJSON(seen, offline) {\n    const seenEntry = this.id ? this.className + ':' + this.id : this;\n    seen = seen || [seenEntry];\n    const json = {};\n    const attrs = this.attributes;\n    for (const attr in attrs) {\n      if ((attr === 'createdAt' || attr === 'updatedAt') && attrs[attr].toJSON) {\n        json[attr] = attrs[attr].toJSON();\n      } else {\n        json[attr] = (0, _encode.default)(attrs[attr], false, false, seen, offline);\n      }\n    }\n    const pending = this._getPendingOps();\n    for (const attr in pending[0]) {\n      if ((0, _indexOf.default)(attr).call(attr, '.') < 0) {\n        json[attr] = pending[0][attr].toJSON(offline);\n      }\n    }\n    if (this.id) {\n      json.objectId = this.id;\n    }\n    return json;\n  }\n\n  /**\n   * Determines whether this ParseObject is equal to another ParseObject\n   *\n   * @param {object} other - An other object ot compare\n   * @returns {boolean}\n   */\n  equals(other) {\n    if (this === other) {\n      return true;\n    }\n    return other instanceof ParseObject && this.className === other.className && this.id === other.id && typeof this.id !== 'undefined';\n  }\n\n  /**\n   * Returns true if this object has been modified since its last\n   * save/refresh.  If an attribute is specified, it returns true only if that\n   * particular attribute has been modified since the last save/refresh.\n   *\n   * @param {string} attr An attribute name (optional).\n   * @returns {boolean}\n   */\n  dirty(attr) {\n    if (!this.id) {\n      return true;\n    }\n    const pendingOps = this._getPendingOps();\n    const dirtyObjects = this._getDirtyObjectAttributes();\n    if (attr) {\n      if (Object.hasOwn(dirtyObjects, attr)) {\n        return true;\n      }\n      for (let i = 0; i < pendingOps.length; i++) {\n        if (Object.hasOwn(pendingOps[i], attr)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    if ((0, _keys.default)(pendingOps[0]).length !== 0) {\n      return true;\n    }\n    if ((0, _keys.default)(dirtyObjects).length !== 0) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Returns an array of keys that have been modified since last save/refresh\n   *\n   * @returns {string[]}\n   */\n  dirtyKeys() {\n    const pendingOps = this._getPendingOps();\n    const keys = {};\n    for (let i = 0; i < pendingOps.length; i++) {\n      for (const attr in pendingOps[i]) {\n        keys[attr] = true;\n      }\n    }\n    const dirtyObjects = this._getDirtyObjectAttributes();\n    for (const attr in dirtyObjects) {\n      keys[attr] = true;\n    }\n    return (0, _keys.default)(keys);\n  }\n\n  /**\n   * Returns true if the object has been fetched.\n   *\n   * @returns {boolean}\n   */\n  isDataAvailable() {\n    const serverData = this._getServerData();\n    return !!(0, _keys.default)(serverData).length;\n  }\n\n  /**\n   * Gets a Pointer referencing this Object.\n   *\n   * @returns {Pointer}\n   */\n  toPointer() {\n    if (!this.id) {\n      throw new Error('Cannot create a pointer to an unsaved ParseObject');\n    }\n    return {\n      __type: 'Pointer',\n      className: this.className,\n      objectId: this.id\n    };\n  }\n\n  /**\n   * Gets a Pointer referencing this Object.\n   *\n   * @returns {Pointer}\n   */\n  toOfflinePointer() {\n    if (!this._localId) {\n      throw new Error('Cannot create a offline pointer to a saved ParseObject');\n    }\n    return {\n      __type: 'Object',\n      className: this.className,\n      _localId: this._localId\n    };\n  }\n\n  /**\n   * Gets the value of an attribute.\n   *\n   * @param {string} attr The string name of an attribute.\n   * @returns {*}\n   */\n  get(attr) {\n    return this.attributes[attr];\n  }\n\n  /**\n   * Gets a relation on the given class for the attribute.\n   *\n   * @param {string} attr The attribute to get the relation for.\n   * @returns {Parse.Relation}\n   */\n  relation(attr) {\n    const value = this.get(attr);\n    if (value) {\n      if (!(value instanceof _ParseRelation.default)) {\n        throw new Error('Called relation() on non-relation field ' + attr);\n      }\n      value._ensureParentAndKey(this, attr);\n      return value;\n    }\n    return new _ParseRelation.default(this, attr);\n  }\n\n  /**\n   * Gets the HTML-escaped value of an attribute.\n   *\n   * @param {string} attr The string name of an attribute.\n   * @returns {string}\n   */\n  escape(attr) {\n    let val = this.attributes[attr];\n    if (val == null) {\n      return '';\n    }\n    if (typeof val !== 'string') {\n      if (typeof val.toString !== 'function') {\n        return '';\n      }\n      val = val.toString();\n    }\n    return (0, _escape.default)(val);\n  }\n\n  /**\n   * Returns <code>true</code> if the attribute contains a value that is not\n   * null or undefined.\n   *\n   * @param {string} attr The string name of the attribute.\n   * @returns {boolean}\n   */\n  has(attr) {\n    const attributes = this.attributes;\n    if (Object.hasOwn(attributes, attr)) {\n      return attributes[attr] != null;\n    }\n    return false;\n  }\n\n  /**\n   * Sets a hash of model attributes on the object.\n   *\n   * <p>You can call it with an object containing keys and values, with one\n   * key and value, or dot notation.  For example:<pre>\n   *   gameTurn.set({\n   *     player: player1,\n   *     diceRoll: 2\n   *   }, {\n   *     error: function(gameTurnAgain, error) {\n   *       // The set failed validation.\n   *     }\n   *   });\n   *\n   *   game.set(\"currentPlayer\", player2, {\n   *     error: function(gameTurnAgain, error) {\n   *       // The set failed validation.\n   *     }\n   *   });\n   *\n   *   game.set(\"finished\", true);</pre></p>\n   *\n   *   game.set(\"player.score\", 10);</pre></p>\n   *\n   * @param {(string|object)} key The key to set.\n   * @param {(string|object)} value The value to give it.\n   * @param {object} options A set of options for the set.\n   *     The only supported option is <code>error</code>.\n   * @returns {Parse.Object} Returns the object, so you can chain this call.\n   */\n  set(key, value, options) {\n    let changes = {};\n    const newOps = {};\n    if (key && typeof key === 'object') {\n      changes = key;\n      options = value;\n    } else if (typeof key === 'string') {\n      changes[key] = value;\n    } else {\n      return this;\n    }\n    options = options || {};\n    let readonly = [];\n    if (typeof this.constructor.readOnlyAttributes === 'function') {\n      readonly = (0, _concat.default)(readonly).call(readonly, this.constructor.readOnlyAttributes());\n    }\n    for (const k in changes) {\n      if (k === 'createdAt' || k === 'updatedAt') {\n        // This property is read-only, but for legacy reasons we silently\n        // ignore it\n        continue;\n      }\n      if ((0, _indexOf.default)(readonly).call(readonly, k) > -1) {\n        throw new Error('Cannot modify readonly attribute: ' + k);\n      }\n      if (options.unset) {\n        newOps[k] = new _ParseOp.UnsetOp();\n      } else if (changes[k] instanceof _ParseOp.Op) {\n        newOps[k] = changes[k];\n      } else if (changes[k] && typeof changes[k] === 'object' && typeof changes[k].__op === 'string') {\n        newOps[k] = (0, _ParseOp.opFromJSON)(changes[k]);\n      } else if (k === 'objectId' || k === 'id') {\n        if (typeof changes[k] === 'string') {\n          this.id = changes[k];\n        }\n      } else if (k === 'ACL' && typeof changes[k] === 'object' && !(changes[k] instanceof _ParseACL.default)) {\n        newOps[k] = new _ParseOp.SetOp(new _ParseACL.default(changes[k]));\n      } else if (changes[k] instanceof _ParseRelation.default) {\n        const relation = new _ParseRelation.default(this, k);\n        relation.targetClassName = changes[k].targetClassName;\n        newOps[k] = new _ParseOp.SetOp(relation);\n      } else {\n        newOps[k] = new _ParseOp.SetOp(changes[k]);\n      }\n    }\n    const currentAttributes = this.attributes;\n\n    // Calculate new values\n    const newValues = {};\n    for (const attr in newOps) {\n      if (newOps[attr] instanceof _ParseOp.RelationOp) {\n        newValues[attr] = newOps[attr].applyTo(currentAttributes[attr], this, attr);\n      } else if (!(newOps[attr] instanceof _ParseOp.UnsetOp)) {\n        newValues[attr] = newOps[attr].applyTo(currentAttributes[attr]);\n      }\n    }\n\n    // Validate changes\n    if (!options.ignoreValidation) {\n      const validationError = this.validate(newValues);\n      if (validationError) {\n        throw validationError;\n      }\n    }\n\n    // Consolidate Ops\n    const pendingOps = this._getPendingOps();\n    const last = pendingOps.length - 1;\n    const stateController = _CoreManager.default.getObjectStateController();\n    for (const attr in newOps) {\n      const nextOp = newOps[attr].mergeWith(pendingOps[last][attr]);\n      stateController.setPendingOp(this._getStateIdentifier(), attr, nextOp);\n    }\n    return this;\n  }\n\n  /**\n   * Remove an attribute from the model. This is a noop if the attribute doesn't\n   * exist.\n   *\n   * @param {string} attr The string name of an attribute.\n   * @param options\n   * @returns {Parse.Object} Returns the object, so you can chain this call.\n   */\n  unset(attr, options) {\n    options = options || {};\n    options.unset = true;\n    return this.set(attr, null, options);\n  }\n\n  /**\n   * Atomically increments the value of the given attribute the next time the\n   * object is saved. If no amount is specified, 1 is used by default.\n   *\n   * @param attr {String} The key.\n   * @param amount {Number} The amount to increment by (optional).\n   * @returns {Parse.Object} Returns the object, so you can chain this call.\n   */\n  increment(attr, amount) {\n    if (typeof amount === 'undefined') {\n      amount = 1;\n    }\n    if (typeof amount !== 'number') {\n      throw new Error('Cannot increment by a non-numeric amount.');\n    }\n    return this.set(attr, new _ParseOp.IncrementOp(amount));\n  }\n\n  /**\n   * Atomically decrements the value of the given attribute the next time the\n   * object is saved. If no amount is specified, 1 is used by default.\n   *\n   * @param attr {String} The key.\n   * @param amount {Number} The amount to decrement by (optional).\n   * @returns {Parse.Object} Returns the object, so you can chain this call.\n   */\n  decrement(attr, amount) {\n    if (typeof amount === 'undefined') {\n      amount = 1;\n    }\n    if (typeof amount !== 'number') {\n      throw new Error('Cannot decrement by a non-numeric amount.');\n    }\n    return this.set(attr, new _ParseOp.IncrementOp(amount * -1));\n  }\n\n  /**\n   * Atomically add an object to the end of the array associated with a given\n   * key.\n   *\n   * @param attr {String} The key.\n   * @param item {} The item to add.\n   * @returns {Parse.Object} Returns the object, so you can chain this call.\n   */\n  add(attr, item) {\n    return this.set(attr, new _ParseOp.AddOp([item]));\n  }\n\n  /**\n   * Atomically add the objects to the end of the array associated with a given\n   * key.\n   *\n   * @param attr {String} The key.\n   * @param items {Object[]} The items to add.\n   * @returns {Parse.Object} Returns the object, so you can chain this call.\n   */\n  addAll(attr, items) {\n    return this.set(attr, new _ParseOp.AddOp(items));\n  }\n\n  /**\n   * Atomically add an object to the array associated with a given key, only\n   * if it is not already present in the array. The position of the insert is\n   * not guaranteed.\n   *\n   * @param attr {String} The key.\n   * @param item {} The object to add.\n   * @returns {Parse.Object} Returns the object, so you can chain this call.\n   */\n  addUnique(attr, item) {\n    return this.set(attr, new _ParseOp.AddUniqueOp([item]));\n  }\n\n  /**\n   * Atomically add the objects to the array associated with a given key, only\n   * if it is not already present in the array. The position of the insert is\n   * not guaranteed.\n   *\n   * @param attr {String} The key.\n   * @param items {Object[]} The objects to add.\n   * @returns {Parse.Object} Returns the object, so you can chain this call.\n   */\n  addAllUnique(attr, items) {\n    return this.set(attr, new _ParseOp.AddUniqueOp(items));\n  }\n\n  /**\n   * Atomically remove all instances of an object from the array associated\n   * with a given key.\n   *\n   * @param attr {String} The key.\n   * @param item {} The object to remove.\n   * @returns {Parse.Object} Returns the object, so you can chain this call.\n   */\n  remove(attr, item) {\n    return this.set(attr, new _ParseOp.RemoveOp([item]));\n  }\n\n  /**\n   * Atomically remove all instances of the objects from the array associated\n   * with a given key.\n   *\n   * @param attr {String} The key.\n   * @param items {Object[]} The object to remove.\n   * @returns {Parse.Object} Returns the object, so you can chain this call.\n   */\n  removeAll(attr, items) {\n    return this.set(attr, new _ParseOp.RemoveOp(items));\n  }\n\n  /**\n   * Returns an instance of a subclass of Parse.Op describing what kind of\n   * modification has been performed on this field since the last time it was\n   * saved. For example, after calling object.increment(\"x\"), calling\n   * object.op(\"x\") would return an instance of Parse.Op.Increment.\n   *\n   * @param attr {String} The key.\n   * @returns {Parse.Op | undefined} The operation, or undefined if none.\n   */\n  op(attr) {\n    const pending = this._getPendingOps();\n    for (let i = 0; i < pending.length; i += 1) {\n      if (pending[i][attr]) {\n        return pending[i][attr];\n      }\n    }\n  }\n\n  /**\n   * Creates a new model with identical attributes to this one.\n   *\n   * @returns {Parse.Object}\n   */\n  clone() {\n    const clone = new this.constructor(this.className);\n    let attributes = this.attributes;\n    if (typeof this.constructor.readOnlyAttributes === 'function') {\n      const readonly = this.constructor.readOnlyAttributes() || [];\n      // Attributes are frozen, so we have to rebuild an object,\n      // rather than delete readonly keys\n      const copy = {};\n      for (const a in attributes) {\n        if ((0, _indexOf.default)(readonly).call(readonly, a) < 0) {\n          copy[a] = attributes[a];\n        }\n      }\n      attributes = copy;\n    }\n    if (clone.set) {\n      clone.set(attributes);\n    }\n    return clone;\n  }\n\n  /**\n   * Creates a new instance of this object. Not to be confused with clone()\n   *\n   * @returns {Parse.Object}\n   */\n  newInstance() {\n    const clone = new this.constructor(this.className);\n    clone.id = this.id;\n    if (singleInstance) {\n      // Just return an object with the right id\n      return clone;\n    }\n    const stateController = _CoreManager.default.getObjectStateController();\n    if (stateController) {\n      stateController.duplicateState(this._getStateIdentifier(), clone._getStateIdentifier());\n    }\n    return clone;\n  }\n\n  /**\n   * Returns true if this object has never been saved to Parse.\n   *\n   * @returns {boolean}\n   */\n  isNew() {\n    return !this.id;\n  }\n\n  /**\n   * Returns true if this object was created by the Parse server when the\n   * object might have already been there (e.g. in the case of a Facebook\n   * login)\n   *\n   * @returns {boolean}\n   */\n  existed() {\n    if (!this.id) {\n      return false;\n    }\n    const stateController = _CoreManager.default.getObjectStateController();\n    const state = stateController.getState(this._getStateIdentifier());\n    if (state) {\n      return state.existed;\n    }\n    return false;\n  }\n\n  /**\n   * Returns true if this object exists on the Server\n   *\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise<boolean>} A boolean promise that is fulfilled if object exists.\n   */\n  async exists(options) {\n    if (!this.id) {\n      return false;\n    }\n    try {\n      const ParseQuery = _CoreManager.default.getParseQuery();\n      const query = new ParseQuery(this.className);\n      await query.get(this.id, options);\n      return true;\n    } catch (e) {\n      if (e.code === _ParseError.default.OBJECT_NOT_FOUND) {\n        return false;\n      }\n      throw e;\n    }\n  }\n\n  /**\n   * Checks if the model is currently in a valid state.\n   *\n   * @returns {boolean}\n   */\n  isValid() {\n    return !this.validate(this.attributes);\n  }\n\n  /**\n   * You should not call this function directly unless you subclass\n   * <code>Parse.Object</code>, in which case you can override this method\n   * to provide additional validation on <code>set</code> and\n   * <code>save</code>.  Your implementation should return\n   *\n   * @param {object} attrs The current data to validate.\n   * @returns {Parse.Error|boolean} False if the data is valid.  An error object otherwise.\n   * @see Parse.Object#set\n   */\n  validate(attrs) {\n    if (Object.hasOwn(attrs, 'ACL') && !(attrs.ACL instanceof _ParseACL.default)) {\n      return new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'ACL must be a Parse ACL.');\n    }\n    for (const key in attrs) {\n      if (!/^[A-Za-z_][0-9A-Za-z_.]*$/.test(key)) {\n        return new _ParseError.default(_ParseError.default.INVALID_KEY_NAME, `Invalid key name: ${key}`);\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Returns the ACL for this object.\n   *\n   * @returns {Parse.ACL|null} An instance of Parse.ACL.\n   * @see Parse.Object#get\n   */\n  getACL() {\n    const acl = this.get('ACL');\n    if (acl instanceof _ParseACL.default) {\n      return acl;\n    }\n    return null;\n  }\n\n  /**\n   * Sets the ACL to be used for this object.\n   *\n   * @param {Parse.ACL} acl An instance of Parse.ACL.\n   * @param {object} options\n   * @returns {Parse.Object} Returns the object, so you can chain this call.\n   * @see Parse.Object#set\n   */\n  setACL(acl, options) {\n    return this.set('ACL', acl, options);\n  }\n\n  /**\n   * Clears any (or specific) changes to this object made since the last call to save()\n   *\n   * @param {string} [keys] - specify which fields to revert\n   */\n  revert() {\n    let keysToRevert;\n    for (var _len = arguments.length, keys = new Array(_len), _key = 0; _key < _len; _key++) {\n      keys[_key] = arguments[_key];\n    }\n    if (keys.length) {\n      keysToRevert = [];\n      for (const key of keys) {\n        if (typeof key === 'string') {\n          keysToRevert.push(key);\n        } else {\n          throw new Error('Parse.Object#revert expects either no, or a list of string, arguments.');\n        }\n      }\n    }\n    this._clearPendingOps(keysToRevert);\n  }\n\n  /**\n   * Clears all attributes on a model\n   *\n   * @returns {Parse.Object} Returns the object, so you can chain this call.\n   */\n  clear() {\n    const attributes = this.attributes;\n    const erasable = {};\n    let readonly = ['createdAt', 'updatedAt'];\n    if (typeof this.constructor.readOnlyAttributes === 'function') {\n      readonly = (0, _concat.default)(readonly).call(readonly, this.constructor.readOnlyAttributes());\n    }\n    for (const attr in attributes) {\n      if ((0, _indexOf.default)(readonly).call(readonly, attr) < 0) {\n        erasable[attr] = true;\n      }\n    }\n    return this.set(erasable, {\n      unset: true\n    });\n  }\n\n  /**\n   * Fetch the model from the server. If the server's representation of the\n   * model differs from its current attributes, they will be overriden.\n   *\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>include: The name(s) of the key(s) to include. Can be a string, an array of strings,\n   *       or an array of array of strings.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n   * </ul>\n   * @returns {Promise} A promise that is fulfilled when the fetch\n   *     completes.\n   */\n  fetch(options) {\n    const fetchOptions = ParseObject._getRequestOptions(options);\n    const controller = _CoreManager.default.getObjectController();\n    return controller.fetch(this, true, fetchOptions);\n  }\n\n  /**\n   * Fetch the model from the server. If the server's representation of the\n   * model differs from its current attributes, they will be overriden.\n   *\n   * Includes nested Parse.Objects for the provided key. You can use dot\n   * notation to specify which fields in the included object are also fetched.\n   *\n   * @param {string | Array<string | Array<string>>} keys The name(s) of the key(s) to include.\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise} A promise that is fulfilled when the fetch\n   *     completes.\n   */\n  fetchWithInclude(keys, options) {\n    options = options || {};\n    options.include = keys;\n    return this.fetch(options);\n  }\n\n  /**\n   * Saves this object to the server at some unspecified time in the future,\n   * even if Parse is currently inaccessible.\n   *\n   * Use this when you may not have a solid network connection, and don't need to know when the save completes.\n   * If there is some problem with the object such that it can't be saved, it will be silently discarded.\n   *\n   * Objects saved with this method will be stored locally in an on-disk cache until they can be delivered to Parse.\n   * They will be sent immediately if possible. Otherwise, they will be sent the next time a network connection is\n   * available. Objects saved this way will persist even after the app is closed, in which case they will be sent the\n   * next time the app is opened.\n   *\n   * @param {object} [options]\n   * Used to pass option parameters to method if arg1 and arg2 were both passed as strings.\n   * Valid options are:\n   * <ul>\n   * <li>sessionToken: A valid session token, used for making a request on\n   * behalf of a specific user.\n   * <li>cascadeSave: If `false`, nested objects will not be saved (default is `true`).\n   * <li>context: A dictionary that is accessible in Cloud Code `beforeSave` and `afterSave` triggers.\n   * </ul>\n   * @returns {Promise} A promise that is fulfilled when the save\n   * completes.\n   */\n  async saveEventually(options) {\n    try {\n      await this.save(null, options);\n    } catch (e) {\n      if (e.code === _ParseError.default.CONNECTION_FAILED) {\n        await _CoreManager.default.getEventuallyQueue().save(this, options);\n        _CoreManager.default.getEventuallyQueue().poll();\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Set a hash of model attributes, and save the model to the server.\n   * updatedAt will be updated when the request returns.\n   * You can either call it as:<pre>\n   * object.save();</pre>\n   * or<pre>\n   * object.save(attrs);</pre>\n   * or<pre>\n   * object.save(null, options);</pre>\n   * or<pre>\n   * object.save(attrs, options);</pre>\n   * or<pre>\n   * object.save(key, value);</pre>\n   * or<pre>\n   * object.save(key, value, options);</pre>\n   *\n   * Example 1: <pre>\n   * gameTurn.save({\n   * player: \"Jake Cutter\",\n   * diceRoll: 2\n   * }).then(function(gameTurnAgain) {\n   * // The save was successful.\n   * }, function(error) {\n   * // The save failed.  Error is an instance of Parse.Error.\n   * });</pre>\n   *\n   * Example 2: <pre>\n   * gameTurn.save(\"player\", \"Jake Cutter\");</pre>\n   *\n   * @param {string | object | null} [arg1]\n   * Valid options are:<ul>\n   * <li>`Object` - Key/value pairs to update on the object.</li>\n   * <li>`String` Key - Key of attribute to update (requires arg2 to also be string)</li>\n   * <li>`null` - Passing null for arg1 allows you to save the object with options passed in arg2.</li>\n   * </ul>\n   * @param {string | object} [arg2]\n   * <ul>\n   * <li>`String` Value - If arg1 was passed as a key, arg2 is the value that should be set on that key.</li>\n   * <li>`Object` Options - Valid options are:\n   * <ul>\n   * <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   * be used for this request.\n   * <li>sessionToken: A valid session token, used for making a request on\n   * behalf of a specific user.\n   * <li>cascadeSave: If `false`, nested objects will not be saved (default is `true`).\n   * <li>context: A dictionary that is accessible in Cloud Code `beforeSave` and `afterSave` triggers.\n   * </ul>\n   * </li>\n   * </ul>\n   * @param {object} [arg3]\n   * Used to pass option parameters to method if arg1 and arg2 were both passed as strings.\n   * Valid options are:\n   * <ul>\n   * <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   * be used for this request.\n   * <li>sessionToken: A valid session token, used for making a request on\n   * behalf of a specific user.\n   * <li>cascadeSave: If `false`, nested objects will not be saved (default is `true`).\n   * <li>context: A dictionary that is accessible in Cloud Code `beforeSave` and `afterSave` triggers.\n   * </ul>\n   * @returns {Promise} A promise that is fulfilled when the save\n   * completes.\n   */\n\n  async save(arg1, arg2, arg3) {\n    let attrs;\n    let options;\n    if (typeof arg1 === 'object' || typeof arg1 === 'undefined') {\n      attrs = arg1;\n      if (typeof arg2 === 'object') {\n        options = arg2;\n      }\n    } else {\n      attrs = {};\n      attrs[arg1] = arg2;\n      options = arg3;\n    }\n    options = options || {};\n    if (attrs) {\n      this.set(attrs, options);\n    }\n    const saveOptions = ParseObject._getRequestOptions(options);\n    const controller = _CoreManager.default.getObjectController();\n    const unsaved = options.cascadeSave !== false ? (0, _unsavedChildren.default)(this) : null;\n    if (unsaved && unsaved.length && options.transaction === true && (0, _some.default)(unsaved).call(unsaved, el => el instanceof ParseObject)) {\n      const unsavedFiles = [];\n      const unsavedObjects = [];\n      (0, _forEach.default)(unsaved).call(unsaved, el => {\n        if (el instanceof _ParseFile.default) unsavedFiles.push(el);else unsavedObjects.push(el);\n      });\n      unsavedObjects.push(this);\n      const filePromise = unsavedFiles.length ? controller.save(unsavedFiles, saveOptions) : _promise.default.resolve();\n      return filePromise.then(() => controller.save(unsavedObjects, saveOptions)).then(savedOjbects => savedOjbects.pop());\n    }\n    await controller.save(unsaved, saveOptions);\n    return controller.save(this, saveOptions);\n  }\n\n  /**\n   * Deletes this object from the server at some unspecified time in the future,\n   * even if Parse is currently inaccessible.\n   *\n   * Use this when you may not have a solid network connection,\n   * and don't need to know when the delete completes. If there is some problem with the object\n   * such that it can't be deleted, the request will be silently discarded.\n   *\n   * Delete instructions made with this method will be stored locally in an on-disk cache until they can be transmitted\n   * to Parse. They will be sent immediately if possible. Otherwise, they will be sent the next time a network connection\n   * is available. Delete requests will persist even after the app is closed, in which case they will be sent the\n   * next time the app is opened.\n   *\n   * @param {object} [options]\n   * Valid options are:<ul>\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeDelete` and `afterDelete` triggers.\n   * </ul>\n   * @returns {Promise} A promise that is fulfilled when the destroy\n   *     completes.\n   */\n  async destroyEventually(options) {\n    try {\n      await this.destroy(options);\n    } catch (e) {\n      if (e.code === _ParseError.default.CONNECTION_FAILED) {\n        await _CoreManager.default.getEventuallyQueue().destroy(this, options);\n        _CoreManager.default.getEventuallyQueue().poll();\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Destroy this model on the server if it was already persisted.\n   *\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeDelete` and `afterDelete` triggers.\n   * </ul>\n   * @returns {Promise} A promise that is fulfilled when the destroy\n   *     completes.\n   */\n  destroy(options) {\n    if (!this.id) {\n      return _promise.default.resolve(undefined);\n    }\n    const destroyOptions = ParseObject._getRequestOptions(options);\n    return _CoreManager.default.getObjectController().destroy(this, destroyOptions);\n  }\n\n  /**\n   * Asynchronously stores the object and every object it points to in the local datastore,\n   * recursively, using a default pin name: _default.\n   *\n   * If those other objects have not been fetched from Parse, they will not be stored.\n   * However, if they have changed data, all the changes will be retained.\n   *\n   * <pre>\n   * await object.pin();\n   * </pre>\n   *\n   * To retrieve object:\n   * <code>query.fromLocalDatastore()</code> or <code>query.fromPin()</code>\n   *\n   * @returns {Promise} A promise that is fulfilled when the pin completes.\n   */\n  pin() {\n    return ParseObject.pinAllWithName(_LocalDatastoreUtils.DEFAULT_PIN, [this]);\n  }\n\n  /**\n   * Asynchronously removes the object and every object it points to in the local datastore,\n   * recursively, using a default pin name: _default.\n   *\n   * <pre>\n   * await object.unPin();\n   * </pre>\n   *\n   * @returns {Promise} A promise that is fulfilled when the unPin completes.\n   */\n  unPin() {\n    return ParseObject.unPinAllWithName(_LocalDatastoreUtils.DEFAULT_PIN, [this]);\n  }\n\n  /**\n   * Asynchronously returns if the object is pinned\n   *\n   * <pre>\n   * const isPinned = await object.isPinned();\n   * </pre>\n   *\n   * @returns {Promise<boolean>} A boolean promise that is fulfilled if object is pinned.\n   */\n  async isPinned() {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    if (!localDatastore.isEnabled) {\n      return _promise.default.reject('Parse.enableLocalDatastore() must be called first');\n    }\n    const objectKey = localDatastore.getKeyForObject(this);\n    const pin = await localDatastore.fromPinWithName(objectKey);\n    return pin.length > 0;\n  }\n\n  /**\n   * Asynchronously stores the objects and every object they point to in the local datastore, recursively.\n   *\n   * If those other objects have not been fetched from Parse, they will not be stored.\n   * However, if they have changed data, all the changes will be retained.\n   *\n   * <pre>\n   * await object.pinWithName(name);\n   * </pre>\n   *\n   * To retrieve object:\n   * <code>query.fromLocalDatastore()</code> or <code>query.fromPinWithName(name)</code>\n   *\n   * @param {string} name Name of Pin.\n   * @returns {Promise} A promise that is fulfilled when the pin completes.\n   */\n  pinWithName(name) {\n    return ParseObject.pinAllWithName(name, [this]);\n  }\n\n  /**\n   * Asynchronously removes the object and every object it points to in the local datastore, recursively.\n   *\n   * <pre>\n   * await object.unPinWithName(name);\n   * </pre>\n   *\n   * @param {string} name Name of Pin.\n   * @returns {Promise} A promise that is fulfilled when the unPin completes.\n   */\n  unPinWithName(name) {\n    return ParseObject.unPinAllWithName(name, [this]);\n  }\n\n  /**\n   * Asynchronously loads data from the local datastore into this object.\n   *\n   * <pre>\n   * await object.fetchFromLocalDatastore();\n   * </pre>\n   *\n   * You can create an unfetched pointer with <code>Parse.Object.createWithoutData()</code>\n   * and then call <code>fetchFromLocalDatastore()</code> on it.\n   *\n   * @returns {Promise} A promise that is fulfilled when the fetch completes.\n   */\n  async fetchFromLocalDatastore() {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    if (!localDatastore.isEnabled) {\n      throw new Error('Parse.enableLocalDatastore() must be called first');\n    }\n    const objectKey = localDatastore.getKeyForObject(this);\n    const pinned = await localDatastore._serializeObject(objectKey);\n    if (!pinned) {\n      throw new Error('Cannot fetch an unsaved ParseObject');\n    }\n    const result = ParseObject.fromJSON(pinned);\n    this._finishFetch(result.toJSON());\n    return this;\n  }\n\n  /* Static methods */\n\n  static _clearAllState() {\n    const stateController = _CoreManager.default.getObjectStateController();\n    stateController.clearAllState();\n  }\n\n  /**\n   * Fetches the given list of Parse.Object.\n   * If any error is encountered, stops and calls the error handler.\n   *\n   * <pre>\n   *   Parse.Object.fetchAll([object1, object2, ...])\n   *    .then((list) => {\n   *      // All the objects were fetched.\n   *    }, (error) => {\n   *      // An error occurred while fetching one of the objects.\n   *    });\n   * </pre>\n   *\n   * @param {Array} list A list of <code>Parse.Object</code>.\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>include: The name(s) of the key(s) to include. Can be a string, an array of strings,\n   *       or an array of array of strings.\n   * </ul>\n   * @static\n   * @returns {Parse.Object[]}\n   */\n  static fetchAll(list, options) {\n    const fetchOptions = ParseObject._getRequestOptions(options);\n    return _CoreManager.default.getObjectController().fetch(list, true, fetchOptions);\n  }\n\n  /**\n   * Fetches the given list of Parse.Object.\n   *\n   * Includes nested Parse.Objects for the provided key. You can use dot\n   * notation to specify which fields in the included object are also fetched.\n   *\n   * If any error is encountered, stops and calls the error handler.\n   *\n   * <pre>\n   *   Parse.Object.fetchAllWithInclude([object1, object2, ...], [pointer1, pointer2, ...])\n   *    .then((list) => {\n   *      // All the objects were fetched.\n   *    }, (error) => {\n   *      // An error occurred while fetching one of the objects.\n   *    });\n   * </pre>\n   *\n   * @param {Array} list A list of <code>Parse.Object</code>.\n   * @param {string | Array<string | Array<string>>} keys The name(s) of the key(s) to include.\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @static\n   * @returns {Parse.Object[]}\n   */\n  static fetchAllWithInclude(list, keys, options) {\n    options = options || {};\n    options.include = keys;\n    return ParseObject.fetchAll(list, options);\n  }\n\n  /**\n   * Fetches the given list of Parse.Object if needed.\n   * If any error is encountered, stops and calls the error handler.\n   *\n   * Includes nested Parse.Objects for the provided key. You can use dot\n   * notation to specify which fields in the included object are also fetched.\n   *\n   * If any error is encountered, stops and calls the error handler.\n   *\n   * <pre>\n   *   Parse.Object.fetchAllIfNeededWithInclude([object1, object2, ...], [pointer1, pointer2, ...])\n   *    .then((list) => {\n   *      // All the objects were fetched.\n   *    }, (error) => {\n   *      // An error occurred while fetching one of the objects.\n   *    });\n   * </pre>\n   *\n   * @param {Array} list A list of <code>Parse.Object</code>.\n   * @param {string | Array<string | Array<string>>} keys The name(s) of the key(s) to include.\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @static\n   * @returns {Parse.Object[]}\n   */\n  static fetchAllIfNeededWithInclude(list, keys, options) {\n    options = options || {};\n    options.include = keys;\n    return ParseObject.fetchAllIfNeeded(list, options);\n  }\n\n  /**\n   * Fetches the given list of Parse.Object if needed.\n   * If any error is encountered, stops and calls the error handler.\n   *\n   * <pre>\n   *   Parse.Object.fetchAllIfNeeded([object1, ...])\n   *    .then((list) => {\n   *      // Objects were fetched and updated.\n   *    }, (error) => {\n   *      // An error occurred while fetching one of the objects.\n   *    });\n   * </pre>\n   *\n   * @param {Array} list A list of <code>Parse.Object</code>.\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>include: The name(s) of the key(s) to include. Can be a string, an array of strings,\n   *       or an array of array of strings.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n   * </ul>\n   * @static\n   * @returns {Parse.Object[]}\n   */\n  static fetchAllIfNeeded(list, options) {\n    const fetchOptions = ParseObject._getRequestOptions(options);\n    return _CoreManager.default.getObjectController().fetch(list, false, fetchOptions);\n  }\n  static handleIncludeOptions(options) {\n    let include = [];\n    if ((0, _isArray.default)(options.include)) {\n      var _context;\n      (0, _forEach.default)(_context = options.include).call(_context, key => {\n        if ((0, _isArray.default)(key)) {\n          include = (0, _concat.default)(include).call(include, key);\n        } else {\n          include.push(key);\n        }\n      });\n    } else {\n      include.push(options.include);\n    }\n    return include;\n  }\n\n  /**\n   * Destroy the given list of models on the server if it was already persisted.\n   *\n   * <p>Unlike saveAll, if an error occurs while deleting an individual model,\n   * this method will continue trying to delete the rest of the models if\n   * possible, except in the case of a fatal error like a connection error.\n   *\n   * <p>In particular, the Parse.Error object returned in the case of error may\n   * be one of two types:\n   *\n   * <ul>\n   * <li>A Parse.Error.AGGREGATE_ERROR. This object's \"errors\" property is an\n   * array of other Parse.Error objects. Each error object in this array\n   * has an \"object\" property that references the object that could not be\n   * deleted (for instance, because that object could not be found).</li>\n   * <li>A non-aggregate Parse.Error. This indicates a serious error that\n   * caused the delete operation to be aborted partway through (for\n   * instance, a connection failure in the middle of the delete).</li>\n   * </ul>\n   *\n   * <pre>\n   * Parse.Object.destroyAll([object1, object2, ...])\n   * .then((list) => {\n   * // All the objects were deleted.\n   * }, (error) => {\n   * // An error occurred while deleting one or more of the objects.\n   * // If this is an aggregate error, then we can inspect each error\n   * // object individually to determine the reason why a particular\n   * // object was not deleted.\n   * if (error.code === Parse.Error.AGGREGATE_ERROR) {\n   * for (var i = 0; i < error.errors.length; i++) {\n   * console.log(\"Couldn't delete \" + error.errors[i].object.id +\n   * \"due to \" + error.errors[i].message);\n   * }\n   * } else {\n   * console.log(\"Delete aborted because of \" + error.message);\n   * }\n   * });\n   * </pre>\n   *\n   * @param {Array} list A list of <code>Parse.Object</code>.\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeDelete` and `afterDelete` triggers.\n   *   <li>transaction: Set to true to enable transactions\n   *   <li>batchSize: How many objects to yield in each batch (default: 20)\n   * </ul>\n   * @static\n   * @returns {Promise} A promise that is fulfilled when the destroyAll\n   * completes.\n   */\n  static destroyAll(list, options) {\n    const destroyOptions = ParseObject._getRequestOptions(options);\n    return _CoreManager.default.getObjectController().destroy(list, destroyOptions);\n  }\n\n  /**\n   * Saves the given list of Parse.Object.\n   * If any error is encountered, stops and calls the error handler.\n   *\n   * <pre>\n   * Parse.Object.saveAll([object1, object2, ...])\n   * .then((list) => {\n   * // All the objects were saved.\n   * }, (error) => {\n   * // An error occurred while saving one of the objects.\n   * });\n   * </pre>\n   *\n   * @param {Array} list A list of <code>Parse.Object</code>.\n   * @param {object} options\n   * Valid options are:\n   * <ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *        be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>cascadeSave: If `false`, nested objects will not be saved (default is `true`).\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeSave` and `afterSave` triggers.\n   *   <li>transaction: Set to true to enable transactions\n   *   <li>batchSize: How many objects to yield in each batch (default: 20)\n   * </ul>\n   * @static\n   * @returns {Parse.Object[]}\n   */\n  static saveAll(list, options) {\n    const saveOptions = ParseObject._getRequestOptions(options);\n    return _CoreManager.default.getObjectController().save(list, saveOptions);\n  }\n\n  /**\n   * Creates a reference to a subclass of Parse.Object with the given id. This\n   * does not exist on Parse.Object, only on subclasses.\n   *\n   * <p>A shortcut for: <pre>\n   *  var Foo = Parse.Object.extend(\"Foo\");\n   *  var pointerToFoo = new Foo();\n   *  pointerToFoo.id = \"myObjectId\";\n   * </pre>\n   *\n   * @param {string} id The ID of the object to create a reference to.\n   * @static\n   * @returns {Parse.Object} A Parse.Object reference.\n   */\n  static createWithoutData(id) {\n    const obj = new this();\n    obj.id = id;\n    return obj;\n  }\n\n  /**\n   * Creates a new instance of a Parse Object from a JSON representation.\n   *\n   * @param {object} json The JSON map of the Object's data\n   * @param {boolean} override In single instance mode, all old server data\n   *   is overwritten if this is set to true\n   * @param {boolean} dirty Whether the Parse.Object should set JSON keys to dirty\n   * @static\n   * @returns {Parse.Object} A Parse.Object reference\n   */\n  static fromJSON(json, override, dirty) {\n    if (!json.className) {\n      throw new Error('Cannot create an object without a className');\n    }\n    const constructor = classMap[json.className];\n    const o = constructor ? new constructor(json.className) : new ParseObject(json.className);\n    const otherAttributes = {};\n    for (const attr in json) {\n      if (attr !== 'className' && attr !== '__type') {\n        otherAttributes[attr] = json[attr];\n        if (dirty) {\n          o.set(attr, json[attr]);\n        }\n      }\n    }\n    if (override) {\n      // id needs to be set before clearServerData can work\n      if (otherAttributes.objectId) {\n        o.id = otherAttributes.objectId;\n      }\n      let preserved = null;\n      if (typeof o._preserveFieldsOnFetch === 'function') {\n        preserved = o._preserveFieldsOnFetch();\n      }\n      o._clearServerData();\n      if (preserved) {\n        o._finishFetch(preserved);\n      }\n    }\n    o._finishFetch(otherAttributes);\n    if (json.objectId) {\n      o._setExisted(true);\n    }\n    return o;\n  }\n\n  /**\n   * Registers a subclass of Parse.Object with a specific class name.\n   * When objects of that class are retrieved from a query, they will be\n   * instantiated with this subclass.\n   * This is only necessary when using ES6 subclassing.\n   *\n   * @param {string} className The class name of the subclass\n   * @param {Function} constructor The subclass\n   */\n  static registerSubclass(className, constructor) {\n    if (typeof className !== 'string') {\n      throw new TypeError('The first argument must be a valid class name.');\n    }\n    if (typeof constructor === 'undefined') {\n      throw new TypeError('You must supply a subclass constructor.');\n    }\n    if (typeof constructor !== 'function') {\n      throw new TypeError('You must register the subclass constructor. ' + 'Did you attempt to register an instance of the subclass?');\n    }\n    classMap[className] = constructor;\n    if (!constructor.className) {\n      constructor.className = className;\n    }\n  }\n\n  /**\n   * Unegisters a subclass of Parse.Object with a specific class name.\n   *\n   * @param {string} className The class name of the subclass\n   */\n  static unregisterSubclass(className) {\n    if (typeof className !== 'string') {\n      throw new TypeError('The first argument must be a valid class name.');\n    }\n    delete classMap[className];\n  }\n\n  /**\n   * Creates a new subclass of Parse.Object for the given Parse class name.\n   *\n   * <p>Every extension of a Parse class will inherit from the most recent\n   * previous extension of that class. When a Parse.Object is automatically\n   * created by parsing JSON, it will use the most recent extension of that\n   * class.</p>\n   *\n   * <p>You should call either:<pre>\n   *     var MyClass = Parse.Object.extend(\"MyClass\", {\n   *         <i>Instance methods</i>,\n   *         initialize: function(attrs, options) {\n   *             this.someInstanceProperty = [],\n   *             <i>Other instance properties</i>\n   *         }\n   *     }, {\n   *         <i>Class properties</i>\n   *     });</pre>\n   * or, for Backbone compatibility:<pre>\n   *     var MyClass = Parse.Object.extend({\n   *         className: \"MyClass\",\n   *         <i>Instance methods</i>,\n   *         initialize: function(attrs, options) {\n   *             this.someInstanceProperty = [],\n   *             <i>Other instance properties</i>\n   *         }\n   *     }, {\n   *         <i>Class properties</i>\n   *     });</pre></p>\n   *\n   * @param {string} className The name of the Parse class backing this model.\n   * @param {object} [protoProps] Instance properties to add to instances of the\n   *     class returned from this method.\n   * @param {object} [classProps] Class properties to add the class returned from\n   *     this method.\n   * @returns {Parse.Object} A new subclass of Parse.Object.\n   */\n  static extend(className, protoProps, classProps) {\n    if (typeof className !== 'string') {\n      if (className && typeof className.className === 'string') {\n        return ParseObject.extend(className.className, className, protoProps);\n      } else {\n        throw new Error(\"Parse.Object.extend's first argument should be the className.\");\n      }\n    }\n    let adjustedClassName = className;\n    if (adjustedClassName === 'User' && _CoreManager.default.get('PERFORM_USER_REWRITE')) {\n      adjustedClassName = '_User';\n    }\n    let parentProto = ParseObject.prototype;\n    if (Object.hasOwn(this, '__super__') && this.__super__) {\n      parentProto = this.prototype;\n    }\n    let ParseObjectSubclass = function (attributes, options) {\n      this.className = adjustedClassName;\n      this._objCount = objectCount++;\n      // Enable legacy initializers\n      if (typeof this.initialize === 'function') {\n        this.initialize.apply(this, arguments);\n      }\n      if (this._initializers) {\n        for (const initializer of this._initializers) {\n          initializer.apply(this, arguments);\n        }\n      }\n      if (attributes && typeof attributes === 'object') {\n        try {\n          this.set(attributes || {}, options);\n        } catch (_) {\n          throw new Error(\"Can't create an invalid Parse Object\");\n        }\n      }\n    };\n    if (classMap[adjustedClassName]) {\n      ParseObjectSubclass = classMap[adjustedClassName];\n    } else {\n      ParseObjectSubclass.extend = function (name, protoProps, classProps) {\n        if (typeof name === 'string') {\n          return ParseObject.extend.call(ParseObjectSubclass, name, protoProps, classProps);\n        }\n        return ParseObject.extend.call(ParseObjectSubclass, adjustedClassName, name, protoProps);\n      };\n      ParseObjectSubclass.createWithoutData = ParseObject.createWithoutData;\n      ParseObjectSubclass.className = adjustedClassName;\n      ParseObjectSubclass.__super__ = parentProto;\n      ParseObjectSubclass.prototype = (0, _create.default)(parentProto, {\n        constructor: {\n          value: ParseObjectSubclass,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      });\n    }\n    if (protoProps) {\n      for (const prop in protoProps) {\n        if (prop === 'initialize') {\n          (0, _defineProperty3.default)(ParseObjectSubclass.prototype, '_initializers', {\n            value: [...(ParseObjectSubclass.prototype._initializers || []), protoProps[prop]],\n            enumerable: false,\n            writable: true,\n            configurable: true\n          });\n          continue;\n        }\n        if (prop !== 'className') {\n          (0, _defineProperty3.default)(ParseObjectSubclass.prototype, prop, {\n            value: protoProps[prop],\n            enumerable: false,\n            writable: true,\n            configurable: true\n          });\n        }\n      }\n    }\n    if (classProps) {\n      for (const prop in classProps) {\n        if (prop !== 'className') {\n          (0, _defineProperty3.default)(ParseObjectSubclass, prop, {\n            value: classProps[prop],\n            enumerable: false,\n            writable: true,\n            configurable: true\n          });\n        }\n      }\n    }\n    classMap[adjustedClassName] = ParseObjectSubclass;\n    return ParseObjectSubclass;\n  }\n\n  /**\n   * Enable single instance objects, where any local objects with the same Id\n   * share the same attributes, and stay synchronized with each other.\n   * This is disabled by default in server environments, since it can lead to\n   * security issues.\n   *\n   * @static\n   */\n  static enableSingleInstance() {\n    singleInstance = true;\n    _CoreManager.default.setObjectStateController(SingleInstanceStateController);\n  }\n\n  /**\n   * Disable single instance objects, where any local objects with the same Id\n   * share the same attributes, and stay synchronized with each other.\n   * When disabled, you can have two instances of the same object in memory\n   * without them sharing attributes.\n   *\n   * @static\n   */\n  static disableSingleInstance() {\n    singleInstance = false;\n    _CoreManager.default.setObjectStateController(UniqueInstanceStateController);\n  }\n\n  /**\n   * Asynchronously stores the objects and every object they point to in the local datastore,\n   * recursively, using a default pin name: _default.\n   *\n   * If those other objects have not been fetched from Parse, they will not be stored.\n   * However, if they have changed data, all the changes will be retained.\n   *\n   * <pre>\n   * await Parse.Object.pinAll([...]);\n   * </pre>\n   *\n   * To retrieve object:\n   * <code>query.fromLocalDatastore()</code> or <code>query.fromPin()</code>\n   *\n   * @param {Array} objects A list of <code>Parse.Object</code>.\n   * @returns {Promise} A promise that is fulfilled when the pin completes.\n   * @static\n   */\n  static pinAll(objects) {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    if (!localDatastore.isEnabled) {\n      return _promise.default.reject('Parse.enableLocalDatastore() must be called first');\n    }\n    return ParseObject.pinAllWithName(_LocalDatastoreUtils.DEFAULT_PIN, objects);\n  }\n\n  /**\n   * Asynchronously stores the objects and every object they point to in the local datastore, recursively.\n   *\n   * If those other objects have not been fetched from Parse, they will not be stored.\n   * However, if they have changed data, all the changes will be retained.\n   *\n   * <pre>\n   * await Parse.Object.pinAllWithName(name, [obj1, obj2, ...]);\n   * </pre>\n   *\n   * To retrieve object:\n   * <code>query.fromLocalDatastore()</code> or <code>query.fromPinWithName(name)</code>\n   *\n   * @param {string} name Name of Pin.\n   * @param {Array} objects A list of <code>Parse.Object</code>.\n   * @returns {Promise} A promise that is fulfilled when the pin completes.\n   * @static\n   */\n  static pinAllWithName(name, objects) {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    if (!localDatastore.isEnabled) {\n      return _promise.default.reject('Parse.enableLocalDatastore() must be called first');\n    }\n    return localDatastore._handlePinAllWithName(name, objects);\n  }\n\n  /**\n   * Asynchronously removes the objects and every object they point to in the local datastore,\n   * recursively, using a default pin name: _default.\n   *\n   * <pre>\n   * await Parse.Object.unPinAll([...]);\n   * </pre>\n   *\n   * @param {Array} objects A list of <code>Parse.Object</code>.\n   * @returns {Promise} A promise that is fulfilled when the unPin completes.\n   * @static\n   */\n  static unPinAll(objects) {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    if (!localDatastore.isEnabled) {\n      return _promise.default.reject('Parse.enableLocalDatastore() must be called first');\n    }\n    return ParseObject.unPinAllWithName(_LocalDatastoreUtils.DEFAULT_PIN, objects);\n  }\n\n  /**\n   * Asynchronously removes the objects and every object they point to in the local datastore, recursively.\n   *\n   * <pre>\n   * await Parse.Object.unPinAllWithName(name, [obj1, obj2, ...]);\n   * </pre>\n   *\n   * @param {string} name Name of Pin.\n   * @param {Array} objects A list of <code>Parse.Object</code>.\n   * @returns {Promise} A promise that is fulfilled when the unPin completes.\n   * @static\n   */\n  static unPinAllWithName(name, objects) {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    if (!localDatastore.isEnabled) {\n      return _promise.default.reject('Parse.enableLocalDatastore() must be called first');\n    }\n    return localDatastore._handleUnPinAllWithName(name, objects);\n  }\n\n  /**\n   * Asynchronously removes all objects in the local datastore using a default pin name: _default.\n   *\n   * <pre>\n   * await Parse.Object.unPinAllObjects();\n   * </pre>\n   *\n   * @returns {Promise} A promise that is fulfilled when the unPin completes.\n   * @static\n   */\n  static unPinAllObjects() {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    if (!localDatastore.isEnabled) {\n      return _promise.default.reject('Parse.enableLocalDatastore() must be called first');\n    }\n    return localDatastore.unPinWithName(_LocalDatastoreUtils.DEFAULT_PIN);\n  }\n\n  /**\n   * Asynchronously removes all objects with the specified pin name.\n   * Deletes the pin name also.\n   *\n   * <pre>\n   * await Parse.Object.unPinAllObjectsWithName(name);\n   * </pre>\n   *\n   * @param {string} name Name of Pin.\n   * @returns {Promise} A promise that is fulfilled when the unPin completes.\n   * @static\n   */\n  static unPinAllObjectsWithName(name) {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    if (!localDatastore.isEnabled) {\n      return _promise.default.reject('Parse.enableLocalDatastore() must be called first');\n    }\n    return localDatastore.unPinWithName(_LocalDatastoreUtils.PIN_PREFIX + name);\n  }\n}\nconst DefaultController = {\n  fetch(target, forceFetch, options) {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    if ((0, _isArray.default)(target)) {\n      if (target.length < 1) {\n        return _promise.default.resolve([]);\n      }\n      const objs = [];\n      const ids = [];\n      let className = null;\n      const results = [];\n      let error = null;\n      (0, _forEach.default)(target).call(target, el => {\n        if (error) {\n          return;\n        }\n        if (!className) {\n          className = el.className;\n        }\n        if (className !== el.className) {\n          error = new _ParseError.default(_ParseError.default.INVALID_CLASS_NAME, 'All objects should be of the same class');\n        }\n        if (!el.id) {\n          error = new _ParseError.default(_ParseError.default.MISSING_OBJECT_ID, 'All objects must have an ID');\n        }\n        if (forceFetch || !el.isDataAvailable()) {\n          ids.push(el.id);\n          objs.push(el);\n        }\n        results.push(el);\n      });\n      if (error) {\n        return _promise.default.reject(error);\n      }\n      const ParseQuery = _CoreManager.default.getParseQuery();\n      const query = new ParseQuery(className);\n      query.containedIn('objectId', ids);\n      if (options && options.include) {\n        query.include(options.include);\n      }\n      query._limit = ids.length;\n      return (0, _find.default)(query).call(query, options).then(async objects => {\n        const idMap = {};\n        (0, _forEach.default)(objects).call(objects, o => {\n          idMap[o.id] = o;\n        });\n        for (let i = 0; i < objs.length; i++) {\n          const obj = objs[i];\n          if (!obj || !obj.id || !idMap[obj.id]) {\n            if (forceFetch) {\n              return _promise.default.reject(new _ParseError.default(_ParseError.default.OBJECT_NOT_FOUND, 'All objects must exist on the server.'));\n            }\n          }\n        }\n        if (!singleInstance) {\n          // If single instance objects are disabled, we need to replace the\n          for (let i = 0; i < results.length; i++) {\n            const obj = results[i];\n            if (obj && obj.id && idMap[obj.id]) {\n              const id = obj.id;\n              obj._finishFetch(idMap[id].toJSON());\n              results[i] = idMap[id];\n            }\n          }\n        }\n        for (const object of results) {\n          await localDatastore._updateObjectIfPinned(object);\n        }\n        return _promise.default.resolve(results);\n      });\n    } else if (target instanceof ParseObject) {\n      if (!target.id) {\n        return _promise.default.reject(new _ParseError.default(_ParseError.default.MISSING_OBJECT_ID, 'Object does not have an ID'));\n      }\n      const RESTController = _CoreManager.default.getRESTController();\n      const params = {};\n      if (options && options.include) {\n        params.include = options.include.join();\n      }\n      return RESTController.request('GET', 'classes/' + target.className + '/' + target._getId(), params, options).then(async response => {\n        target._clearPendingOps();\n        target._clearServerData();\n        target._finishFetch(response);\n        await localDatastore._updateObjectIfPinned(target);\n        return target;\n      });\n    }\n    return _promise.default.resolve(undefined);\n  },\n  async destroy(target, options) {\n    if (options && options.batchSize && options.transaction) throw new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'You cannot use both transaction and batchSize options simultaneously.');\n    let batchSize = options && options.batchSize ? options.batchSize : _CoreManager.default.get('REQUEST_BATCH_SIZE');\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    const RESTController = _CoreManager.default.getRESTController();\n    if ((0, _isArray.default)(target)) {\n      if (options && options.transaction && target.length > 1) batchSize = target.length;\n      if (target.length < 1) {\n        return _promise.default.resolve([]);\n      }\n      const batches = [[]];\n      (0, _forEach.default)(target).call(target, obj => {\n        if (!obj.id) {\n          return;\n        }\n        batches[batches.length - 1].push(obj);\n        if (batches[batches.length - 1].length >= batchSize) {\n          batches.push([]);\n        }\n      });\n      if (batches[batches.length - 1].length === 0) {\n        // If the last batch is empty, remove it\n        batches.pop();\n      }\n      let deleteCompleted = _promise.default.resolve();\n      const errors = [];\n      (0, _forEach.default)(batches).call(batches, batch => {\n        const requests = (0, _map.default)(batch).call(batch, obj => {\n          return {\n            method: 'DELETE',\n            path: getServerUrlPath() + 'classes/' + obj.className + '/' + obj._getId(),\n            body: {}\n          };\n        });\n        const body = options && options.transaction && requests.length > 1 ? {\n          requests,\n          transaction: true\n        } : {\n          requests\n        };\n        deleteCompleted = deleteCompleted.then(() => {\n          return RESTController.request('POST', 'batch', body, options).then(results => {\n            for (let i = 0; i < results.length; i++) {\n              if (results[i] && Object.hasOwn(results[i], 'error')) {\n                const err = new _ParseError.default(results[i].error.code, results[i].error.error);\n                err.object = batch[i];\n                errors.push(err);\n              }\n            }\n          });\n        });\n      });\n      return deleteCompleted.then(async () => {\n        if (errors.length) {\n          const aggregate = new _ParseError.default(_ParseError.default.AGGREGATE_ERROR);\n          aggregate.errors = errors;\n          return _promise.default.reject(aggregate);\n        }\n        for (const object of target) {\n          await localDatastore._destroyObjectIfPinned(object);\n        }\n        return _promise.default.resolve(target);\n      });\n    } else if (target instanceof ParseObject) {\n      return RESTController.request('DELETE', 'classes/' + target.className + '/' + target._getId(), {}, options).then(async () => {\n        await localDatastore._destroyObjectIfPinned(target);\n        return _promise.default.resolve(target);\n      });\n    }\n    return _promise.default.resolve(target);\n  },\n  save(target, options) {\n    if (options && options.batchSize && options.transaction) return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'You cannot use both transaction and batchSize options simultaneously.'));\n    let batchSize = options && options.batchSize ? options.batchSize : _CoreManager.default.get('REQUEST_BATCH_SIZE');\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    const mapIdForPin = {};\n    const RESTController = _CoreManager.default.getRESTController();\n    const stateController = _CoreManager.default.getObjectStateController();\n    const allowCustomObjectId = _CoreManager.default.get('ALLOW_CUSTOM_OBJECT_ID');\n    options = options || {};\n    options.returnStatus = options.returnStatus || true;\n    if ((0, _isArray.default)(target)) {\n      if (target.length < 1) {\n        return _promise.default.resolve([]);\n      }\n      let unsaved = (0, _concat.default)(target).call(target);\n      for (let i = 0; i < target.length; i++) {\n        const target_i = target[i];\n        if (target_i instanceof ParseObject) {\n          unsaved = (0, _concat.default)(unsaved).call(unsaved, (0, _unsavedChildren.default)(target_i, true));\n        }\n      }\n      unsaved = (0, _unique.default)(unsaved);\n      const filesSaved = [];\n      let pending = [];\n      (0, _forEach.default)(unsaved).call(unsaved, el => {\n        if (el instanceof _ParseFile.default) {\n          filesSaved.push(el.save(options));\n        } else if (el instanceof ParseObject) {\n          pending.push(el);\n        }\n      });\n      if (options && options.transaction && pending.length > 1) {\n        if ((0, _some.default)(pending).call(pending, el => !(0, _canBeSerialized.default)(el))) return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Tried to save a transactional batch containing an object with unserializable attributes.'));\n        batchSize = pending.length;\n      }\n      return _promise.default.all(filesSaved).then(() => {\n        let objectError = null;\n        return (0, _promiseUtils.continueWhile)(() => {\n          return pending.length > 0;\n        }, () => {\n          const batch = [];\n          const nextPending = [];\n          (0, _forEach.default)(pending).call(pending, el => {\n            if (allowCustomObjectId && Object.hasOwn(el, 'id') && !el.id) {\n              throw new _ParseError.default(_ParseError.default.MISSING_OBJECT_ID, 'objectId must not be empty or null');\n            }\n            if (batch.length < batchSize && (0, _canBeSerialized.default)(el)) {\n              batch.push(el);\n            } else {\n              nextPending.push(el);\n            }\n          });\n          pending = nextPending;\n          if (batch.length < 1) {\n            return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Tried to save a batch with a cycle.'));\n          }\n\n          // Queue up tasks for each object in the batch.\n          // When every task is ready, the API request will execute\n          const batchReturned = (0, _promiseUtils.resolvingPromise)();\n          const batchReady = [];\n          const batchTasks = [];\n          (0, _forEach.default)(batch).call(batch, (obj, index) => {\n            // eslint-disable-next-line\n            const ready = (0, _promiseUtils.resolvingPromise)();\n            batchReady.push(ready);\n            stateController.pushPendingState(obj._getStateIdentifier());\n            batchTasks.push(stateController.enqueueTask(obj._getStateIdentifier(), function () {\n              ready.resolve();\n              return batchReturned.then(responses => {\n                if (Object.hasOwn(responses[index], 'success')) {\n                  const objectId = responses[index].success.objectId;\n                  const status = responses[index]._status;\n                  delete responses[index]._status;\n                  delete responses[index]._headers;\n                  mapIdForPin[objectId] = obj._localId;\n                  obj._handleSaveResponse(responses[index].success, status);\n                } else {\n                  if (!objectError && Object.hasOwn(responses[index], 'error')) {\n                    const serverError = responses[index].error;\n                    objectError = new _ParseError.default(serverError.code, serverError.error);\n                    // Cancel the rest of the save\n                    pending = [];\n                  }\n                  obj._handleSaveError();\n                }\n              });\n            }));\n          });\n          (0, _promiseUtils.when)(batchReady).then(() => {\n            // Kick off the batch request\n            const requests = (0, _map.default)(batch).call(batch, obj => {\n              const params = obj._getSaveParams();\n              params.path = getServerUrlPath() + params.path;\n              return params;\n            });\n            const body = options && options.transaction && requests.length > 1 ? {\n              requests,\n              transaction: true\n            } : {\n              requests\n            };\n            return RESTController.request('POST', 'batch', body, options);\n          }).then(batchReturned.resolve, error => {\n            batchReturned.reject(new _ParseError.default(_ParseError.default.INCORRECT_TYPE, error.message));\n          });\n          return (0, _promiseUtils.when)(batchTasks);\n        }).then(async () => {\n          if (objectError) {\n            return _promise.default.reject(objectError);\n          }\n          for (const object of target) {\n            // Make sure that it is a ParseObject before updating it into the localDataStore\n            if (object instanceof ParseObject) {\n              await localDatastore._updateLocalIdForObject(mapIdForPin[object.id], object);\n              await localDatastore._updateObjectIfPinned(object);\n            }\n          }\n          return _promise.default.resolve(target);\n        });\n      });\n    } else if (target instanceof ParseObject) {\n      if (allowCustomObjectId && Object.hasOwn(target, 'id') && !target.id) {\n        throw new _ParseError.default(_ParseError.default.MISSING_OBJECT_ID, 'objectId must not be empty or null');\n      }\n      // generate _localId in case if cascadeSave=false\n      target._getId();\n      const localId = target._localId;\n      // copying target lets guarantee the pointer isn't modified elsewhere\n      const targetCopy = target;\n      const task = function () {\n        const params = targetCopy._getSaveParams();\n        return RESTController.request(params.method, params.path, params.body, options).then(response => {\n          const status = response._status;\n          delete response._status;\n          delete response._headers;\n          targetCopy._handleSaveResponse(response, status);\n        }, error => {\n          targetCopy._handleSaveError();\n          return _promise.default.reject(error);\n        });\n      };\n      stateController.pushPendingState(target._getStateIdentifier());\n      return stateController.enqueueTask(target._getStateIdentifier(), task).then(async () => {\n        await localDatastore._updateLocalIdForObject(localId, target);\n        await localDatastore._updateObjectIfPinned(target);\n        return target;\n      }, error => {\n        return _promise.default.reject(error);\n      });\n    }\n    return _promise.default.resolve(undefined);\n  }\n};\n_CoreManager.default.setParseObject(ParseObject);\n_CoreManager.default.setObjectController(DefaultController);\nvar _default = exports.default = ParseObject;","map":{"version":3,"names":["_WeakMap","require","_Object$defineProperty2","_Object$getOwnPropertyDescriptor","_interopRequireDefault","exports","value","default","_defineProperty2","_create","_indexOf","_for","_stringify","_freeze","_keys","_forEach","_includes","_getPrototypeOf","_concat","_some","_promise","_isArray","_defineProperty3","_find","_map","_CoreManager","_canBeSerialized","_decode","_encode","_escape","_ParseACL","_parseDate","_ParseError","_ParseFile","_promiseUtils","_LocalDatastoreUtils","_uuid","_ParseOp","_ParseRelation","SingleInstanceStateController","_interopRequireWildcard","_unique","UniqueInstanceStateController","_unsavedChildren","e","t","r","n","__esModule","o","i","f","__proto__","has","get","set","hasOwnProperty","call","classMap","objectCount","singleInstance","setObjectStateController","getServerUrlPath","serverUrl","length","url","replace","substr","ParseObject","constructor","className","attributes","options","initialize","apply","arguments","toSet","_objCount","attr","_","Error","id","stateController","getObjectStateController","estimateAttributes","_getStateIdentifier","createdAt","_getServerData","updatedAt","_getId","_localId","localId","getServerData","_clearServerData","serverData","unset","undefined","setServerData","_getPendingOps","getPendingOps","_clearPendingOps","keysToClear","pending","latest","keys","key","_getDirtyObjectAttributes","objectCache","getObjectCache","dirty","val","json","stringified","_toFullJSON","seen","offline","toJSON","__type","_getSaveJSON","dirtyObjects","isDotNotation","field","fieldName","split","SetOp","_getSaveParams","method","body","path","objectId","_finishFetch","initializeState","decoded","_ensureParentAndKey","commitServerChanges","_setExisted","existed","state","getState","_migrateId","serverId","oldState","removeState","_handleSaveResponse","response","status","changes","popPendingState","RelationOp","applyTo","Object","prototype","UnsetOp","_handleSaveError","mergeFirstPendingState","_getClassMap","_getRequestOptions","requestOptions","toString","hasOwn","useMasterKey","useMaintenanceKey","sessionToken","installationId","transaction","batchSize","context","include","handleIncludeOptions","usePost","seenEntry","attrs","equals","other","pendingOps","dirtyKeys","isDataAvailable","toPointer","toOfflinePointer","relation","escape","newOps","readonly","readOnlyAttributes","k","Op","__op","opFromJSON","targetClassName","currentAttributes","newValues","ignoreValidation","validationError","validate","last","nextOp","mergeWith","setPendingOp","increment","amount","IncrementOp","decrement","add","item","AddOp","addAll","items","addUnique","AddUniqueOp","addAllUnique","remove","RemoveOp","removeAll","op","clone","copy","a","newInstance","duplicateState","isNew","exists","ParseQuery","getParseQuery","query","code","OBJECT_NOT_FOUND","isValid","ACL","OTHER_CAUSE","test","INVALID_KEY_NAME","getACL","acl","setACL","revert","keysToRevert","_len","Array","_key","push","clear","erasable","fetch","fetchOptions","controller","getObjectController","fetchWithInclude","saveEventually","save","CONNECTION_FAILED","getEventuallyQueue","poll","arg1","arg2","arg3","saveOptions","unsaved","cascadeSave","el","unsavedFiles","unsavedObjects","filePromise","resolve","then","savedOjbects","pop","destroyEventually","destroy","destroyOptions","pin","pinAllWithName","DEFAULT_PIN","unPin","unPinAllWithName","isPinned","localDatastore","getLocalDatastore","isEnabled","reject","objectKey","getKeyForObject","fromPinWithName","pinWithName","name","unPinWithName","fetchFromLocalDatastore","pinned","_serializeObject","result","fromJSON","_clearAllState","clearAllState","fetchAll","list","fetchAllWithInclude","fetchAllIfNeededWithInclude","fetchAllIfNeeded","_context","destroyAll","saveAll","createWithoutData","obj","override","otherAttributes","preserved","_preserveFieldsOnFetch","registerSubclass","TypeError","unregisterSubclass","extend","protoProps","classProps","adjustedClassName","parentProto","__super__","ParseObjectSubclass","_initializers","initializer","enumerable","writable","configurable","prop","enableSingleInstance","disableSingleInstance","pinAll","objects","_handlePinAllWithName","unPinAll","_handleUnPinAllWithName","unPinAllObjects","unPinAllObjectsWithName","PIN_PREFIX","DefaultController","target","forceFetch","objs","ids","results","error","INVALID_CLASS_NAME","MISSING_OBJECT_ID","containedIn","_limit","idMap","object","_updateObjectIfPinned","RESTController","getRESTController","params","join","request","batches","deleteCompleted","errors","batch","requests","err","aggregate","AGGREGATE_ERROR","_destroyObjectIfPinned","mapIdForPin","allowCustomObjectId","returnStatus","target_i","filesSaved","all","objectError","continueWhile","nextPending","batchReturned","resolvingPromise","batchReady","batchTasks","index","ready","pushPendingState","enqueueTask","responses","success","_status","_headers","serverError","when","INCORRECT_TYPE","message","_updateLocalIdForObject","targetCopy","task","setParseObject","setObjectController","_default"],"sources":["/home/snx/Desktop/CS_School/node_modules/parse/lib/browser/ParseObject.js"],"sourcesContent":["\"use strict\";\n\nvar _WeakMap = require(\"@babel/runtime-corejs3/core-js-stable/weak-map\");\nvar _Object$defineProperty2 = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\nvar _Object$getOwnPropertyDescriptor = require(\"@babel/runtime-corejs3/core-js-stable/object/get-own-property-descriptor\");\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n_Object$defineProperty2(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\nvar _create = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/create\"));\nvar _indexOf = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/index-of\"));\nvar _for = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/symbol/for\"));\nvar _stringify = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/json/stringify\"));\nvar _freeze = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/freeze\"));\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/keys\"));\nvar _forEach = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/for-each\"));\nvar _includes = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/includes\"));\nvar _getPrototypeOf = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/get-prototype-of\"));\nvar _concat = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/concat\"));\nvar _some = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/some\"));\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/promise\"));\nvar _isArray = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\"));\nvar _defineProperty3 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\"));\nvar _find = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/find\"));\nvar _map = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/map\"));\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\nvar _canBeSerialized = _interopRequireDefault(require(\"./canBeSerialized\"));\nvar _decode = _interopRequireDefault(require(\"./decode\"));\nvar _encode = _interopRequireDefault(require(\"./encode\"));\nvar _escape = _interopRequireDefault(require(\"./escape\"));\nvar _ParseACL = _interopRequireDefault(require(\"./ParseACL\"));\nvar _parseDate = _interopRequireDefault(require(\"./parseDate\"));\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\nvar _ParseFile = _interopRequireDefault(require(\"./ParseFile\"));\nvar _promiseUtils = require(\"./promiseUtils\");\nvar _LocalDatastoreUtils = require(\"./LocalDatastoreUtils\");\nvar _uuid = _interopRequireDefault(require(\"./uuid\"));\nvar _ParseOp = require(\"./ParseOp\");\nvar _ParseRelation = _interopRequireDefault(require(\"./ParseRelation\"));\nvar SingleInstanceStateController = _interopRequireWildcard(require(\"./SingleInstanceStateController\"));\nvar _unique = _interopRequireDefault(require(\"./unique\"));\nvar UniqueInstanceStateController = _interopRequireWildcard(require(\"./UniqueInstanceStateController\"));\nvar _unsavedChildren = _interopRequireDefault(require(\"./unsavedChildren\"));\nfunction _interopRequireWildcard(e, t) {\n  if (\"function\" == typeof _WeakMap) var r = new _WeakMap(),\n    n = new _WeakMap();\n  return (_interopRequireWildcard = function (e, t) {\n    if (!t && e && e.__esModule) return e;\n    var o,\n      i,\n      f = {\n        __proto__: null,\n        default: e\n      };\n    if (null === e || \"object\" != typeof e && \"function\" != typeof e) return f;\n    if (o = t ? n : r) {\n      if (o.has(e)) return o.get(e);\n      o.set(e, f);\n    }\n    for (const t in e) \"default\" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = _Object$defineProperty2) && _Object$getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]);\n    return f;\n  })(e, t);\n}\n// Mapping of class names to constructors, so we can populate objects from the\n// server with appropriate subclasses of ParseObject\nconst classMap = (0, _create.default)(null);\n\n// Global counter for generating unique Ids for non-single-instance objects\nlet objectCount = 0;\n// On web clients, objects are single-instance: any two objects with the same Id\n// will have the same attributes. However, this may be dangerous default\n// behavior in a server scenario\nlet singleInstance = !_CoreManager.default.get('IS_NODE');\nif (singleInstance) {\n  _CoreManager.default.setObjectStateController(SingleInstanceStateController);\n} else {\n  _CoreManager.default.setObjectStateController(UniqueInstanceStateController);\n}\nfunction getServerUrlPath() {\n  let serverUrl = _CoreManager.default.get('SERVER_URL');\n  if (serverUrl[serverUrl.length - 1] !== '/') {\n    serverUrl += '/';\n  }\n  const url = serverUrl.replace(/https?:\\/\\//, '');\n  return url.substr((0, _indexOf.default)(url).call(url, '/'));\n}\n\n/**\n * Creates a new model with defined attributes.\n *\n * <p>You won't normally call this method directly.  It is recommended that\n * you use a subclass of <code>Parse.Object</code> instead, created by calling\n * <code>extend</code>.</p>\n *\n * <p>However, if you don't want to use a subclass, or aren't sure which\n * subclass is appropriate, you can use this form:<pre>\n *     var object = new Parse.Object(\"ClassName\");\n * </pre>\n * That is basically equivalent to:<pre>\n *     var MyClass = Parse.Object.extend(\"ClassName\");\n *     var object = new MyClass();\n * </pre></p>\n *\n * @alias Parse.Object\n */\nclass ParseObject {\n  /**\n   * @param {string} className The class name for the object\n   * @param {object} attributes The initial set of data to store in the object.\n   * @param {object} options The options for this object instance.\n   * @param {boolean} [options.ignoreValidation] Set to `true` ignore any attribute validation errors.\n   */\n  constructor(className, attributes, options) {\n    /**\n     * The ID of this object, unique within its class.\n     *\n     * @property {string} id\n     */\n    (0, _defineProperty2.default)(this, \"id\", void 0);\n    (0, _defineProperty2.default)(this, \"_localId\", void 0);\n    (0, _defineProperty2.default)(this, \"_objCount\", void 0);\n    (0, _defineProperty2.default)(this, \"className\", void 0);\n    // Enable legacy initializers\n    if (typeof this.initialize === 'function') {\n      this.initialize.apply(this, arguments);\n    }\n    let toSet = null;\n    this._objCount = objectCount++;\n    if (typeof className === 'string') {\n      this.className = className;\n      if (attributes && typeof attributes === 'object') {\n        toSet = attributes;\n      }\n    } else if (className && typeof className === 'object') {\n      this.className = className.className;\n      toSet = {};\n      for (const attr in className) {\n        if (attr !== 'className') {\n          toSet[attr] = className[attr];\n        }\n      }\n      if (attributes && typeof attributes === 'object') {\n        options = attributes;\n      }\n    }\n    if (toSet) {\n      try {\n        this.set(toSet, options);\n      } catch (_) {\n        throw new Error(\"Can't create an invalid Parse Object\");\n      }\n    }\n    if (_CoreManager.default.get('NODE_LOGGING')) {\n      this[(0, _for.default)('nodejs.util.inspect.custom')] = function () {\n        return `ParseObject: className: ${this.className}, id: ${this.id}\\nAttributes: ${(0, _stringify.default)(this.attributes, null, 2)}`;\n      };\n    }\n  }\n  /* Prototype getters / setters */\n\n  get attributes() {\n    const stateController = _CoreManager.default.getObjectStateController();\n    return (0, _freeze.default)(stateController.estimateAttributes(this._getStateIdentifier()));\n  }\n\n  /**\n   * The first time this object was saved on the server.\n   *\n   * @property {Date} createdAt\n   * @returns {Date}\n   */\n  get createdAt() {\n    return this._getServerData().createdAt;\n  }\n\n  /**\n   * The last time this object was updated on the server.\n   *\n   * @property {Date} updatedAt\n   * @returns {Date}\n   */\n  get updatedAt() {\n    return this._getServerData().updatedAt;\n  }\n\n  /* Private methods */\n\n  /**\n   * Returns a local or server Id used uniquely identify this object\n   *\n   * @returns {string}\n   */\n  _getId() {\n    if (typeof this.id === 'string') {\n      return this.id;\n    }\n    if (typeof this._localId === 'string') {\n      return this._localId;\n    }\n    const localId = 'local' + (0, _uuid.default)();\n    this._localId = localId;\n    return localId;\n  }\n\n  /**\n   * Returns a unique identifier used to pull data from the State Controller.\n   *\n   * @returns {Parse.Object|object}\n   */\n  _getStateIdentifier() {\n    if (singleInstance) {\n      let id = this.id;\n      if (!id) {\n        id = this._getId();\n      }\n      return {\n        id,\n        className: this.className\n      };\n    } else {\n      return this;\n    }\n  }\n  _getServerData() {\n    const stateController = _CoreManager.default.getObjectStateController();\n    return stateController.getServerData(this._getStateIdentifier());\n  }\n  _clearServerData() {\n    const serverData = this._getServerData();\n    const unset = {};\n    for (const attr in serverData) {\n      unset[attr] = undefined;\n    }\n    const stateController = _CoreManager.default.getObjectStateController();\n    stateController.setServerData(this._getStateIdentifier(), unset);\n  }\n  _getPendingOps() {\n    const stateController = _CoreManager.default.getObjectStateController();\n    return stateController.getPendingOps(this._getStateIdentifier());\n  }\n\n  /**\n   * @param {Array<string>} [keysToClear] - if specified, only ops matching\n   * these fields will be cleared\n   */\n  _clearPendingOps(keysToClear) {\n    const pending = this._getPendingOps();\n    const latest = pending[pending.length - 1];\n    const keys = keysToClear || (0, _keys.default)(latest);\n    (0, _forEach.default)(keys).call(keys, key => {\n      delete latest[key];\n    });\n  }\n  _getDirtyObjectAttributes() {\n    const attributes = this.attributes;\n    const stateController = _CoreManager.default.getObjectStateController();\n    const objectCache = stateController.getObjectCache(this._getStateIdentifier());\n    const dirty = {};\n    for (const attr in attributes) {\n      const val = attributes[attr];\n      if (val && typeof val === 'object' && !(val instanceof ParseObject) && !(val instanceof _ParseFile.default) && !(val instanceof _ParseRelation.default)) {\n        // Due to the way browsers construct maps, the key order will not change\n        // unless the object is changed\n        try {\n          const json = (0, _encode.default)(val, false, true);\n          const stringified = (0, _stringify.default)(json);\n          if (objectCache[attr] !== stringified) {\n            dirty[attr] = val;\n          }\n        } catch (_) {\n          // Error occurred, possibly by a nested unsaved pointer in a mutable container\n          // No matter how it happened, it indicates a change in the attribute\n          dirty[attr] = val;\n        }\n      }\n    }\n    return dirty;\n  }\n  _toFullJSON(seen, offline) {\n    const json = this.toJSON(seen, offline);\n    json.__type = 'Object';\n    json.className = this.className;\n    return json;\n  }\n  _getSaveJSON() {\n    const pending = this._getPendingOps();\n    const dirtyObjects = this._getDirtyObjectAttributes();\n    const json = {};\n    for (var attr in dirtyObjects) {\n      let isDotNotation = false;\n      for (let i = 0; i < pending.length; i += 1) {\n        for (const field in pending[i]) {\n          // Dot notation operations are handled later\n          if ((0, _includes.default)(field).call(field, '.')) {\n            const fieldName = field.split('.')[0];\n            if (fieldName === attr) {\n              isDotNotation = true;\n              break;\n            }\n          }\n        }\n      }\n      if (!isDotNotation) {\n        json[attr] = new _ParseOp.SetOp(dirtyObjects[attr]).toJSON();\n      }\n    }\n    for (attr in pending[0]) {\n      json[attr] = pending[0][attr].toJSON();\n    }\n    return json;\n  }\n  _getSaveParams() {\n    let method = this.id ? 'PUT' : 'POST';\n    const body = this._getSaveJSON();\n    let path = 'classes/' + this.className;\n    if (_CoreManager.default.get('ALLOW_CUSTOM_OBJECT_ID')) {\n      if (!this.createdAt) {\n        method = 'POST';\n        body.objectId = this.id;\n      } else {\n        method = 'PUT';\n        path += '/' + this.id;\n      }\n    } else if (this.id) {\n      path += '/' + this.id;\n    } else if (this.className === '_User') {\n      path = 'users';\n    }\n    return {\n      method,\n      body,\n      path\n    };\n  }\n  _finishFetch(serverData) {\n    if (!this.id && serverData.objectId) {\n      this.id = serverData.objectId;\n    }\n    const stateController = _CoreManager.default.getObjectStateController();\n    stateController.initializeState(this._getStateIdentifier());\n    const decoded = {};\n    for (const attr in serverData) {\n      if (attr === 'ACL') {\n        decoded[attr] = new _ParseACL.default(serverData[attr]);\n      } else if (attr !== 'objectId') {\n        decoded[attr] = (0, _decode.default)(serverData[attr]);\n        if (decoded[attr] instanceof _ParseRelation.default) {\n          decoded[attr]._ensureParentAndKey(this, attr);\n        }\n      }\n    }\n    if (decoded.createdAt && typeof decoded.createdAt === 'string') {\n      decoded.createdAt = (0, _parseDate.default)(decoded.createdAt);\n    }\n    if (decoded.updatedAt && typeof decoded.updatedAt === 'string') {\n      decoded.updatedAt = (0, _parseDate.default)(decoded.updatedAt);\n    }\n    if (!decoded.updatedAt && decoded.createdAt) {\n      decoded.updatedAt = decoded.createdAt;\n    }\n    stateController.commitServerChanges(this._getStateIdentifier(), decoded);\n  }\n  _setExisted(existed) {\n    const stateController = _CoreManager.default.getObjectStateController();\n    const state = stateController.getState(this._getStateIdentifier());\n    if (state) {\n      state.existed = existed;\n    }\n  }\n  _migrateId(serverId) {\n    if (this._localId && serverId) {\n      if (singleInstance) {\n        const stateController = _CoreManager.default.getObjectStateController();\n        const oldState = stateController.removeState(this._getStateIdentifier());\n        this.id = serverId;\n        delete this._localId;\n        if (oldState) {\n          stateController.initializeState(this._getStateIdentifier(), oldState);\n        }\n      } else {\n        this.id = serverId;\n        delete this._localId;\n      }\n    }\n  }\n  _handleSaveResponse(response, status) {\n    const changes = {};\n    const stateController = _CoreManager.default.getObjectStateController();\n    const pending = stateController.popPendingState(this._getStateIdentifier());\n    for (var attr in pending) {\n      if (pending[attr] instanceof _ParseOp.RelationOp) {\n        changes[attr] = pending[attr].applyTo(undefined, this, attr);\n      } else if (!(attr in response)) {\n        // Only SetOps and UnsetOps should not come back with results\n        changes[attr] = pending[attr].applyTo(undefined);\n      }\n    }\n    for (attr in response) {\n      if ((attr === 'createdAt' || attr === 'updatedAt') && typeof response[attr] === 'string') {\n        changes[attr] = (0, _parseDate.default)(response[attr]);\n      } else if (attr === 'ACL') {\n        changes[attr] = new _ParseACL.default(response[attr]);\n      } else if (attr !== 'objectId') {\n        const val = (0, _decode.default)(response[attr]);\n        if (val && (0, _getPrototypeOf.default)(val) === Object.prototype) {\n          changes[attr] = {\n            ...this.attributes[attr],\n            ...val\n          };\n        } else {\n          changes[attr] = val;\n        }\n        if (changes[attr] instanceof _ParseOp.UnsetOp) {\n          changes[attr] = undefined;\n        }\n      }\n    }\n    if (changes.createdAt && !changes.updatedAt) {\n      changes.updatedAt = changes.createdAt;\n    }\n    this._migrateId(response.objectId);\n    if (status !== 201) {\n      this._setExisted(true);\n    }\n    stateController.commitServerChanges(this._getStateIdentifier(), changes);\n  }\n  _handleSaveError() {\n    const stateController = _CoreManager.default.getObjectStateController();\n    stateController.mergeFirstPendingState(this._getStateIdentifier());\n  }\n  static _getClassMap() {\n    return classMap;\n  }\n  static _getRequestOptions() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const requestOptions = {};\n    if (Object.prototype.toString.call(options) !== '[object Object]') {\n      throw new Error('request options must be of type Object');\n    }\n    const {\n      hasOwn\n    } = Object;\n    if (hasOwn(options, 'useMasterKey')) {\n      requestOptions.useMasterKey = !!options.useMasterKey;\n    }\n    if (hasOwn(options, 'useMaintenanceKey')) {\n      requestOptions.useMaintenanceKey = !!options.useMaintenanceKey;\n    }\n    if (hasOwn(options, 'sessionToken') && typeof options.sessionToken === 'string') {\n      requestOptions.sessionToken = options.sessionToken;\n    }\n    if (hasOwn(options, 'installationId') && typeof options.installationId === 'string') {\n      requestOptions.installationId = options.installationId;\n    }\n    if (hasOwn(options, 'transaction') && typeof options.transaction === 'boolean') {\n      requestOptions.transaction = options.transaction;\n    }\n    if (hasOwn(options, 'batchSize') && typeof options.batchSize === 'number') {\n      requestOptions.batchSize = options.batchSize;\n    }\n    if (hasOwn(options, 'context') && typeof options.context === 'object') {\n      requestOptions.context = options.context;\n    }\n    if (hasOwn(options, 'include')) {\n      requestOptions.include = ParseObject.handleIncludeOptions(options);\n    }\n    if (hasOwn(options, 'usePost')) {\n      requestOptions.usePost = options.usePost;\n    }\n    if (hasOwn(options, 'json')) {\n      requestOptions.json = options.json;\n    }\n    return requestOptions;\n  }\n\n  /* Public methods */\n\n  initialize() {\n    // NOOP\n  }\n\n  /**\n   * Returns a JSON version of the object suitable for saving to Parse.\n   *\n   * @param seen\n   * @param offline\n   * @returns {object}\n   */\n  toJSON(seen, offline) {\n    const seenEntry = this.id ? this.className + ':' + this.id : this;\n    seen = seen || [seenEntry];\n    const json = {};\n    const attrs = this.attributes;\n    for (const attr in attrs) {\n      if ((attr === 'createdAt' || attr === 'updatedAt') && attrs[attr].toJSON) {\n        json[attr] = attrs[attr].toJSON();\n      } else {\n        json[attr] = (0, _encode.default)(attrs[attr], false, false, seen, offline);\n      }\n    }\n    const pending = this._getPendingOps();\n    for (const attr in pending[0]) {\n      if ((0, _indexOf.default)(attr).call(attr, '.') < 0) {\n        json[attr] = pending[0][attr].toJSON(offline);\n      }\n    }\n    if (this.id) {\n      json.objectId = this.id;\n    }\n    return json;\n  }\n\n  /**\n   * Determines whether this ParseObject is equal to another ParseObject\n   *\n   * @param {object} other - An other object ot compare\n   * @returns {boolean}\n   */\n  equals(other) {\n    if (this === other) {\n      return true;\n    }\n    return other instanceof ParseObject && this.className === other.className && this.id === other.id && typeof this.id !== 'undefined';\n  }\n\n  /**\n   * Returns true if this object has been modified since its last\n   * save/refresh.  If an attribute is specified, it returns true only if that\n   * particular attribute has been modified since the last save/refresh.\n   *\n   * @param {string} attr An attribute name (optional).\n   * @returns {boolean}\n   */\n  dirty(attr) {\n    if (!this.id) {\n      return true;\n    }\n    const pendingOps = this._getPendingOps();\n    const dirtyObjects = this._getDirtyObjectAttributes();\n    if (attr) {\n      if (Object.hasOwn(dirtyObjects, attr)) {\n        return true;\n      }\n      for (let i = 0; i < pendingOps.length; i++) {\n        if (Object.hasOwn(pendingOps[i], attr)) {\n          return true;\n        }\n      }\n      return false;\n    }\n    if ((0, _keys.default)(pendingOps[0]).length !== 0) {\n      return true;\n    }\n    if ((0, _keys.default)(dirtyObjects).length !== 0) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Returns an array of keys that have been modified since last save/refresh\n   *\n   * @returns {string[]}\n   */\n  dirtyKeys() {\n    const pendingOps = this._getPendingOps();\n    const keys = {};\n    for (let i = 0; i < pendingOps.length; i++) {\n      for (const attr in pendingOps[i]) {\n        keys[attr] = true;\n      }\n    }\n    const dirtyObjects = this._getDirtyObjectAttributes();\n    for (const attr in dirtyObjects) {\n      keys[attr] = true;\n    }\n    return (0, _keys.default)(keys);\n  }\n\n  /**\n   * Returns true if the object has been fetched.\n   *\n   * @returns {boolean}\n   */\n  isDataAvailable() {\n    const serverData = this._getServerData();\n    return !!(0, _keys.default)(serverData).length;\n  }\n\n  /**\n   * Gets a Pointer referencing this Object.\n   *\n   * @returns {Pointer}\n   */\n  toPointer() {\n    if (!this.id) {\n      throw new Error('Cannot create a pointer to an unsaved ParseObject');\n    }\n    return {\n      __type: 'Pointer',\n      className: this.className,\n      objectId: this.id\n    };\n  }\n\n  /**\n   * Gets a Pointer referencing this Object.\n   *\n   * @returns {Pointer}\n   */\n  toOfflinePointer() {\n    if (!this._localId) {\n      throw new Error('Cannot create a offline pointer to a saved ParseObject');\n    }\n    return {\n      __type: 'Object',\n      className: this.className,\n      _localId: this._localId\n    };\n  }\n\n  /**\n   * Gets the value of an attribute.\n   *\n   * @param {string} attr The string name of an attribute.\n   * @returns {*}\n   */\n  get(attr) {\n    return this.attributes[attr];\n  }\n\n  /**\n   * Gets a relation on the given class for the attribute.\n   *\n   * @param {string} attr The attribute to get the relation for.\n   * @returns {Parse.Relation}\n   */\n  relation(attr) {\n    const value = this.get(attr);\n    if (value) {\n      if (!(value instanceof _ParseRelation.default)) {\n        throw new Error('Called relation() on non-relation field ' + attr);\n      }\n      value._ensureParentAndKey(this, attr);\n      return value;\n    }\n    return new _ParseRelation.default(this, attr);\n  }\n\n  /**\n   * Gets the HTML-escaped value of an attribute.\n   *\n   * @param {string} attr The string name of an attribute.\n   * @returns {string}\n   */\n  escape(attr) {\n    let val = this.attributes[attr];\n    if (val == null) {\n      return '';\n    }\n    if (typeof val !== 'string') {\n      if (typeof val.toString !== 'function') {\n        return '';\n      }\n      val = val.toString();\n    }\n    return (0, _escape.default)(val);\n  }\n\n  /**\n   * Returns <code>true</code> if the attribute contains a value that is not\n   * null or undefined.\n   *\n   * @param {string} attr The string name of the attribute.\n   * @returns {boolean}\n   */\n  has(attr) {\n    const attributes = this.attributes;\n    if (Object.hasOwn(attributes, attr)) {\n      return attributes[attr] != null;\n    }\n    return false;\n  }\n\n  /**\n   * Sets a hash of model attributes on the object.\n   *\n   * <p>You can call it with an object containing keys and values, with one\n   * key and value, or dot notation.  For example:<pre>\n   *   gameTurn.set({\n   *     player: player1,\n   *     diceRoll: 2\n   *   }, {\n   *     error: function(gameTurnAgain, error) {\n   *       // The set failed validation.\n   *     }\n   *   });\n   *\n   *   game.set(\"currentPlayer\", player2, {\n   *     error: function(gameTurnAgain, error) {\n   *       // The set failed validation.\n   *     }\n   *   });\n   *\n   *   game.set(\"finished\", true);</pre></p>\n   *\n   *   game.set(\"player.score\", 10);</pre></p>\n   *\n   * @param {(string|object)} key The key to set.\n   * @param {(string|object)} value The value to give it.\n   * @param {object} options A set of options for the set.\n   *     The only supported option is <code>error</code>.\n   * @returns {Parse.Object} Returns the object, so you can chain this call.\n   */\n  set(key, value, options) {\n    let changes = {};\n    const newOps = {};\n    if (key && typeof key === 'object') {\n      changes = key;\n      options = value;\n    } else if (typeof key === 'string') {\n      changes[key] = value;\n    } else {\n      return this;\n    }\n    options = options || {};\n    let readonly = [];\n    if (typeof this.constructor.readOnlyAttributes === 'function') {\n      readonly = (0, _concat.default)(readonly).call(readonly, this.constructor.readOnlyAttributes());\n    }\n    for (const k in changes) {\n      if (k === 'createdAt' || k === 'updatedAt') {\n        // This property is read-only, but for legacy reasons we silently\n        // ignore it\n        continue;\n      }\n      if ((0, _indexOf.default)(readonly).call(readonly, k) > -1) {\n        throw new Error('Cannot modify readonly attribute: ' + k);\n      }\n      if (options.unset) {\n        newOps[k] = new _ParseOp.UnsetOp();\n      } else if (changes[k] instanceof _ParseOp.Op) {\n        newOps[k] = changes[k];\n      } else if (changes[k] && typeof changes[k] === 'object' && typeof changes[k].__op === 'string') {\n        newOps[k] = (0, _ParseOp.opFromJSON)(changes[k]);\n      } else if (k === 'objectId' || k === 'id') {\n        if (typeof changes[k] === 'string') {\n          this.id = changes[k];\n        }\n      } else if (k === 'ACL' && typeof changes[k] === 'object' && !(changes[k] instanceof _ParseACL.default)) {\n        newOps[k] = new _ParseOp.SetOp(new _ParseACL.default(changes[k]));\n      } else if (changes[k] instanceof _ParseRelation.default) {\n        const relation = new _ParseRelation.default(this, k);\n        relation.targetClassName = changes[k].targetClassName;\n        newOps[k] = new _ParseOp.SetOp(relation);\n      } else {\n        newOps[k] = new _ParseOp.SetOp(changes[k]);\n      }\n    }\n    const currentAttributes = this.attributes;\n\n    // Calculate new values\n    const newValues = {};\n    for (const attr in newOps) {\n      if (newOps[attr] instanceof _ParseOp.RelationOp) {\n        newValues[attr] = newOps[attr].applyTo(currentAttributes[attr], this, attr);\n      } else if (!(newOps[attr] instanceof _ParseOp.UnsetOp)) {\n        newValues[attr] = newOps[attr].applyTo(currentAttributes[attr]);\n      }\n    }\n\n    // Validate changes\n    if (!options.ignoreValidation) {\n      const validationError = this.validate(newValues);\n      if (validationError) {\n        throw validationError;\n      }\n    }\n\n    // Consolidate Ops\n    const pendingOps = this._getPendingOps();\n    const last = pendingOps.length - 1;\n    const stateController = _CoreManager.default.getObjectStateController();\n    for (const attr in newOps) {\n      const nextOp = newOps[attr].mergeWith(pendingOps[last][attr]);\n      stateController.setPendingOp(this._getStateIdentifier(), attr, nextOp);\n    }\n    return this;\n  }\n\n  /**\n   * Remove an attribute from the model. This is a noop if the attribute doesn't\n   * exist.\n   *\n   * @param {string} attr The string name of an attribute.\n   * @param options\n   * @returns {Parse.Object} Returns the object, so you can chain this call.\n   */\n  unset(attr, options) {\n    options = options || {};\n    options.unset = true;\n    return this.set(attr, null, options);\n  }\n\n  /**\n   * Atomically increments the value of the given attribute the next time the\n   * object is saved. If no amount is specified, 1 is used by default.\n   *\n   * @param attr {String} The key.\n   * @param amount {Number} The amount to increment by (optional).\n   * @returns {Parse.Object} Returns the object, so you can chain this call.\n   */\n  increment(attr, amount) {\n    if (typeof amount === 'undefined') {\n      amount = 1;\n    }\n    if (typeof amount !== 'number') {\n      throw new Error('Cannot increment by a non-numeric amount.');\n    }\n    return this.set(attr, new _ParseOp.IncrementOp(amount));\n  }\n\n  /**\n   * Atomically decrements the value of the given attribute the next time the\n   * object is saved. If no amount is specified, 1 is used by default.\n   *\n   * @param attr {String} The key.\n   * @param amount {Number} The amount to decrement by (optional).\n   * @returns {Parse.Object} Returns the object, so you can chain this call.\n   */\n  decrement(attr, amount) {\n    if (typeof amount === 'undefined') {\n      amount = 1;\n    }\n    if (typeof amount !== 'number') {\n      throw new Error('Cannot decrement by a non-numeric amount.');\n    }\n    return this.set(attr, new _ParseOp.IncrementOp(amount * -1));\n  }\n\n  /**\n   * Atomically add an object to the end of the array associated with a given\n   * key.\n   *\n   * @param attr {String} The key.\n   * @param item {} The item to add.\n   * @returns {Parse.Object} Returns the object, so you can chain this call.\n   */\n  add(attr, item) {\n    return this.set(attr, new _ParseOp.AddOp([item]));\n  }\n\n  /**\n   * Atomically add the objects to the end of the array associated with a given\n   * key.\n   *\n   * @param attr {String} The key.\n   * @param items {Object[]} The items to add.\n   * @returns {Parse.Object} Returns the object, so you can chain this call.\n   */\n  addAll(attr, items) {\n    return this.set(attr, new _ParseOp.AddOp(items));\n  }\n\n  /**\n   * Atomically add an object to the array associated with a given key, only\n   * if it is not already present in the array. The position of the insert is\n   * not guaranteed.\n   *\n   * @param attr {String} The key.\n   * @param item {} The object to add.\n   * @returns {Parse.Object} Returns the object, so you can chain this call.\n   */\n  addUnique(attr, item) {\n    return this.set(attr, new _ParseOp.AddUniqueOp([item]));\n  }\n\n  /**\n   * Atomically add the objects to the array associated with a given key, only\n   * if it is not already present in the array. The position of the insert is\n   * not guaranteed.\n   *\n   * @param attr {String} The key.\n   * @param items {Object[]} The objects to add.\n   * @returns {Parse.Object} Returns the object, so you can chain this call.\n   */\n  addAllUnique(attr, items) {\n    return this.set(attr, new _ParseOp.AddUniqueOp(items));\n  }\n\n  /**\n   * Atomically remove all instances of an object from the array associated\n   * with a given key.\n   *\n   * @param attr {String} The key.\n   * @param item {} The object to remove.\n   * @returns {Parse.Object} Returns the object, so you can chain this call.\n   */\n  remove(attr, item) {\n    return this.set(attr, new _ParseOp.RemoveOp([item]));\n  }\n\n  /**\n   * Atomically remove all instances of the objects from the array associated\n   * with a given key.\n   *\n   * @param attr {String} The key.\n   * @param items {Object[]} The object to remove.\n   * @returns {Parse.Object} Returns the object, so you can chain this call.\n   */\n  removeAll(attr, items) {\n    return this.set(attr, new _ParseOp.RemoveOp(items));\n  }\n\n  /**\n   * Returns an instance of a subclass of Parse.Op describing what kind of\n   * modification has been performed on this field since the last time it was\n   * saved. For example, after calling object.increment(\"x\"), calling\n   * object.op(\"x\") would return an instance of Parse.Op.Increment.\n   *\n   * @param attr {String} The key.\n   * @returns {Parse.Op | undefined} The operation, or undefined if none.\n   */\n  op(attr) {\n    const pending = this._getPendingOps();\n    for (let i = 0; i < pending.length; i += 1) {\n      if (pending[i][attr]) {\n        return pending[i][attr];\n      }\n    }\n  }\n\n  /**\n   * Creates a new model with identical attributes to this one.\n   *\n   * @returns {Parse.Object}\n   */\n  clone() {\n    const clone = new this.constructor(this.className);\n    let attributes = this.attributes;\n    if (typeof this.constructor.readOnlyAttributes === 'function') {\n      const readonly = this.constructor.readOnlyAttributes() || [];\n      // Attributes are frozen, so we have to rebuild an object,\n      // rather than delete readonly keys\n      const copy = {};\n      for (const a in attributes) {\n        if ((0, _indexOf.default)(readonly).call(readonly, a) < 0) {\n          copy[a] = attributes[a];\n        }\n      }\n      attributes = copy;\n    }\n    if (clone.set) {\n      clone.set(attributes);\n    }\n    return clone;\n  }\n\n  /**\n   * Creates a new instance of this object. Not to be confused with clone()\n   *\n   * @returns {Parse.Object}\n   */\n  newInstance() {\n    const clone = new this.constructor(this.className);\n    clone.id = this.id;\n    if (singleInstance) {\n      // Just return an object with the right id\n      return clone;\n    }\n    const stateController = _CoreManager.default.getObjectStateController();\n    if (stateController) {\n      stateController.duplicateState(this._getStateIdentifier(), clone._getStateIdentifier());\n    }\n    return clone;\n  }\n\n  /**\n   * Returns true if this object has never been saved to Parse.\n   *\n   * @returns {boolean}\n   */\n  isNew() {\n    return !this.id;\n  }\n\n  /**\n   * Returns true if this object was created by the Parse server when the\n   * object might have already been there (e.g. in the case of a Facebook\n   * login)\n   *\n   * @returns {boolean}\n   */\n  existed() {\n    if (!this.id) {\n      return false;\n    }\n    const stateController = _CoreManager.default.getObjectStateController();\n    const state = stateController.getState(this._getStateIdentifier());\n    if (state) {\n      return state.existed;\n    }\n    return false;\n  }\n\n  /**\n   * Returns true if this object exists on the Server\n   *\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise<boolean>} A boolean promise that is fulfilled if object exists.\n   */\n  async exists(options) {\n    if (!this.id) {\n      return false;\n    }\n    try {\n      const ParseQuery = _CoreManager.default.getParseQuery();\n      const query = new ParseQuery(this.className);\n      await query.get(this.id, options);\n      return true;\n    } catch (e) {\n      if (e.code === _ParseError.default.OBJECT_NOT_FOUND) {\n        return false;\n      }\n      throw e;\n    }\n  }\n\n  /**\n   * Checks if the model is currently in a valid state.\n   *\n   * @returns {boolean}\n   */\n  isValid() {\n    return !this.validate(this.attributes);\n  }\n\n  /**\n   * You should not call this function directly unless you subclass\n   * <code>Parse.Object</code>, in which case you can override this method\n   * to provide additional validation on <code>set</code> and\n   * <code>save</code>.  Your implementation should return\n   *\n   * @param {object} attrs The current data to validate.\n   * @returns {Parse.Error|boolean} False if the data is valid.  An error object otherwise.\n   * @see Parse.Object#set\n   */\n  validate(attrs) {\n    if (Object.hasOwn(attrs, 'ACL') && !(attrs.ACL instanceof _ParseACL.default)) {\n      return new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'ACL must be a Parse ACL.');\n    }\n    for (const key in attrs) {\n      if (!/^[A-Za-z_][0-9A-Za-z_.]*$/.test(key)) {\n        return new _ParseError.default(_ParseError.default.INVALID_KEY_NAME, `Invalid key name: ${key}`);\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Returns the ACL for this object.\n   *\n   * @returns {Parse.ACL|null} An instance of Parse.ACL.\n   * @see Parse.Object#get\n   */\n  getACL() {\n    const acl = this.get('ACL');\n    if (acl instanceof _ParseACL.default) {\n      return acl;\n    }\n    return null;\n  }\n\n  /**\n   * Sets the ACL to be used for this object.\n   *\n   * @param {Parse.ACL} acl An instance of Parse.ACL.\n   * @param {object} options\n   * @returns {Parse.Object} Returns the object, so you can chain this call.\n   * @see Parse.Object#set\n   */\n  setACL(acl, options) {\n    return this.set('ACL', acl, options);\n  }\n\n  /**\n   * Clears any (or specific) changes to this object made since the last call to save()\n   *\n   * @param {string} [keys] - specify which fields to revert\n   */\n  revert() {\n    let keysToRevert;\n    for (var _len = arguments.length, keys = new Array(_len), _key = 0; _key < _len; _key++) {\n      keys[_key] = arguments[_key];\n    }\n    if (keys.length) {\n      keysToRevert = [];\n      for (const key of keys) {\n        if (typeof key === 'string') {\n          keysToRevert.push(key);\n        } else {\n          throw new Error('Parse.Object#revert expects either no, or a list of string, arguments.');\n        }\n      }\n    }\n    this._clearPendingOps(keysToRevert);\n  }\n\n  /**\n   * Clears all attributes on a model\n   *\n   * @returns {Parse.Object} Returns the object, so you can chain this call.\n   */\n  clear() {\n    const attributes = this.attributes;\n    const erasable = {};\n    let readonly = ['createdAt', 'updatedAt'];\n    if (typeof this.constructor.readOnlyAttributes === 'function') {\n      readonly = (0, _concat.default)(readonly).call(readonly, this.constructor.readOnlyAttributes());\n    }\n    for (const attr in attributes) {\n      if ((0, _indexOf.default)(readonly).call(readonly, attr) < 0) {\n        erasable[attr] = true;\n      }\n    }\n    return this.set(erasable, {\n      unset: true\n    });\n  }\n\n  /**\n   * Fetch the model from the server. If the server's representation of the\n   * model differs from its current attributes, they will be overriden.\n   *\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>include: The name(s) of the key(s) to include. Can be a string, an array of strings,\n   *       or an array of array of strings.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n   * </ul>\n   * @returns {Promise} A promise that is fulfilled when the fetch\n   *     completes.\n   */\n  fetch(options) {\n    const fetchOptions = ParseObject._getRequestOptions(options);\n    const controller = _CoreManager.default.getObjectController();\n    return controller.fetch(this, true, fetchOptions);\n  }\n\n  /**\n   * Fetch the model from the server. If the server's representation of the\n   * model differs from its current attributes, they will be overriden.\n   *\n   * Includes nested Parse.Objects for the provided key. You can use dot\n   * notation to specify which fields in the included object are also fetched.\n   *\n   * @param {string | Array<string | Array<string>>} keys The name(s) of the key(s) to include.\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise} A promise that is fulfilled when the fetch\n   *     completes.\n   */\n  fetchWithInclude(keys, options) {\n    options = options || {};\n    options.include = keys;\n    return this.fetch(options);\n  }\n\n  /**\n   * Saves this object to the server at some unspecified time in the future,\n   * even if Parse is currently inaccessible.\n   *\n   * Use this when you may not have a solid network connection, and don't need to know when the save completes.\n   * If there is some problem with the object such that it can't be saved, it will be silently discarded.\n   *\n   * Objects saved with this method will be stored locally in an on-disk cache until they can be delivered to Parse.\n   * They will be sent immediately if possible. Otherwise, they will be sent the next time a network connection is\n   * available. Objects saved this way will persist even after the app is closed, in which case they will be sent the\n   * next time the app is opened.\n   *\n   * @param {object} [options]\n   * Used to pass option parameters to method if arg1 and arg2 were both passed as strings.\n   * Valid options are:\n   * <ul>\n   * <li>sessionToken: A valid session token, used for making a request on\n   * behalf of a specific user.\n   * <li>cascadeSave: If `false`, nested objects will not be saved (default is `true`).\n   * <li>context: A dictionary that is accessible in Cloud Code `beforeSave` and `afterSave` triggers.\n   * </ul>\n   * @returns {Promise} A promise that is fulfilled when the save\n   * completes.\n   */\n  async saveEventually(options) {\n    try {\n      await this.save(null, options);\n    } catch (e) {\n      if (e.code === _ParseError.default.CONNECTION_FAILED) {\n        await _CoreManager.default.getEventuallyQueue().save(this, options);\n        _CoreManager.default.getEventuallyQueue().poll();\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Set a hash of model attributes, and save the model to the server.\n   * updatedAt will be updated when the request returns.\n   * You can either call it as:<pre>\n   * object.save();</pre>\n   * or<pre>\n   * object.save(attrs);</pre>\n   * or<pre>\n   * object.save(null, options);</pre>\n   * or<pre>\n   * object.save(attrs, options);</pre>\n   * or<pre>\n   * object.save(key, value);</pre>\n   * or<pre>\n   * object.save(key, value, options);</pre>\n   *\n   * Example 1: <pre>\n   * gameTurn.save({\n   * player: \"Jake Cutter\",\n   * diceRoll: 2\n   * }).then(function(gameTurnAgain) {\n   * // The save was successful.\n   * }, function(error) {\n   * // The save failed.  Error is an instance of Parse.Error.\n   * });</pre>\n   *\n   * Example 2: <pre>\n   * gameTurn.save(\"player\", \"Jake Cutter\");</pre>\n   *\n   * @param {string | object | null} [arg1]\n   * Valid options are:<ul>\n   * <li>`Object` - Key/value pairs to update on the object.</li>\n   * <li>`String` Key - Key of attribute to update (requires arg2 to also be string)</li>\n   * <li>`null` - Passing null for arg1 allows you to save the object with options passed in arg2.</li>\n   * </ul>\n   * @param {string | object} [arg2]\n   * <ul>\n   * <li>`String` Value - If arg1 was passed as a key, arg2 is the value that should be set on that key.</li>\n   * <li>`Object` Options - Valid options are:\n   * <ul>\n   * <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   * be used for this request.\n   * <li>sessionToken: A valid session token, used for making a request on\n   * behalf of a specific user.\n   * <li>cascadeSave: If `false`, nested objects will not be saved (default is `true`).\n   * <li>context: A dictionary that is accessible in Cloud Code `beforeSave` and `afterSave` triggers.\n   * </ul>\n   * </li>\n   * </ul>\n   * @param {object} [arg3]\n   * Used to pass option parameters to method if arg1 and arg2 were both passed as strings.\n   * Valid options are:\n   * <ul>\n   * <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   * be used for this request.\n   * <li>sessionToken: A valid session token, used for making a request on\n   * behalf of a specific user.\n   * <li>cascadeSave: If `false`, nested objects will not be saved (default is `true`).\n   * <li>context: A dictionary that is accessible in Cloud Code `beforeSave` and `afterSave` triggers.\n   * </ul>\n   * @returns {Promise} A promise that is fulfilled when the save\n   * completes.\n   */\n\n  async save(arg1, arg2, arg3) {\n    let attrs;\n    let options;\n    if (typeof arg1 === 'object' || typeof arg1 === 'undefined') {\n      attrs = arg1;\n      if (typeof arg2 === 'object') {\n        options = arg2;\n      }\n    } else {\n      attrs = {};\n      attrs[arg1] = arg2;\n      options = arg3;\n    }\n    options = options || {};\n    if (attrs) {\n      this.set(attrs, options);\n    }\n    const saveOptions = ParseObject._getRequestOptions(options);\n    const controller = _CoreManager.default.getObjectController();\n    const unsaved = options.cascadeSave !== false ? (0, _unsavedChildren.default)(this) : null;\n    if (unsaved && unsaved.length && options.transaction === true && (0, _some.default)(unsaved).call(unsaved, el => el instanceof ParseObject)) {\n      const unsavedFiles = [];\n      const unsavedObjects = [];\n      (0, _forEach.default)(unsaved).call(unsaved, el => {\n        if (el instanceof _ParseFile.default) unsavedFiles.push(el);else unsavedObjects.push(el);\n      });\n      unsavedObjects.push(this);\n      const filePromise = unsavedFiles.length ? controller.save(unsavedFiles, saveOptions) : _promise.default.resolve();\n      return filePromise.then(() => controller.save(unsavedObjects, saveOptions)).then(savedOjbects => savedOjbects.pop());\n    }\n    await controller.save(unsaved, saveOptions);\n    return controller.save(this, saveOptions);\n  }\n\n  /**\n   * Deletes this object from the server at some unspecified time in the future,\n   * even if Parse is currently inaccessible.\n   *\n   * Use this when you may not have a solid network connection,\n   * and don't need to know when the delete completes. If there is some problem with the object\n   * such that it can't be deleted, the request will be silently discarded.\n   *\n   * Delete instructions made with this method will be stored locally in an on-disk cache until they can be transmitted\n   * to Parse. They will be sent immediately if possible. Otherwise, they will be sent the next time a network connection\n   * is available. Delete requests will persist even after the app is closed, in which case they will be sent the\n   * next time the app is opened.\n   *\n   * @param {object} [options]\n   * Valid options are:<ul>\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeDelete` and `afterDelete` triggers.\n   * </ul>\n   * @returns {Promise} A promise that is fulfilled when the destroy\n   *     completes.\n   */\n  async destroyEventually(options) {\n    try {\n      await this.destroy(options);\n    } catch (e) {\n      if (e.code === _ParseError.default.CONNECTION_FAILED) {\n        await _CoreManager.default.getEventuallyQueue().destroy(this, options);\n        _CoreManager.default.getEventuallyQueue().poll();\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Destroy this model on the server if it was already persisted.\n   *\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeDelete` and `afterDelete` triggers.\n   * </ul>\n   * @returns {Promise} A promise that is fulfilled when the destroy\n   *     completes.\n   */\n  destroy(options) {\n    if (!this.id) {\n      return _promise.default.resolve(undefined);\n    }\n    const destroyOptions = ParseObject._getRequestOptions(options);\n    return _CoreManager.default.getObjectController().destroy(this, destroyOptions);\n  }\n\n  /**\n   * Asynchronously stores the object and every object it points to in the local datastore,\n   * recursively, using a default pin name: _default.\n   *\n   * If those other objects have not been fetched from Parse, they will not be stored.\n   * However, if they have changed data, all the changes will be retained.\n   *\n   * <pre>\n   * await object.pin();\n   * </pre>\n   *\n   * To retrieve object:\n   * <code>query.fromLocalDatastore()</code> or <code>query.fromPin()</code>\n   *\n   * @returns {Promise} A promise that is fulfilled when the pin completes.\n   */\n  pin() {\n    return ParseObject.pinAllWithName(_LocalDatastoreUtils.DEFAULT_PIN, [this]);\n  }\n\n  /**\n   * Asynchronously removes the object and every object it points to in the local datastore,\n   * recursively, using a default pin name: _default.\n   *\n   * <pre>\n   * await object.unPin();\n   * </pre>\n   *\n   * @returns {Promise} A promise that is fulfilled when the unPin completes.\n   */\n  unPin() {\n    return ParseObject.unPinAllWithName(_LocalDatastoreUtils.DEFAULT_PIN, [this]);\n  }\n\n  /**\n   * Asynchronously returns if the object is pinned\n   *\n   * <pre>\n   * const isPinned = await object.isPinned();\n   * </pre>\n   *\n   * @returns {Promise<boolean>} A boolean promise that is fulfilled if object is pinned.\n   */\n  async isPinned() {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    if (!localDatastore.isEnabled) {\n      return _promise.default.reject('Parse.enableLocalDatastore() must be called first');\n    }\n    const objectKey = localDatastore.getKeyForObject(this);\n    const pin = await localDatastore.fromPinWithName(objectKey);\n    return pin.length > 0;\n  }\n\n  /**\n   * Asynchronously stores the objects and every object they point to in the local datastore, recursively.\n   *\n   * If those other objects have not been fetched from Parse, they will not be stored.\n   * However, if they have changed data, all the changes will be retained.\n   *\n   * <pre>\n   * await object.pinWithName(name);\n   * </pre>\n   *\n   * To retrieve object:\n   * <code>query.fromLocalDatastore()</code> or <code>query.fromPinWithName(name)</code>\n   *\n   * @param {string} name Name of Pin.\n   * @returns {Promise} A promise that is fulfilled when the pin completes.\n   */\n  pinWithName(name) {\n    return ParseObject.pinAllWithName(name, [this]);\n  }\n\n  /**\n   * Asynchronously removes the object and every object it points to in the local datastore, recursively.\n   *\n   * <pre>\n   * await object.unPinWithName(name);\n   * </pre>\n   *\n   * @param {string} name Name of Pin.\n   * @returns {Promise} A promise that is fulfilled when the unPin completes.\n   */\n  unPinWithName(name) {\n    return ParseObject.unPinAllWithName(name, [this]);\n  }\n\n  /**\n   * Asynchronously loads data from the local datastore into this object.\n   *\n   * <pre>\n   * await object.fetchFromLocalDatastore();\n   * </pre>\n   *\n   * You can create an unfetched pointer with <code>Parse.Object.createWithoutData()</code>\n   * and then call <code>fetchFromLocalDatastore()</code> on it.\n   *\n   * @returns {Promise} A promise that is fulfilled when the fetch completes.\n   */\n  async fetchFromLocalDatastore() {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    if (!localDatastore.isEnabled) {\n      throw new Error('Parse.enableLocalDatastore() must be called first');\n    }\n    const objectKey = localDatastore.getKeyForObject(this);\n    const pinned = await localDatastore._serializeObject(objectKey);\n    if (!pinned) {\n      throw new Error('Cannot fetch an unsaved ParseObject');\n    }\n    const result = ParseObject.fromJSON(pinned);\n    this._finishFetch(result.toJSON());\n    return this;\n  }\n\n  /* Static methods */\n\n  static _clearAllState() {\n    const stateController = _CoreManager.default.getObjectStateController();\n    stateController.clearAllState();\n  }\n\n  /**\n   * Fetches the given list of Parse.Object.\n   * If any error is encountered, stops and calls the error handler.\n   *\n   * <pre>\n   *   Parse.Object.fetchAll([object1, object2, ...])\n   *    .then((list) => {\n   *      // All the objects were fetched.\n   *    }, (error) => {\n   *      // An error occurred while fetching one of the objects.\n   *    });\n   * </pre>\n   *\n   * @param {Array} list A list of <code>Parse.Object</code>.\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>include: The name(s) of the key(s) to include. Can be a string, an array of strings,\n   *       or an array of array of strings.\n   * </ul>\n   * @static\n   * @returns {Parse.Object[]}\n   */\n  static fetchAll(list, options) {\n    const fetchOptions = ParseObject._getRequestOptions(options);\n    return _CoreManager.default.getObjectController().fetch(list, true, fetchOptions);\n  }\n\n  /**\n   * Fetches the given list of Parse.Object.\n   *\n   * Includes nested Parse.Objects for the provided key. You can use dot\n   * notation to specify which fields in the included object are also fetched.\n   *\n   * If any error is encountered, stops and calls the error handler.\n   *\n   * <pre>\n   *   Parse.Object.fetchAllWithInclude([object1, object2, ...], [pointer1, pointer2, ...])\n   *    .then((list) => {\n   *      // All the objects were fetched.\n   *    }, (error) => {\n   *      // An error occurred while fetching one of the objects.\n   *    });\n   * </pre>\n   *\n   * @param {Array} list A list of <code>Parse.Object</code>.\n   * @param {string | Array<string | Array<string>>} keys The name(s) of the key(s) to include.\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @static\n   * @returns {Parse.Object[]}\n   */\n  static fetchAllWithInclude(list, keys, options) {\n    options = options || {};\n    options.include = keys;\n    return ParseObject.fetchAll(list, options);\n  }\n\n  /**\n   * Fetches the given list of Parse.Object if needed.\n   * If any error is encountered, stops and calls the error handler.\n   *\n   * Includes nested Parse.Objects for the provided key. You can use dot\n   * notation to specify which fields in the included object are also fetched.\n   *\n   * If any error is encountered, stops and calls the error handler.\n   *\n   * <pre>\n   *   Parse.Object.fetchAllIfNeededWithInclude([object1, object2, ...], [pointer1, pointer2, ...])\n   *    .then((list) => {\n   *      // All the objects were fetched.\n   *    }, (error) => {\n   *      // An error occurred while fetching one of the objects.\n   *    });\n   * </pre>\n   *\n   * @param {Array} list A list of <code>Parse.Object</code>.\n   * @param {string | Array<string | Array<string>>} keys The name(s) of the key(s) to include.\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @static\n   * @returns {Parse.Object[]}\n   */\n  static fetchAllIfNeededWithInclude(list, keys, options) {\n    options = options || {};\n    options.include = keys;\n    return ParseObject.fetchAllIfNeeded(list, options);\n  }\n\n  /**\n   * Fetches the given list of Parse.Object if needed.\n   * If any error is encountered, stops and calls the error handler.\n   *\n   * <pre>\n   *   Parse.Object.fetchAllIfNeeded([object1, ...])\n   *    .then((list) => {\n   *      // Objects were fetched and updated.\n   *    }, (error) => {\n   *      // An error occurred while fetching one of the objects.\n   *    });\n   * </pre>\n   *\n   * @param {Array} list A list of <code>Parse.Object</code>.\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>include: The name(s) of the key(s) to include. Can be a string, an array of strings,\n   *       or an array of array of strings.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n   * </ul>\n   * @static\n   * @returns {Parse.Object[]}\n   */\n  static fetchAllIfNeeded(list, options) {\n    const fetchOptions = ParseObject._getRequestOptions(options);\n    return _CoreManager.default.getObjectController().fetch(list, false, fetchOptions);\n  }\n  static handleIncludeOptions(options) {\n    let include = [];\n    if ((0, _isArray.default)(options.include)) {\n      var _context;\n      (0, _forEach.default)(_context = options.include).call(_context, key => {\n        if ((0, _isArray.default)(key)) {\n          include = (0, _concat.default)(include).call(include, key);\n        } else {\n          include.push(key);\n        }\n      });\n    } else {\n      include.push(options.include);\n    }\n    return include;\n  }\n\n  /**\n   * Destroy the given list of models on the server if it was already persisted.\n   *\n   * <p>Unlike saveAll, if an error occurs while deleting an individual model,\n   * this method will continue trying to delete the rest of the models if\n   * possible, except in the case of a fatal error like a connection error.\n   *\n   * <p>In particular, the Parse.Error object returned in the case of error may\n   * be one of two types:\n   *\n   * <ul>\n   * <li>A Parse.Error.AGGREGATE_ERROR. This object's \"errors\" property is an\n   * array of other Parse.Error objects. Each error object in this array\n   * has an \"object\" property that references the object that could not be\n   * deleted (for instance, because that object could not be found).</li>\n   * <li>A non-aggregate Parse.Error. This indicates a serious error that\n   * caused the delete operation to be aborted partway through (for\n   * instance, a connection failure in the middle of the delete).</li>\n   * </ul>\n   *\n   * <pre>\n   * Parse.Object.destroyAll([object1, object2, ...])\n   * .then((list) => {\n   * // All the objects were deleted.\n   * }, (error) => {\n   * // An error occurred while deleting one or more of the objects.\n   * // If this is an aggregate error, then we can inspect each error\n   * // object individually to determine the reason why a particular\n   * // object was not deleted.\n   * if (error.code === Parse.Error.AGGREGATE_ERROR) {\n   * for (var i = 0; i < error.errors.length; i++) {\n   * console.log(\"Couldn't delete \" + error.errors[i].object.id +\n   * \"due to \" + error.errors[i].message);\n   * }\n   * } else {\n   * console.log(\"Delete aborted because of \" + error.message);\n   * }\n   * });\n   * </pre>\n   *\n   * @param {Array} list A list of <code>Parse.Object</code>.\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeDelete` and `afterDelete` triggers.\n   *   <li>transaction: Set to true to enable transactions\n   *   <li>batchSize: How many objects to yield in each batch (default: 20)\n   * </ul>\n   * @static\n   * @returns {Promise} A promise that is fulfilled when the destroyAll\n   * completes.\n   */\n  static destroyAll(list, options) {\n    const destroyOptions = ParseObject._getRequestOptions(options);\n    return _CoreManager.default.getObjectController().destroy(list, destroyOptions);\n  }\n\n  /**\n   * Saves the given list of Parse.Object.\n   * If any error is encountered, stops and calls the error handler.\n   *\n   * <pre>\n   * Parse.Object.saveAll([object1, object2, ...])\n   * .then((list) => {\n   * // All the objects were saved.\n   * }, (error) => {\n   * // An error occurred while saving one of the objects.\n   * });\n   * </pre>\n   *\n   * @param {Array} list A list of <code>Parse.Object</code>.\n   * @param {object} options\n   * Valid options are:\n   * <ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *        be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>cascadeSave: If `false`, nested objects will not be saved (default is `true`).\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeSave` and `afterSave` triggers.\n   *   <li>transaction: Set to true to enable transactions\n   *   <li>batchSize: How many objects to yield in each batch (default: 20)\n   * </ul>\n   * @static\n   * @returns {Parse.Object[]}\n   */\n  static saveAll(list, options) {\n    const saveOptions = ParseObject._getRequestOptions(options);\n    return _CoreManager.default.getObjectController().save(list, saveOptions);\n  }\n\n  /**\n   * Creates a reference to a subclass of Parse.Object with the given id. This\n   * does not exist on Parse.Object, only on subclasses.\n   *\n   * <p>A shortcut for: <pre>\n   *  var Foo = Parse.Object.extend(\"Foo\");\n   *  var pointerToFoo = new Foo();\n   *  pointerToFoo.id = \"myObjectId\";\n   * </pre>\n   *\n   * @param {string} id The ID of the object to create a reference to.\n   * @static\n   * @returns {Parse.Object} A Parse.Object reference.\n   */\n  static createWithoutData(id) {\n    const obj = new this();\n    obj.id = id;\n    return obj;\n  }\n\n  /**\n   * Creates a new instance of a Parse Object from a JSON representation.\n   *\n   * @param {object} json The JSON map of the Object's data\n   * @param {boolean} override In single instance mode, all old server data\n   *   is overwritten if this is set to true\n   * @param {boolean} dirty Whether the Parse.Object should set JSON keys to dirty\n   * @static\n   * @returns {Parse.Object} A Parse.Object reference\n   */\n  static fromJSON(json, override, dirty) {\n    if (!json.className) {\n      throw new Error('Cannot create an object without a className');\n    }\n    const constructor = classMap[json.className];\n    const o = constructor ? new constructor(json.className) : new ParseObject(json.className);\n    const otherAttributes = {};\n    for (const attr in json) {\n      if (attr !== 'className' && attr !== '__type') {\n        otherAttributes[attr] = json[attr];\n        if (dirty) {\n          o.set(attr, json[attr]);\n        }\n      }\n    }\n    if (override) {\n      // id needs to be set before clearServerData can work\n      if (otherAttributes.objectId) {\n        o.id = otherAttributes.objectId;\n      }\n      let preserved = null;\n      if (typeof o._preserveFieldsOnFetch === 'function') {\n        preserved = o._preserveFieldsOnFetch();\n      }\n      o._clearServerData();\n      if (preserved) {\n        o._finishFetch(preserved);\n      }\n    }\n    o._finishFetch(otherAttributes);\n    if (json.objectId) {\n      o._setExisted(true);\n    }\n    return o;\n  }\n\n  /**\n   * Registers a subclass of Parse.Object with a specific class name.\n   * When objects of that class are retrieved from a query, they will be\n   * instantiated with this subclass.\n   * This is only necessary when using ES6 subclassing.\n   *\n   * @param {string} className The class name of the subclass\n   * @param {Function} constructor The subclass\n   */\n  static registerSubclass(className, constructor) {\n    if (typeof className !== 'string') {\n      throw new TypeError('The first argument must be a valid class name.');\n    }\n    if (typeof constructor === 'undefined') {\n      throw new TypeError('You must supply a subclass constructor.');\n    }\n    if (typeof constructor !== 'function') {\n      throw new TypeError('You must register the subclass constructor. ' + 'Did you attempt to register an instance of the subclass?');\n    }\n    classMap[className] = constructor;\n    if (!constructor.className) {\n      constructor.className = className;\n    }\n  }\n\n  /**\n   * Unegisters a subclass of Parse.Object with a specific class name.\n   *\n   * @param {string} className The class name of the subclass\n   */\n  static unregisterSubclass(className) {\n    if (typeof className !== 'string') {\n      throw new TypeError('The first argument must be a valid class name.');\n    }\n    delete classMap[className];\n  }\n\n  /**\n   * Creates a new subclass of Parse.Object for the given Parse class name.\n   *\n   * <p>Every extension of a Parse class will inherit from the most recent\n   * previous extension of that class. When a Parse.Object is automatically\n   * created by parsing JSON, it will use the most recent extension of that\n   * class.</p>\n   *\n   * <p>You should call either:<pre>\n   *     var MyClass = Parse.Object.extend(\"MyClass\", {\n   *         <i>Instance methods</i>,\n   *         initialize: function(attrs, options) {\n   *             this.someInstanceProperty = [],\n   *             <i>Other instance properties</i>\n   *         }\n   *     }, {\n   *         <i>Class properties</i>\n   *     });</pre>\n   * or, for Backbone compatibility:<pre>\n   *     var MyClass = Parse.Object.extend({\n   *         className: \"MyClass\",\n   *         <i>Instance methods</i>,\n   *         initialize: function(attrs, options) {\n   *             this.someInstanceProperty = [],\n   *             <i>Other instance properties</i>\n   *         }\n   *     }, {\n   *         <i>Class properties</i>\n   *     });</pre></p>\n   *\n   * @param {string} className The name of the Parse class backing this model.\n   * @param {object} [protoProps] Instance properties to add to instances of the\n   *     class returned from this method.\n   * @param {object} [classProps] Class properties to add the class returned from\n   *     this method.\n   * @returns {Parse.Object} A new subclass of Parse.Object.\n   */\n  static extend(className, protoProps, classProps) {\n    if (typeof className !== 'string') {\n      if (className && typeof className.className === 'string') {\n        return ParseObject.extend(className.className, className, protoProps);\n      } else {\n        throw new Error(\"Parse.Object.extend's first argument should be the className.\");\n      }\n    }\n    let adjustedClassName = className;\n    if (adjustedClassName === 'User' && _CoreManager.default.get('PERFORM_USER_REWRITE')) {\n      adjustedClassName = '_User';\n    }\n    let parentProto = ParseObject.prototype;\n    if (Object.hasOwn(this, '__super__') && this.__super__) {\n      parentProto = this.prototype;\n    }\n    let ParseObjectSubclass = function (attributes, options) {\n      this.className = adjustedClassName;\n      this._objCount = objectCount++;\n      // Enable legacy initializers\n      if (typeof this.initialize === 'function') {\n        this.initialize.apply(this, arguments);\n      }\n      if (this._initializers) {\n        for (const initializer of this._initializers) {\n          initializer.apply(this, arguments);\n        }\n      }\n      if (attributes && typeof attributes === 'object') {\n        try {\n          this.set(attributes || {}, options);\n        } catch (_) {\n          throw new Error(\"Can't create an invalid Parse Object\");\n        }\n      }\n    };\n    if (classMap[adjustedClassName]) {\n      ParseObjectSubclass = classMap[adjustedClassName];\n    } else {\n      ParseObjectSubclass.extend = function (name, protoProps, classProps) {\n        if (typeof name === 'string') {\n          return ParseObject.extend.call(ParseObjectSubclass, name, protoProps, classProps);\n        }\n        return ParseObject.extend.call(ParseObjectSubclass, adjustedClassName, name, protoProps);\n      };\n      ParseObjectSubclass.createWithoutData = ParseObject.createWithoutData;\n      ParseObjectSubclass.className = adjustedClassName;\n      ParseObjectSubclass.__super__ = parentProto;\n      ParseObjectSubclass.prototype = (0, _create.default)(parentProto, {\n        constructor: {\n          value: ParseObjectSubclass,\n          enumerable: false,\n          writable: true,\n          configurable: true\n        }\n      });\n    }\n    if (protoProps) {\n      for (const prop in protoProps) {\n        if (prop === 'initialize') {\n          (0, _defineProperty3.default)(ParseObjectSubclass.prototype, '_initializers', {\n            value: [...(ParseObjectSubclass.prototype._initializers || []), protoProps[prop]],\n            enumerable: false,\n            writable: true,\n            configurable: true\n          });\n          continue;\n        }\n        if (prop !== 'className') {\n          (0, _defineProperty3.default)(ParseObjectSubclass.prototype, prop, {\n            value: protoProps[prop],\n            enumerable: false,\n            writable: true,\n            configurable: true\n          });\n        }\n      }\n    }\n    if (classProps) {\n      for (const prop in classProps) {\n        if (prop !== 'className') {\n          (0, _defineProperty3.default)(ParseObjectSubclass, prop, {\n            value: classProps[prop],\n            enumerable: false,\n            writable: true,\n            configurable: true\n          });\n        }\n      }\n    }\n    classMap[adjustedClassName] = ParseObjectSubclass;\n    return ParseObjectSubclass;\n  }\n\n  /**\n   * Enable single instance objects, where any local objects with the same Id\n   * share the same attributes, and stay synchronized with each other.\n   * This is disabled by default in server environments, since it can lead to\n   * security issues.\n   *\n   * @static\n   */\n  static enableSingleInstance() {\n    singleInstance = true;\n    _CoreManager.default.setObjectStateController(SingleInstanceStateController);\n  }\n\n  /**\n   * Disable single instance objects, where any local objects with the same Id\n   * share the same attributes, and stay synchronized with each other.\n   * When disabled, you can have two instances of the same object in memory\n   * without them sharing attributes.\n   *\n   * @static\n   */\n  static disableSingleInstance() {\n    singleInstance = false;\n    _CoreManager.default.setObjectStateController(UniqueInstanceStateController);\n  }\n\n  /**\n   * Asynchronously stores the objects and every object they point to in the local datastore,\n   * recursively, using a default pin name: _default.\n   *\n   * If those other objects have not been fetched from Parse, they will not be stored.\n   * However, if they have changed data, all the changes will be retained.\n   *\n   * <pre>\n   * await Parse.Object.pinAll([...]);\n   * </pre>\n   *\n   * To retrieve object:\n   * <code>query.fromLocalDatastore()</code> or <code>query.fromPin()</code>\n   *\n   * @param {Array} objects A list of <code>Parse.Object</code>.\n   * @returns {Promise} A promise that is fulfilled when the pin completes.\n   * @static\n   */\n  static pinAll(objects) {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    if (!localDatastore.isEnabled) {\n      return _promise.default.reject('Parse.enableLocalDatastore() must be called first');\n    }\n    return ParseObject.pinAllWithName(_LocalDatastoreUtils.DEFAULT_PIN, objects);\n  }\n\n  /**\n   * Asynchronously stores the objects and every object they point to in the local datastore, recursively.\n   *\n   * If those other objects have not been fetched from Parse, they will not be stored.\n   * However, if they have changed data, all the changes will be retained.\n   *\n   * <pre>\n   * await Parse.Object.pinAllWithName(name, [obj1, obj2, ...]);\n   * </pre>\n   *\n   * To retrieve object:\n   * <code>query.fromLocalDatastore()</code> or <code>query.fromPinWithName(name)</code>\n   *\n   * @param {string} name Name of Pin.\n   * @param {Array} objects A list of <code>Parse.Object</code>.\n   * @returns {Promise} A promise that is fulfilled when the pin completes.\n   * @static\n   */\n  static pinAllWithName(name, objects) {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    if (!localDatastore.isEnabled) {\n      return _promise.default.reject('Parse.enableLocalDatastore() must be called first');\n    }\n    return localDatastore._handlePinAllWithName(name, objects);\n  }\n\n  /**\n   * Asynchronously removes the objects and every object they point to in the local datastore,\n   * recursively, using a default pin name: _default.\n   *\n   * <pre>\n   * await Parse.Object.unPinAll([...]);\n   * </pre>\n   *\n   * @param {Array} objects A list of <code>Parse.Object</code>.\n   * @returns {Promise} A promise that is fulfilled when the unPin completes.\n   * @static\n   */\n  static unPinAll(objects) {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    if (!localDatastore.isEnabled) {\n      return _promise.default.reject('Parse.enableLocalDatastore() must be called first');\n    }\n    return ParseObject.unPinAllWithName(_LocalDatastoreUtils.DEFAULT_PIN, objects);\n  }\n\n  /**\n   * Asynchronously removes the objects and every object they point to in the local datastore, recursively.\n   *\n   * <pre>\n   * await Parse.Object.unPinAllWithName(name, [obj1, obj2, ...]);\n   * </pre>\n   *\n   * @param {string} name Name of Pin.\n   * @param {Array} objects A list of <code>Parse.Object</code>.\n   * @returns {Promise} A promise that is fulfilled when the unPin completes.\n   * @static\n   */\n  static unPinAllWithName(name, objects) {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    if (!localDatastore.isEnabled) {\n      return _promise.default.reject('Parse.enableLocalDatastore() must be called first');\n    }\n    return localDatastore._handleUnPinAllWithName(name, objects);\n  }\n\n  /**\n   * Asynchronously removes all objects in the local datastore using a default pin name: _default.\n   *\n   * <pre>\n   * await Parse.Object.unPinAllObjects();\n   * </pre>\n   *\n   * @returns {Promise} A promise that is fulfilled when the unPin completes.\n   * @static\n   */\n  static unPinAllObjects() {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    if (!localDatastore.isEnabled) {\n      return _promise.default.reject('Parse.enableLocalDatastore() must be called first');\n    }\n    return localDatastore.unPinWithName(_LocalDatastoreUtils.DEFAULT_PIN);\n  }\n\n  /**\n   * Asynchronously removes all objects with the specified pin name.\n   * Deletes the pin name also.\n   *\n   * <pre>\n   * await Parse.Object.unPinAllObjectsWithName(name);\n   * </pre>\n   *\n   * @param {string} name Name of Pin.\n   * @returns {Promise} A promise that is fulfilled when the unPin completes.\n   * @static\n   */\n  static unPinAllObjectsWithName(name) {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    if (!localDatastore.isEnabled) {\n      return _promise.default.reject('Parse.enableLocalDatastore() must be called first');\n    }\n    return localDatastore.unPinWithName(_LocalDatastoreUtils.PIN_PREFIX + name);\n  }\n}\nconst DefaultController = {\n  fetch(target, forceFetch, options) {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    if ((0, _isArray.default)(target)) {\n      if (target.length < 1) {\n        return _promise.default.resolve([]);\n      }\n      const objs = [];\n      const ids = [];\n      let className = null;\n      const results = [];\n      let error = null;\n      (0, _forEach.default)(target).call(target, el => {\n        if (error) {\n          return;\n        }\n        if (!className) {\n          className = el.className;\n        }\n        if (className !== el.className) {\n          error = new _ParseError.default(_ParseError.default.INVALID_CLASS_NAME, 'All objects should be of the same class');\n        }\n        if (!el.id) {\n          error = new _ParseError.default(_ParseError.default.MISSING_OBJECT_ID, 'All objects must have an ID');\n        }\n        if (forceFetch || !el.isDataAvailable()) {\n          ids.push(el.id);\n          objs.push(el);\n        }\n        results.push(el);\n      });\n      if (error) {\n        return _promise.default.reject(error);\n      }\n      const ParseQuery = _CoreManager.default.getParseQuery();\n      const query = new ParseQuery(className);\n      query.containedIn('objectId', ids);\n      if (options && options.include) {\n        query.include(options.include);\n      }\n      query._limit = ids.length;\n      return (0, _find.default)(query).call(query, options).then(async objects => {\n        const idMap = {};\n        (0, _forEach.default)(objects).call(objects, o => {\n          idMap[o.id] = o;\n        });\n        for (let i = 0; i < objs.length; i++) {\n          const obj = objs[i];\n          if (!obj || !obj.id || !idMap[obj.id]) {\n            if (forceFetch) {\n              return _promise.default.reject(new _ParseError.default(_ParseError.default.OBJECT_NOT_FOUND, 'All objects must exist on the server.'));\n            }\n          }\n        }\n        if (!singleInstance) {\n          // If single instance objects are disabled, we need to replace the\n          for (let i = 0; i < results.length; i++) {\n            const obj = results[i];\n            if (obj && obj.id && idMap[obj.id]) {\n              const id = obj.id;\n              obj._finishFetch(idMap[id].toJSON());\n              results[i] = idMap[id];\n            }\n          }\n        }\n        for (const object of results) {\n          await localDatastore._updateObjectIfPinned(object);\n        }\n        return _promise.default.resolve(results);\n      });\n    } else if (target instanceof ParseObject) {\n      if (!target.id) {\n        return _promise.default.reject(new _ParseError.default(_ParseError.default.MISSING_OBJECT_ID, 'Object does not have an ID'));\n      }\n      const RESTController = _CoreManager.default.getRESTController();\n      const params = {};\n      if (options && options.include) {\n        params.include = options.include.join();\n      }\n      return RESTController.request('GET', 'classes/' + target.className + '/' + target._getId(), params, options).then(async response => {\n        target._clearPendingOps();\n        target._clearServerData();\n        target._finishFetch(response);\n        await localDatastore._updateObjectIfPinned(target);\n        return target;\n      });\n    }\n    return _promise.default.resolve(undefined);\n  },\n  async destroy(target, options) {\n    if (options && options.batchSize && options.transaction) throw new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'You cannot use both transaction and batchSize options simultaneously.');\n    let batchSize = options && options.batchSize ? options.batchSize : _CoreManager.default.get('REQUEST_BATCH_SIZE');\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    const RESTController = _CoreManager.default.getRESTController();\n    if ((0, _isArray.default)(target)) {\n      if (options && options.transaction && target.length > 1) batchSize = target.length;\n      if (target.length < 1) {\n        return _promise.default.resolve([]);\n      }\n      const batches = [[]];\n      (0, _forEach.default)(target).call(target, obj => {\n        if (!obj.id) {\n          return;\n        }\n        batches[batches.length - 1].push(obj);\n        if (batches[batches.length - 1].length >= batchSize) {\n          batches.push([]);\n        }\n      });\n      if (batches[batches.length - 1].length === 0) {\n        // If the last batch is empty, remove it\n        batches.pop();\n      }\n      let deleteCompleted = _promise.default.resolve();\n      const errors = [];\n      (0, _forEach.default)(batches).call(batches, batch => {\n        const requests = (0, _map.default)(batch).call(batch, obj => {\n          return {\n            method: 'DELETE',\n            path: getServerUrlPath() + 'classes/' + obj.className + '/' + obj._getId(),\n            body: {}\n          };\n        });\n        const body = options && options.transaction && requests.length > 1 ? {\n          requests,\n          transaction: true\n        } : {\n          requests\n        };\n        deleteCompleted = deleteCompleted.then(() => {\n          return RESTController.request('POST', 'batch', body, options).then(results => {\n            for (let i = 0; i < results.length; i++) {\n              if (results[i] && Object.hasOwn(results[i], 'error')) {\n                const err = new _ParseError.default(results[i].error.code, results[i].error.error);\n                err.object = batch[i];\n                errors.push(err);\n              }\n            }\n          });\n        });\n      });\n      return deleteCompleted.then(async () => {\n        if (errors.length) {\n          const aggregate = new _ParseError.default(_ParseError.default.AGGREGATE_ERROR);\n          aggregate.errors = errors;\n          return _promise.default.reject(aggregate);\n        }\n        for (const object of target) {\n          await localDatastore._destroyObjectIfPinned(object);\n        }\n        return _promise.default.resolve(target);\n      });\n    } else if (target instanceof ParseObject) {\n      return RESTController.request('DELETE', 'classes/' + target.className + '/' + target._getId(), {}, options).then(async () => {\n        await localDatastore._destroyObjectIfPinned(target);\n        return _promise.default.resolve(target);\n      });\n    }\n    return _promise.default.resolve(target);\n  },\n  save(target, options) {\n    if (options && options.batchSize && options.transaction) return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'You cannot use both transaction and batchSize options simultaneously.'));\n    let batchSize = options && options.batchSize ? options.batchSize : _CoreManager.default.get('REQUEST_BATCH_SIZE');\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    const mapIdForPin = {};\n    const RESTController = _CoreManager.default.getRESTController();\n    const stateController = _CoreManager.default.getObjectStateController();\n    const allowCustomObjectId = _CoreManager.default.get('ALLOW_CUSTOM_OBJECT_ID');\n    options = options || {};\n    options.returnStatus = options.returnStatus || true;\n    if ((0, _isArray.default)(target)) {\n      if (target.length < 1) {\n        return _promise.default.resolve([]);\n      }\n      let unsaved = (0, _concat.default)(target).call(target);\n      for (let i = 0; i < target.length; i++) {\n        const target_i = target[i];\n        if (target_i instanceof ParseObject) {\n          unsaved = (0, _concat.default)(unsaved).call(unsaved, (0, _unsavedChildren.default)(target_i, true));\n        }\n      }\n      unsaved = (0, _unique.default)(unsaved);\n      const filesSaved = [];\n      let pending = [];\n      (0, _forEach.default)(unsaved).call(unsaved, el => {\n        if (el instanceof _ParseFile.default) {\n          filesSaved.push(el.save(options));\n        } else if (el instanceof ParseObject) {\n          pending.push(el);\n        }\n      });\n      if (options && options.transaction && pending.length > 1) {\n        if ((0, _some.default)(pending).call(pending, el => !(0, _canBeSerialized.default)(el))) return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Tried to save a transactional batch containing an object with unserializable attributes.'));\n        batchSize = pending.length;\n      }\n      return _promise.default.all(filesSaved).then(() => {\n        let objectError = null;\n        return (0, _promiseUtils.continueWhile)(() => {\n          return pending.length > 0;\n        }, () => {\n          const batch = [];\n          const nextPending = [];\n          (0, _forEach.default)(pending).call(pending, el => {\n            if (allowCustomObjectId && Object.hasOwn(el, 'id') && !el.id) {\n              throw new _ParseError.default(_ParseError.default.MISSING_OBJECT_ID, 'objectId must not be empty or null');\n            }\n            if (batch.length < batchSize && (0, _canBeSerialized.default)(el)) {\n              batch.push(el);\n            } else {\n              nextPending.push(el);\n            }\n          });\n          pending = nextPending;\n          if (batch.length < 1) {\n            return _promise.default.reject(new _ParseError.default(_ParseError.default.OTHER_CAUSE, 'Tried to save a batch with a cycle.'));\n          }\n\n          // Queue up tasks for each object in the batch.\n          // When every task is ready, the API request will execute\n          const batchReturned = (0, _promiseUtils.resolvingPromise)();\n          const batchReady = [];\n          const batchTasks = [];\n          (0, _forEach.default)(batch).call(batch, (obj, index) => {\n            // eslint-disable-next-line\n            const ready = (0, _promiseUtils.resolvingPromise)();\n            batchReady.push(ready);\n            stateController.pushPendingState(obj._getStateIdentifier());\n            batchTasks.push(stateController.enqueueTask(obj._getStateIdentifier(), function () {\n              ready.resolve();\n              return batchReturned.then(responses => {\n                if (Object.hasOwn(responses[index], 'success')) {\n                  const objectId = responses[index].success.objectId;\n                  const status = responses[index]._status;\n                  delete responses[index]._status;\n                  delete responses[index]._headers;\n                  mapIdForPin[objectId] = obj._localId;\n                  obj._handleSaveResponse(responses[index].success, status);\n                } else {\n                  if (!objectError && Object.hasOwn(responses[index], 'error')) {\n                    const serverError = responses[index].error;\n                    objectError = new _ParseError.default(serverError.code, serverError.error);\n                    // Cancel the rest of the save\n                    pending = [];\n                  }\n                  obj._handleSaveError();\n                }\n              });\n            }));\n          });\n          (0, _promiseUtils.when)(batchReady).then(() => {\n            // Kick off the batch request\n            const requests = (0, _map.default)(batch).call(batch, obj => {\n              const params = obj._getSaveParams();\n              params.path = getServerUrlPath() + params.path;\n              return params;\n            });\n            const body = options && options.transaction && requests.length > 1 ? {\n              requests,\n              transaction: true\n            } : {\n              requests\n            };\n            return RESTController.request('POST', 'batch', body, options);\n          }).then(batchReturned.resolve, error => {\n            batchReturned.reject(new _ParseError.default(_ParseError.default.INCORRECT_TYPE, error.message));\n          });\n          return (0, _promiseUtils.when)(batchTasks);\n        }).then(async () => {\n          if (objectError) {\n            return _promise.default.reject(objectError);\n          }\n          for (const object of target) {\n            // Make sure that it is a ParseObject before updating it into the localDataStore\n            if (object instanceof ParseObject) {\n              await localDatastore._updateLocalIdForObject(mapIdForPin[object.id], object);\n              await localDatastore._updateObjectIfPinned(object);\n            }\n          }\n          return _promise.default.resolve(target);\n        });\n      });\n    } else if (target instanceof ParseObject) {\n      if (allowCustomObjectId && Object.hasOwn(target, 'id') && !target.id) {\n        throw new _ParseError.default(_ParseError.default.MISSING_OBJECT_ID, 'objectId must not be empty or null');\n      }\n      // generate _localId in case if cascadeSave=false\n      target._getId();\n      const localId = target._localId;\n      // copying target lets guarantee the pointer isn't modified elsewhere\n      const targetCopy = target;\n      const task = function () {\n        const params = targetCopy._getSaveParams();\n        return RESTController.request(params.method, params.path, params.body, options).then(response => {\n          const status = response._status;\n          delete response._status;\n          delete response._headers;\n          targetCopy._handleSaveResponse(response, status);\n        }, error => {\n          targetCopy._handleSaveError();\n          return _promise.default.reject(error);\n        });\n      };\n      stateController.pushPendingState(target._getStateIdentifier());\n      return stateController.enqueueTask(target._getStateIdentifier(), task).then(async () => {\n        await localDatastore._updateLocalIdForObject(localId, target);\n        await localDatastore._updateObjectIfPinned(target);\n        return target;\n      }, error => {\n        return _promise.default.reject(error);\n      });\n    }\n    return _promise.default.resolve(undefined);\n  }\n};\n_CoreManager.default.setParseObject(ParseObject);\n_CoreManager.default.setObjectController(DefaultController);\nvar _default = exports.default = ParseObject;"],"mappings":"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AAO/C,YAAY,CAAClB,OAAO,CAAC8O,mBAAmB,CAAC,CAAC,CAACH,KAAK,CAACmD,IAAI,EAAE,IAAI,EAAElD,YAAY,CAAC;EACnF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,OAAOmD,mBAAmBA,CAACD,IAAI,EAAE7L,IAAI,EAAEhC,OAAO,EAAE;IAC9CA,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;IACvBA,OAAO,CAAC+F,OAAO,GAAG/D,IAAI;IACtB,OAAOpC,WAAW,CAACgO,QAAQ,CAACC,IAAI,EAAE7N,OAAO,CAAC;EAC5C;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,OAAO+N,2BAA2BA,CAACF,IAAI,EAAE7L,IAAI,EAAEhC,OAAO,EAAE;IACtDA,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;IACvBA,OAAO,CAAC+F,OAAO,GAAG/D,IAAI;IACtB,OAAOpC,WAAW,CAACoO,gBAAgB,CAACH,IAAI,EAAE7N,OAAO,CAAC;EACpD;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACE,OAAOgO,gBAAgBA,CAACH,IAAI,EAAE7N,OAAO,EAAE;IACrC,MAAM2K,YAAY,GAAG/K,WAAW,CAACwF,kBAAkB,CAACpF,OAAO,CAAC;IAC5D,OAAO/C,YAAY,CAAClB,OAAO,CAAC8O,mBAAmB,CAAC,CAAC,CAACH,KAAK,CAACmD,IAAI,EAAE,KAAK,EAAElD,YAAY,CAAC;EACpF;EACA,OAAO3E,oBAAoBA,CAAChG,OAAO,EAAE;IACnC,IAAI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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}