{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/keys\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\nconst PUBLIC_KEY = '*';\n\n/**\n * Creates a new ACL.\n * If no argument is given, the ACL has no permissions for anyone.\n * If the argument is a Parse.User, the ACL will have read and write\n *   permission for only that user.\n * If the argument is any other JSON object, that object will be interpretted\n *   as a serialized ACL created with toJSON().\n *\n * <p>An ACL, or Access Control List can be added to any\n * <code>Parse.Object</code> to restrict access to only a subset of users\n * of your application.</p>\n *\n * @alias Parse.ACL\n */\nclass ParseACL {\n  /**\n   * @param {(Parse.User | object | null)} arg1 The user to initialize the ACL for\n   */\n  constructor(arg1) {\n    (0, _defineProperty2.default)(this, \"permissionsById\", void 0);\n    this.permissionsById = {};\n    if (arg1 && typeof arg1 === 'object') {\n      const ParseUser = _CoreManager.default.getParseUser();\n      if (arg1 instanceof ParseUser) {\n        this.setReadAccess(arg1, true);\n        this.setWriteAccess(arg1, true);\n      } else {\n        for (const userId in arg1) {\n          const accessList = arg1[userId];\n          this.permissionsById[userId] = {};\n          for (const permission in accessList) {\n            const allowed = accessList[permission];\n            if (permission !== 'read' && permission !== 'write') {\n              throw new TypeError('Tried to create an ACL with an invalid permission type.');\n            }\n            if (typeof allowed !== 'boolean') {\n              throw new TypeError('Tried to create an ACL with an invalid permission value.');\n            }\n            this.permissionsById[userId][permission] = allowed;\n          }\n        }\n      }\n    } else if (typeof arg1 === 'function') {\n      throw new TypeError('ParseACL constructed with a function. Did you forget ()?');\n    }\n  }\n\n  /**\n   * Returns a JSON-encoded version of the ACL.\n   *\n   * @returns {object}\n   */\n  toJSON() {\n    const permissions = {};\n    for (const p in this.permissionsById) {\n      permissions[p] = this.permissionsById[p];\n    }\n    return permissions;\n  }\n\n  /**\n   * Returns whether this ACL is equal to another object\n   *\n   * @param {ParseACL} other The other object's ACL to compare to\n   * @returns {boolean}\n   */\n  equals(other) {\n    if (!(other instanceof ParseACL)) {\n      return false;\n    }\n    const users = (0, _keys.default)(this.permissionsById);\n    const otherUsers = (0, _keys.default)(other.permissionsById);\n    if (users.length !== otherUsers.length) {\n      return false;\n    }\n    for (const u in this.permissionsById) {\n      if (!other.permissionsById[u]) {\n        return false;\n      }\n      if (this.permissionsById[u].read !== other.permissionsById[u].read) {\n        return false;\n      }\n      if (this.permissionsById[u].write !== other.permissionsById[u].write) {\n        return false;\n      }\n    }\n    return true;\n  }\n  _setAccess(accessType, userId, allowed) {\n    const ParseRole = _CoreManager.default.getParseRole();\n    const ParseUser = _CoreManager.default.getParseUser();\n    if (userId instanceof ParseUser) {\n      userId = userId.id;\n    } else if (userId instanceof ParseRole) {\n      const name = userId.getName();\n      if (!name) {\n        throw new TypeError('Role must have a name');\n      }\n      userId = 'role:' + name;\n    }\n    if (typeof userId !== 'string') {\n      throw new TypeError('userId must be a string.');\n    }\n    if (typeof allowed !== 'boolean') {\n      throw new TypeError('allowed must be either true or false.');\n    }\n    let permissions = this.permissionsById[userId];\n    if (!permissions) {\n      if (!allowed) {\n        // The user already doesn't have this permission, so no action is needed\n        return;\n      } else {\n        permissions = {};\n        this.permissionsById[userId] = permissions;\n      }\n    }\n    if (allowed) {\n      this.permissionsById[userId][accessType] = true;\n    } else {\n      delete permissions[accessType];\n      if ((0, _keys.default)(permissions).length === 0) {\n        delete this.permissionsById[userId];\n      }\n    }\n  }\n  _getAccess(accessType, userId) {\n    const ParseRole = _CoreManager.default.getParseRole();\n    const ParseUser = _CoreManager.default.getParseUser();\n    if (userId instanceof ParseUser) {\n      userId = userId.id;\n      if (!userId) {\n        throw new Error('Cannot get access for a ParseUser without an ID');\n      }\n    } else if (userId instanceof ParseRole) {\n      const name = userId.getName();\n      if (!name) {\n        throw new TypeError('Role must have a name');\n      }\n      userId = 'role:' + name;\n    }\n    const permissions = this.permissionsById[userId];\n    if (!permissions) {\n      return false;\n    }\n    return !!permissions[accessType];\n  }\n\n  /**\n   * Sets whether the given user is allowed to read this object.\n   *\n   * @param userId An instance of Parse.User or its objectId.\n   * @param {boolean} allowed Whether that user should have read access.\n   */\n  setReadAccess(userId, allowed) {\n    this._setAccess('read', userId, allowed);\n  }\n\n  /**\n   * Get whether the given user id is *explicitly* allowed to read this object.\n   * Even if this returns false, the user may still be able to access it if\n   * getPublicReadAccess returns true or a role that the user belongs to has\n   * write access.\n   *\n   * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n   * @returns {boolean}\n   */\n  getReadAccess(userId) {\n    return this._getAccess('read', userId);\n  }\n\n  /**\n   * Sets whether the given user id is allowed to write this object.\n   *\n   * @param userId An instance of Parse.User or its objectId, or a Parse.Role..\n   * @param {boolean} allowed Whether that user should have write access.\n   */\n  setWriteAccess(userId, allowed) {\n    this._setAccess('write', userId, allowed);\n  }\n\n  /**\n   * Gets whether the given user id is *explicitly* allowed to write this object.\n   * Even if this returns false, the user may still be able to write it if\n   * getPublicWriteAccess returns true or a role that the user belongs to has\n   * write access.\n   *\n   * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n   * @returns {boolean}\n   */\n  getWriteAccess(userId) {\n    return this._getAccess('write', userId);\n  }\n\n  /**\n   * Sets whether the public is allowed to read this object.\n   *\n   * @param {boolean} allowed\n   */\n  setPublicReadAccess(allowed) {\n    this.setReadAccess(PUBLIC_KEY, allowed);\n  }\n\n  /**\n   * Gets whether the public is allowed to read this object.\n   *\n   * @returns {boolean}\n   */\n  getPublicReadAccess() {\n    return this.getReadAccess(PUBLIC_KEY);\n  }\n\n  /**\n   * Sets whether the public is allowed to write this object.\n   *\n   * @param {boolean} allowed\n   */\n  setPublicWriteAccess(allowed) {\n    this.setWriteAccess(PUBLIC_KEY, allowed);\n  }\n\n  /**\n   * Gets whether the public is allowed to write this object.\n   *\n   * @returns {boolean}\n   */\n  getPublicWriteAccess() {\n    return this.getWriteAccess(PUBLIC_KEY);\n  }\n\n  /**\n   * Gets whether users belonging to the given role are allowed\n   * to read this object. Even if this returns false, the role may\n   * still be able to write it if a parent role has read access.\n   *\n   * @param role The name of the role, or a Parse.Role object.\n   * @returns {boolean} true if the role has read access. false otherwise.\n   * @throws {TypeError} If role is neither a Parse.Role nor a String.\n   */\n  getRoleReadAccess(role) {\n    const ParseRole = _CoreManager.default.getParseRole();\n    if (role instanceof ParseRole) {\n      // Normalize to the String name\n      role = role.getName();\n    }\n    if (typeof role !== 'string') {\n      throw new TypeError('role must be a ParseRole or a String');\n    }\n    return this.getReadAccess('role:' + role);\n  }\n\n  /**\n   * Gets whether users belonging to the given role are allowed\n   * to write this object. Even if this returns false, the role may\n   * still be able to write it if a parent role has write access.\n   *\n   * @param role The name of the role, or a Parse.Role object.\n   * @returns {boolean} true if the role has write access. false otherwise.\n   * @throws {TypeError} If role is neither a Parse.Role nor a String.\n   */\n  getRoleWriteAccess(role) {\n    const ParseRole = _CoreManager.default.getParseRole();\n    if (role instanceof ParseRole) {\n      // Normalize to the String name\n      role = role.getName();\n    }\n    if (typeof role !== 'string') {\n      throw new TypeError('role must be a ParseRole or a String');\n    }\n    return this.getWriteAccess('role:' + role);\n  }\n\n  /**\n   * Sets whether users belonging to the given role are allowed\n   * to read this object.\n   *\n   * @param role The name of the role, or a Parse.Role object.\n   * @param {boolean} allowed Whether the given role can read this object.\n   * @throws {TypeError} If role is neither a Parse.Role nor a String.\n   */\n  setRoleReadAccess(role, allowed) {\n    const ParseRole = _CoreManager.default.getParseRole();\n    if (role instanceof ParseRole) {\n      // Normalize to the String name\n      role = role.getName();\n    }\n    if (typeof role !== 'string') {\n      throw new TypeError('role must be a ParseRole or a String');\n    }\n    this.setReadAccess('role:' + role, allowed);\n  }\n\n  /**\n   * Sets whether users belonging to the given role are allowed\n   * to write this object.\n   *\n   * @param role The name of the role, or a Parse.Role object.\n   * @param {boolean} allowed Whether the given role can write this object.\n   * @throws {TypeError} If role is neither a Parse.Role nor a String.\n   */\n  setRoleWriteAccess(role, allowed) {\n    const ParseRole = _CoreManager.default.getParseRole();\n    if (role instanceof ParseRole) {\n      // Normalize to the String name\n      role = role.getName();\n    }\n    if (typeof role !== 'string') {\n      throw new TypeError('role must be a ParseRole or a String');\n    }\n    this.setWriteAccess('role:' + role, allowed);\n  }\n}\nvar _default = exports.default = ParseACL;","map":{"version":3,"names":["_Object$defineProperty","require","_interopRequireDefault","exports","value","default","_keys","_defineProperty2","_CoreManager","PUBLIC_KEY","ParseACL","constructor","arg1","permissionsById","ParseUser","getParseUser","setReadAccess","setWriteAccess","userId","accessList","permission","allowed","TypeError","toJSON","permissions","p","equals","other","users","otherUsers","length","u","read","write","_setAccess","accessType","ParseRole","getParseRole","id","name","getName","_getAccess","Error","getReadAccess","getWriteAccess","setPublicReadAccess","getPublicReadAccess","setPublicWriteAccess","getPublicWriteAccess","getRoleReadAccess","role","getRoleWriteAccess","setRoleReadAccess","setRoleWriteAccess","_default"],"sources":["/home/snx/Desktop/CS_School/node_modules/parse/lib/browser/ParseACL.js"],"sourcesContent":["\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/keys\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\nconst PUBLIC_KEY = '*';\n\n/**\n * Creates a new ACL.\n * If no argument is given, the ACL has no permissions for anyone.\n * If the argument is a Parse.User, the ACL will have read and write\n *   permission for only that user.\n * If the argument is any other JSON object, that object will be interpretted\n *   as a serialized ACL created with toJSON().\n *\n * <p>An ACL, or Access Control List can be added to any\n * <code>Parse.Object</code> to restrict access to only a subset of users\n * of your application.</p>\n *\n * @alias Parse.ACL\n */\nclass ParseACL {\n  /**\n   * @param {(Parse.User | object | null)} arg1 The user to initialize the ACL for\n   */\n  constructor(arg1) {\n    (0, _defineProperty2.default)(this, \"permissionsById\", void 0);\n    this.permissionsById = {};\n    if (arg1 && typeof arg1 === 'object') {\n      const ParseUser = _CoreManager.default.getParseUser();\n      if (arg1 instanceof ParseUser) {\n        this.setReadAccess(arg1, true);\n        this.setWriteAccess(arg1, true);\n      } else {\n        for (const userId in arg1) {\n          const accessList = arg1[userId];\n          this.permissionsById[userId] = {};\n          for (const permission in accessList) {\n            const allowed = accessList[permission];\n            if (permission !== 'read' && permission !== 'write') {\n              throw new TypeError('Tried to create an ACL with an invalid permission type.');\n            }\n            if (typeof allowed !== 'boolean') {\n              throw new TypeError('Tried to create an ACL with an invalid permission value.');\n            }\n            this.permissionsById[userId][permission] = allowed;\n          }\n        }\n      }\n    } else if (typeof arg1 === 'function') {\n      throw new TypeError('ParseACL constructed with a function. Did you forget ()?');\n    }\n  }\n\n  /**\n   * Returns a JSON-encoded version of the ACL.\n   *\n   * @returns {object}\n   */\n  toJSON() {\n    const permissions = {};\n    for (const p in this.permissionsById) {\n      permissions[p] = this.permissionsById[p];\n    }\n    return permissions;\n  }\n\n  /**\n   * Returns whether this ACL is equal to another object\n   *\n   * @param {ParseACL} other The other object's ACL to compare to\n   * @returns {boolean}\n   */\n  equals(other) {\n    if (!(other instanceof ParseACL)) {\n      return false;\n    }\n    const users = (0, _keys.default)(this.permissionsById);\n    const otherUsers = (0, _keys.default)(other.permissionsById);\n    if (users.length !== otherUsers.length) {\n      return false;\n    }\n    for (const u in this.permissionsById) {\n      if (!other.permissionsById[u]) {\n        return false;\n      }\n      if (this.permissionsById[u].read !== other.permissionsById[u].read) {\n        return false;\n      }\n      if (this.permissionsById[u].write !== other.permissionsById[u].write) {\n        return false;\n      }\n    }\n    return true;\n  }\n  _setAccess(accessType, userId, allowed) {\n    const ParseRole = _CoreManager.default.getParseRole();\n    const ParseUser = _CoreManager.default.getParseUser();\n    if (userId instanceof ParseUser) {\n      userId = userId.id;\n    } else if (userId instanceof ParseRole) {\n      const name = userId.getName();\n      if (!name) {\n        throw new TypeError('Role must have a name');\n      }\n      userId = 'role:' + name;\n    }\n    if (typeof userId !== 'string') {\n      throw new TypeError('userId must be a string.');\n    }\n    if (typeof allowed !== 'boolean') {\n      throw new TypeError('allowed must be either true or false.');\n    }\n    let permissions = this.permissionsById[userId];\n    if (!permissions) {\n      if (!allowed) {\n        // The user already doesn't have this permission, so no action is needed\n        return;\n      } else {\n        permissions = {};\n        this.permissionsById[userId] = permissions;\n      }\n    }\n    if (allowed) {\n      this.permissionsById[userId][accessType] = true;\n    } else {\n      delete permissions[accessType];\n      if ((0, _keys.default)(permissions).length === 0) {\n        delete this.permissionsById[userId];\n      }\n    }\n  }\n  _getAccess(accessType, userId) {\n    const ParseRole = _CoreManager.default.getParseRole();\n    const ParseUser = _CoreManager.default.getParseUser();\n    if (userId instanceof ParseUser) {\n      userId = userId.id;\n      if (!userId) {\n        throw new Error('Cannot get access for a ParseUser without an ID');\n      }\n    } else if (userId instanceof ParseRole) {\n      const name = userId.getName();\n      if (!name) {\n        throw new TypeError('Role must have a name');\n      }\n      userId = 'role:' + name;\n    }\n    const permissions = this.permissionsById[userId];\n    if (!permissions) {\n      return false;\n    }\n    return !!permissions[accessType];\n  }\n\n  /**\n   * Sets whether the given user is allowed to read this object.\n   *\n   * @param userId An instance of Parse.User or its objectId.\n   * @param {boolean} allowed Whether that user should have read access.\n   */\n  setReadAccess(userId, allowed) {\n    this._setAccess('read', userId, allowed);\n  }\n\n  /**\n   * Get whether the given user id is *explicitly* allowed to read this object.\n   * Even if this returns false, the user may still be able to access it if\n   * getPublicReadAccess returns true or a role that the user belongs to has\n   * write access.\n   *\n   * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n   * @returns {boolean}\n   */\n  getReadAccess(userId) {\n    return this._getAccess('read', userId);\n  }\n\n  /**\n   * Sets whether the given user id is allowed to write this object.\n   *\n   * @param userId An instance of Parse.User or its objectId, or a Parse.Role..\n   * @param {boolean} allowed Whether that user should have write access.\n   */\n  setWriteAccess(userId, allowed) {\n    this._setAccess('write', userId, allowed);\n  }\n\n  /**\n   * Gets whether the given user id is *explicitly* allowed to write this object.\n   * Even if this returns false, the user may still be able to write it if\n   * getPublicWriteAccess returns true or a role that the user belongs to has\n   * write access.\n   *\n   * @param userId An instance of Parse.User or its objectId, or a Parse.Role.\n   * @returns {boolean}\n   */\n  getWriteAccess(userId) {\n    return this._getAccess('write', userId);\n  }\n\n  /**\n   * Sets whether the public is allowed to read this object.\n   *\n   * @param {boolean} allowed\n   */\n  setPublicReadAccess(allowed) {\n    this.setReadAccess(PUBLIC_KEY, allowed);\n  }\n\n  /**\n   * Gets whether the public is allowed to read this object.\n   *\n   * @returns {boolean}\n   */\n  getPublicReadAccess() {\n    return this.getReadAccess(PUBLIC_KEY);\n  }\n\n  /**\n   * Sets whether the public is allowed to write this object.\n   *\n   * @param {boolean} allowed\n   */\n  setPublicWriteAccess(allowed) {\n    this.setWriteAccess(PUBLIC_KEY, allowed);\n  }\n\n  /**\n   * Gets whether the public is allowed to write this object.\n   *\n   * @returns {boolean}\n   */\n  getPublicWriteAccess() {\n    return this.getWriteAccess(PUBLIC_KEY);\n  }\n\n  /**\n   * Gets whether users belonging to the given role are allowed\n   * to read this object. Even if this returns false, the role may\n   * still be able to write it if a parent role has read access.\n   *\n   * @param role The name of the role, or a Parse.Role object.\n   * @returns {boolean} true if the role has read access. false otherwise.\n   * @throws {TypeError} If role is neither a Parse.Role nor a String.\n   */\n  getRoleReadAccess(role) {\n    const ParseRole = _CoreManager.default.getParseRole();\n    if (role instanceof ParseRole) {\n      // Normalize to the String name\n      role = role.getName();\n    }\n    if (typeof role !== 'string') {\n      throw new TypeError('role must be a ParseRole or a String');\n    }\n    return this.getReadAccess('role:' + role);\n  }\n\n  /**\n   * Gets whether users belonging to the given role are allowed\n   * to write this object. Even if this returns false, the role may\n   * still be able to write it if a parent role has write access.\n   *\n   * @param role The name of the role, or a Parse.Role object.\n   * @returns {boolean} true if the role has write access. false otherwise.\n   * @throws {TypeError} If role is neither a Parse.Role nor a String.\n   */\n  getRoleWriteAccess(role) {\n    const ParseRole = _CoreManager.default.getParseRole();\n    if (role instanceof ParseRole) {\n      // Normalize to the String name\n      role = role.getName();\n    }\n    if (typeof role !== 'string') {\n      throw new TypeError('role must be a ParseRole or a String');\n    }\n    return this.getWriteAccess('role:' + role);\n  }\n\n  /**\n   * Sets whether users belonging to the given role are allowed\n   * to read this object.\n   *\n   * @param role The name of the role, or a Parse.Role object.\n   * @param {boolean} allowed Whether the given role can read this object.\n   * @throws {TypeError} If role is neither a Parse.Role nor a String.\n   */\n  setRoleReadAccess(role, allowed) {\n    const ParseRole = _CoreManager.default.getParseRole();\n    if (role instanceof ParseRole) {\n      // Normalize to the String name\n      role = role.getName();\n    }\n    if (typeof role !== 'string') {\n      throw new TypeError('role must be a ParseRole or a String');\n    }\n    this.setReadAccess('role:' + role, allowed);\n  }\n\n  /**\n   * Sets whether users belonging to the given role are allowed\n   * to write this object.\n   *\n   * @param role The name of the role, or a Parse.Role object.\n   * @param {boolean} allowed Whether the given role can write this object.\n   * @throws {TypeError} If role is neither a Parse.Role nor a String.\n   */\n  setRoleWriteAccess(role, allowed) {\n    const ParseRole = _CoreManager.default.getParseRole();\n    if (role instanceof ParseRole) {\n      // Normalize to the String name\n      role = role.getName();\n    }\n    if (typeof role !== 'string') {\n      throw new TypeError('role must be a ParseRole or a String');\n    }\n    this.setWriteAccess('role:' + role, allowed);\n  }\n}\nvar _default = exports.default = ParseACL;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}