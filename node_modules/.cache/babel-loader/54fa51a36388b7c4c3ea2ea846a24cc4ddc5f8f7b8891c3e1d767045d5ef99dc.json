{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.b64Digit = b64Digit;\nexports.default = void 0;\nvar _isArray = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\"));\nvar _slice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\"));\nvar _forEach = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/for-each\"));\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/keys\"));\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/promise\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\n/* global Blob */\n\nfunction b64Digit(number) {\n  if (number < 26) {\n    return String.fromCharCode(65 + number);\n  }\n  if (number < 52) {\n    return String.fromCharCode(97 + (number - 26));\n  }\n  if (number < 62) {\n    return String.fromCharCode(48 + (number - 52));\n  }\n  if (number === 62) {\n    return '+';\n  }\n  if (number === 63) {\n    return '/';\n  }\n  throw new TypeError('Tried to encode large digit ' + number + ' in base64.');\n}\n\n/**\n * A Parse.File is a local representation of a file that is saved to the Parse\n * cloud.\n *\n * @alias Parse.File\n */\nclass ParseFile {\n  /**\n   * @param name {String} The file's name. This will be prefixed by a unique\n   *     value once the file has finished saving. The file name must begin with\n   *     an alphanumeric character, and consist of alphanumeric characters,\n   *     periods, spaces, underscores, or dashes.\n   * @param data {Array} The data for the file, as either:\n   *     1. an Array of byte value Numbers or Uint8Array.\n   *     2. an Object like { base64: \"...\" } with a base64-encoded String.\n   *     3. an Object like { uri: \"...\" } with a uri String.\n   *     4. a File object selected with a file upload control. (3) only works\n   *        in Firefox 3.6+, Safari 6.0.2+, Chrome 7+, and IE 10+.\n   *        For example:\n   * <pre>\n   * var fileUploadControl = $(\"#profilePhotoFileUpload\")[0];\n   * if (fileUploadControl.files.length > 0) {\n   *   var file = fileUploadControl.files[0];\n   *   var name = \"photo.jpg\";\n   *   var parseFile = new Parse.File(name, file);\n   *   parseFile.save().then(function() {\n   *     // The file has been saved to Parse.\n   *   }, function(error) {\n   *     // The file either could not be read, or could not be saved to Parse.\n   *   });\n   * }</pre>\n   * @param type {String} Optional Content-Type header to use for the file. If\n   *     this is omitted, the content type will be inferred from the name's\n   *     extension.\n   * @param metadata {object} Optional key value pairs to be stored with file object\n   * @param tags {object} Optional key value pairs to be stored with file object\n   */\n  constructor(name, data, type, metadata, tags) {\n    (0, _defineProperty2.default)(this, \"_name\", void 0);\n    (0, _defineProperty2.default)(this, \"_url\", void 0);\n    (0, _defineProperty2.default)(this, \"_source\", void 0);\n    (0, _defineProperty2.default)(this, \"_previousSave\", void 0);\n    (0, _defineProperty2.default)(this, \"_data\", void 0);\n    (0, _defineProperty2.default)(this, \"_requestTask\", void 0);\n    (0, _defineProperty2.default)(this, \"_metadata\", void 0);\n    (0, _defineProperty2.default)(this, \"_tags\", void 0);\n    const specifiedType = type || '';\n    this._name = name;\n    this._metadata = metadata || {};\n    this._tags = tags || {};\n    if (data !== undefined) {\n      if ((0, _isArray.default)(data) || data instanceof Uint8Array) {\n        this._data = ParseFile.encodeBase64(data);\n        this._source = {\n          format: 'base64',\n          base64: this._data,\n          type: specifiedType\n        };\n      } else if (typeof Blob !== 'undefined' && data instanceof Blob) {\n        this._source = {\n          format: 'file',\n          file: data,\n          type: specifiedType\n        };\n      } else if (data && typeof data.uri === 'string' && data.uri !== undefined) {\n        this._source = {\n          format: 'uri',\n          uri: data.uri,\n          type: specifiedType\n        };\n      } else if (data && typeof data.base64 === 'string') {\n        var _context, _context2, _context3;\n        const base64 = (0, _slice.default)(_context = data.base64.split(',')).call(_context, -1)[0];\n        const dataType = specifiedType || (0, _slice.default)(_context2 = (0, _slice.default)(_context3 = data.base64.split(';')).call(_context3, 0, 1)[0].split(':')).call(_context2, 1, 2)[0] || 'text/plain';\n        this._data = base64;\n        this._source = {\n          format: 'base64',\n          base64,\n          type: dataType\n        };\n      } else {\n        throw new TypeError('Cannot create a Parse.File with that data.');\n      }\n    }\n  }\n\n  /**\n   * Return the data for the file, downloading it if not already present.\n   * Data is present if initialized with Byte Array, Base64 or Saved with Uri.\n   * Data is cleared if saved with File object selected with a file upload control\n   *\n   * @param {object} options\n   * @param {function} [options.progress] callback for download progress\n   * <pre>\n   * const parseFile = new Parse.File(name, file);\n   * parseFile.getData({\n   *   progress: (progressValue, loaded, total) => {\n   *     if (progressValue !== null) {\n   *       // Update the UI using progressValue\n   *     }\n   *   }\n   * });\n   * </pre>\n   * @returns {Promise} Promise that is resolve with base64 data\n   */\n  async getData(options) {\n    options = options || {};\n    if (this._data) {\n      return this._data;\n    }\n    if (!this._url) {\n      throw new Error('Cannot retrieve data for unsaved ParseFile.');\n    }\n    options.requestTask = task => this._requestTask = task;\n    const controller = _CoreManager.default.getFileController();\n    const result = await controller.download(this._url, options);\n    this._data = result.base64;\n    return this._data;\n  }\n\n  /**\n   * Gets the name of the file. Before save is called, this is the filename\n   * given by the user. After save is called, that name gets prefixed with a\n   * unique identifier.\n   *\n   * @returns {string}\n   */\n  name() {\n    return this._name;\n  }\n\n  /**\n   * Gets the url of the file. It is only available after you save the file or\n   * after you get the file from a Parse.Object.\n   *\n   * @param {object} options An object to specify url options\n   * @param {boolean} [options.forceSecure] force the url to be secure\n   * @returns {string | undefined}\n   */\n  url(options) {\n    options = options || {};\n    if (!this._url) {\n      return;\n    }\n    if (options.forceSecure) {\n      return this._url.replace(/^http:\\/\\//i, 'https://');\n    } else {\n      return this._url;\n    }\n  }\n\n  /**\n   * Gets the metadata of the file.\n   *\n   * @returns {object}\n   */\n  metadata() {\n    return this._metadata;\n  }\n\n  /**\n   * Gets the tags of the file.\n   *\n   * @returns {object}\n   */\n  tags() {\n    return this._tags;\n  }\n\n  /**\n   * Saves the file to the Parse cloud.\n   *\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *     behalf of a specific user.\n   *   <li>progress: callback for upload progress. For example:\n   * <pre>\n   * let parseFile = new Parse.File(name, file);\n   * parseFile.save({\n   *   progress: (progressValue, loaded, total) => {\n   *     if (progressValue !== null) {\n   *       // Update the UI using progressValue\n   *     }\n   *   }\n   * });\n   * </pre>\n   * </ul>\n   * @returns {Promise | undefined} Promise that is resolved when the save finishes.\n   */\n  save(options) {\n    options = options || {};\n    options.requestTask = task => this._requestTask = task;\n    options.metadata = this._metadata;\n    options.tags = this._tags;\n    const controller = _CoreManager.default.getFileController();\n    if (!this._previousSave) {\n      if (this._source.format === 'file') {\n        this._previousSave = controller.saveFile(this._name, this._source, options).then(res => {\n          this._name = res.name;\n          this._url = res.url;\n          this._data = null;\n          this._requestTask = null;\n          return this;\n        });\n      } else if (this._source.format === 'uri') {\n        this._previousSave = controller.download(this._source.uri, options).then(result => {\n          if (!(result && result.base64)) {\n            return {};\n          }\n          const newSource = {\n            format: 'base64',\n            base64: result.base64,\n            type: result.contentType\n          };\n          this._data = result.base64;\n          this._requestTask = null;\n          return controller.saveBase64(this._name, newSource, options);\n        }).then(res => {\n          this._name = res.name;\n          this._url = res.url;\n          this._requestTask = null;\n          return this;\n        });\n      } else {\n        this._previousSave = controller.saveBase64(this._name, this._source, options).then(res => {\n          this._name = res.name;\n          this._url = res.url;\n          this._requestTask = null;\n          return this;\n        });\n      }\n    }\n    if (this._previousSave) {\n      return this._previousSave;\n    }\n  }\n\n  /**\n   * Aborts the request if it has already been sent.\n   */\n  cancel() {\n    if (this._requestTask && typeof this._requestTask.abort === 'function') {\n      this._requestTask._aborted = true;\n      this._requestTask.abort();\n    }\n    this._requestTask = null;\n  }\n\n  /**\n   * Deletes the file from the Parse cloud.\n   * In Cloud Code and Node only with Master Key.\n   *\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   * <pre>\n   * @returns {Promise} Promise that is resolved when the delete finishes.\n   */\n  destroy() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!this._name) {\n      throw new _ParseError.default(_ParseError.default.FILE_DELETE_UNNAMED_ERROR, 'Cannot delete an unnamed file.');\n    }\n    const destroyOptions = {\n      useMasterKey: true\n    };\n    if (Object.hasOwn(options, 'useMasterKey')) {\n      destroyOptions.useMasterKey = !!options.useMasterKey;\n    }\n    const controller = _CoreManager.default.getFileController();\n    return controller.deleteFile(this._name, destroyOptions).then(() => {\n      this._data = undefined;\n      this._requestTask = null;\n      return this;\n    });\n  }\n  toJSON() {\n    return {\n      __type: 'File',\n      name: this._name,\n      url: this._url\n    };\n  }\n  equals(other) {\n    if (this === other) {\n      return true;\n    }\n    // Unsaved Files are never equal, since they will be saved to different URLs\n    return other instanceof ParseFile && this.name() === other.name() && this.url() === other.url() && typeof this.url() !== 'undefined';\n  }\n\n  /**\n   * Sets metadata to be saved with file object. Overwrites existing metadata\n   *\n   * @param {object} metadata Key value pairs to be stored with file object\n   */\n  setMetadata(metadata) {\n    if (metadata && typeof metadata === 'object') {\n      var _context4;\n      (0, _forEach.default)(_context4 = (0, _keys.default)(metadata)).call(_context4, key => {\n        this.addMetadata(key, metadata[key]);\n      });\n    }\n  }\n\n  /**\n   * Sets metadata to be saved with file object. Adds to existing metadata.\n   *\n   * @param {string} key key to store the metadata\n   * @param {*} value metadata\n   */\n  addMetadata(key, value) {\n    if (typeof key === 'string') {\n      this._metadata[key] = value;\n    }\n  }\n\n  /**\n   * Sets tags to be saved with file object. Overwrites existing tags\n   *\n   * @param {object} tags Key value pairs to be stored with file object\n   */\n  setTags(tags) {\n    if (tags && typeof tags === 'object') {\n      var _context5;\n      (0, _forEach.default)(_context5 = (0, _keys.default)(tags)).call(_context5, key => {\n        this.addTag(key, tags[key]);\n      });\n    }\n  }\n\n  /**\n   * Sets tags to be saved with file object. Adds to existing tags.\n   *\n   * @param {string} key key to store tags\n   * @param {*} value tag\n   */\n  addTag(key, value) {\n    if (typeof key === 'string') {\n      this._tags[key] = value;\n    }\n  }\n  static fromJSON(obj) {\n    if (obj.__type !== 'File') {\n      throw new TypeError('JSON object does not represent a ParseFile');\n    }\n    const file = new ParseFile(obj.name);\n    file._url = obj.url;\n    return file;\n  }\n  static encodeBase64(bytes) {\n    const chunks = [];\n    chunks.length = Math.ceil(bytes.length / 3);\n    for (let i = 0; i < chunks.length; i++) {\n      const b1 = bytes[i * 3];\n      const b2 = bytes[i * 3 + 1] || 0;\n      const b3 = bytes[i * 3 + 2] || 0;\n      const has2 = i * 3 + 1 < bytes.length;\n      const has3 = i * 3 + 2 < bytes.length;\n      chunks[i] = [b64Digit(b1 >> 2 & 0x3f), b64Digit(b1 << 4 & 0x30 | b2 >> 4 & 0x0f), has2 ? b64Digit(b2 << 2 & 0x3c | b3 >> 6 & 0x03) : '=', has3 ? b64Digit(b3 & 0x3f) : '='].join('');\n    }\n    return chunks.join('');\n  }\n}\nconst DefaultController = {\n  saveFile: async function (name, source, options) {\n    if (source.format !== 'file') {\n      throw new Error('saveFile can only be used with File-type sources.');\n    }\n    const base64Data = await new _promise.default((res, rej) => {\n      const reader = new FileReader();\n      reader.onload = () => res(reader.result);\n      reader.onerror = error => rej(error);\n      reader.readAsDataURL(source.file);\n    });\n    // we only want the data after the comma\n    // For example: \"data:application/pdf;base64,JVBERi0xLjQKJ...\" we would only want \"JVBERi0xLjQKJ...\"\n    const [first, second] = base64Data.split(',');\n    // in the event there is no 'data:application/pdf;base64,' at the beginning of the base64 string\n    // use the entire string instead\n    const data = second ? second : first;\n    const newSource = {\n      format: 'base64',\n      base64: data,\n      type: source.type || (source.file ? source.file.type : undefined)\n    };\n    return await DefaultController.saveBase64(name, newSource, options);\n  },\n  saveBase64: function (name, source) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (source.format !== 'base64') {\n      throw new Error('saveBase64 can only be used with Base64-type sources.');\n    }\n    const data = {\n      base64: source.base64,\n      fileData: {\n        metadata: {\n          ...options.metadata\n        },\n        tags: {\n          ...options.tags\n        }\n      }\n    };\n    delete options.metadata;\n    delete options.tags;\n    if (source.type) {\n      data._ContentType = source.type;\n    }\n    return _CoreManager.default.getRESTController().request('POST', 'files/' + name, data, options);\n  },\n  download: async function (uri, options) {\n    const controller = new AbortController();\n    options.requestTask(controller);\n    const {\n      signal\n    } = controller;\n    try {\n      const response = await fetch(uri, {\n        signal\n      });\n      const reader = response.body.getReader();\n      const length = +response.headers.get('Content-Length') || 0;\n      const contentType = response.headers.get('Content-Type');\n      if (length === 0) {\n        options.progress?.(null, null, null);\n        return {\n          base64: '',\n          contentType\n        };\n      }\n      let recieved = 0;\n      const chunks = [];\n      while (true) {\n        const {\n          done,\n          value\n        } = await reader.read();\n        if (done) {\n          break;\n        }\n        chunks.push(value);\n        recieved += value?.length || 0;\n        options.progress?.(recieved / length, recieved, length);\n      }\n      const body = new Uint8Array(recieved);\n      let offset = 0;\n      for (const chunk of chunks) {\n        body.set(chunk, offset);\n        offset += chunk.length;\n      }\n      return {\n        base64: ParseFile.encodeBase64(body),\n        contentType\n      };\n    } catch (error) {\n      if (error.name === 'AbortError') {\n        return {};\n      } else {\n        throw error;\n      }\n    }\n  },\n  deleteFile: function (name, options) {\n    const headers = {\n      'X-Parse-Application-ID': _CoreManager.default.get('APPLICATION_ID')\n    };\n    if (options.useMasterKey) {\n      headers['X-Parse-Master-Key'] = _CoreManager.default.get('MASTER_KEY');\n    }\n    let url = _CoreManager.default.get('SERVER_URL');\n    if (url[url.length - 1] !== '/') {\n      url += '/';\n    }\n    url += 'files/' + name;\n    return _CoreManager.default.getRESTController().ajax('DELETE', url, '', headers).catch(response => {\n      // TODO: return JSON object in server\n      if (!response || response.toString() === 'SyntaxError: Unexpected end of JSON input') {\n        return _promise.default.resolve();\n      } else {\n        return _CoreManager.default.getRESTController().handleError(response);\n      }\n    });\n  }\n};\n_CoreManager.default.setFileController(DefaultController);\nvar _default = exports.default = ParseFile;","map":{"version":3,"names":["_Object$defineProperty","require","_interopRequireDefault","exports","value","b64Digit","default","_isArray","_slice","_forEach","_keys","_promise","_defineProperty2","_CoreManager","_ParseError","number","String","fromCharCode","TypeError","ParseFile","constructor","name","data","type","metadata","tags","specifiedType","_name","_metadata","_tags","undefined","Uint8Array","_data","encodeBase64","_source","format","base64","Blob","file","uri","_context","_context2","_context3","split","call","dataType","getData","options","_url","Error","requestTask","task","_requestTask","controller","getFileController","result","download","url","forceSecure","replace","save","_previousSave","saveFile","then","res","newSource","contentType","saveBase64","cancel","abort","_aborted","destroy","arguments","length","FILE_DELETE_UNNAMED_ERROR","destroyOptions","useMasterKey","Object","hasOwn","deleteFile","toJSON","__type","equals","other","setMetadata","_context4","key","addMetadata","setTags","_context5","addTag","fromJSON","obj","bytes","chunks","Math","ceil","i","b1","b2","b3","has2","has3","join","DefaultController","source","base64Data","rej","reader","FileReader","onload","onerror","error","readAsDataURL","first","second","fileData","_ContentType","getRESTController","request","AbortController","signal","response","fetch","body","getReader","headers","get","progress","recieved","done","read","push","offset","chunk","set","ajax","catch","toString","resolve","handleError","setFileController","_default"],"sources":["/home/snx/Desktop/CS_School/node_modules/parse/lib/browser/ParseFile.js"],"sourcesContent":["\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.b64Digit = b64Digit;\nexports.default = void 0;\nvar _isArray = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\"));\nvar _slice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\"));\nvar _forEach = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/for-each\"));\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/keys\"));\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/promise\"));\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\n/* global Blob */\n\nfunction b64Digit(number) {\n  if (number < 26) {\n    return String.fromCharCode(65 + number);\n  }\n  if (number < 52) {\n    return String.fromCharCode(97 + (number - 26));\n  }\n  if (number < 62) {\n    return String.fromCharCode(48 + (number - 52));\n  }\n  if (number === 62) {\n    return '+';\n  }\n  if (number === 63) {\n    return '/';\n  }\n  throw new TypeError('Tried to encode large digit ' + number + ' in base64.');\n}\n\n/**\n * A Parse.File is a local representation of a file that is saved to the Parse\n * cloud.\n *\n * @alias Parse.File\n */\nclass ParseFile {\n  /**\n   * @param name {String} The file's name. This will be prefixed by a unique\n   *     value once the file has finished saving. The file name must begin with\n   *     an alphanumeric character, and consist of alphanumeric characters,\n   *     periods, spaces, underscores, or dashes.\n   * @param data {Array} The data for the file, as either:\n   *     1. an Array of byte value Numbers or Uint8Array.\n   *     2. an Object like { base64: \"...\" } with a base64-encoded String.\n   *     3. an Object like { uri: \"...\" } with a uri String.\n   *     4. a File object selected with a file upload control. (3) only works\n   *        in Firefox 3.6+, Safari 6.0.2+, Chrome 7+, and IE 10+.\n   *        For example:\n   * <pre>\n   * var fileUploadControl = $(\"#profilePhotoFileUpload\")[0];\n   * if (fileUploadControl.files.length > 0) {\n   *   var file = fileUploadControl.files[0];\n   *   var name = \"photo.jpg\";\n   *   var parseFile = new Parse.File(name, file);\n   *   parseFile.save().then(function() {\n   *     // The file has been saved to Parse.\n   *   }, function(error) {\n   *     // The file either could not be read, or could not be saved to Parse.\n   *   });\n   * }</pre>\n   * @param type {String} Optional Content-Type header to use for the file. If\n   *     this is omitted, the content type will be inferred from the name's\n   *     extension.\n   * @param metadata {object} Optional key value pairs to be stored with file object\n   * @param tags {object} Optional key value pairs to be stored with file object\n   */\n  constructor(name, data, type, metadata, tags) {\n    (0, _defineProperty2.default)(this, \"_name\", void 0);\n    (0, _defineProperty2.default)(this, \"_url\", void 0);\n    (0, _defineProperty2.default)(this, \"_source\", void 0);\n    (0, _defineProperty2.default)(this, \"_previousSave\", void 0);\n    (0, _defineProperty2.default)(this, \"_data\", void 0);\n    (0, _defineProperty2.default)(this, \"_requestTask\", void 0);\n    (0, _defineProperty2.default)(this, \"_metadata\", void 0);\n    (0, _defineProperty2.default)(this, \"_tags\", void 0);\n    const specifiedType = type || '';\n    this._name = name;\n    this._metadata = metadata || {};\n    this._tags = tags || {};\n    if (data !== undefined) {\n      if ((0, _isArray.default)(data) || data instanceof Uint8Array) {\n        this._data = ParseFile.encodeBase64(data);\n        this._source = {\n          format: 'base64',\n          base64: this._data,\n          type: specifiedType\n        };\n      } else if (typeof Blob !== 'undefined' && data instanceof Blob) {\n        this._source = {\n          format: 'file',\n          file: data,\n          type: specifiedType\n        };\n      } else if (data && typeof data.uri === 'string' && data.uri !== undefined) {\n        this._source = {\n          format: 'uri',\n          uri: data.uri,\n          type: specifiedType\n        };\n      } else if (data && typeof data.base64 === 'string') {\n        var _context, _context2, _context3;\n        const base64 = (0, _slice.default)(_context = data.base64.split(',')).call(_context, -1)[0];\n        const dataType = specifiedType || (0, _slice.default)(_context2 = (0, _slice.default)(_context3 = data.base64.split(';')).call(_context3, 0, 1)[0].split(':')).call(_context2, 1, 2)[0] || 'text/plain';\n        this._data = base64;\n        this._source = {\n          format: 'base64',\n          base64,\n          type: dataType\n        };\n      } else {\n        throw new TypeError('Cannot create a Parse.File with that data.');\n      }\n    }\n  }\n\n  /**\n   * Return the data for the file, downloading it if not already present.\n   * Data is present if initialized with Byte Array, Base64 or Saved with Uri.\n   * Data is cleared if saved with File object selected with a file upload control\n   *\n   * @param {object} options\n   * @param {function} [options.progress] callback for download progress\n   * <pre>\n   * const parseFile = new Parse.File(name, file);\n   * parseFile.getData({\n   *   progress: (progressValue, loaded, total) => {\n   *     if (progressValue !== null) {\n   *       // Update the UI using progressValue\n   *     }\n   *   }\n   * });\n   * </pre>\n   * @returns {Promise} Promise that is resolve with base64 data\n   */\n  async getData(options) {\n    options = options || {};\n    if (this._data) {\n      return this._data;\n    }\n    if (!this._url) {\n      throw new Error('Cannot retrieve data for unsaved ParseFile.');\n    }\n    options.requestTask = task => this._requestTask = task;\n    const controller = _CoreManager.default.getFileController();\n    const result = await controller.download(this._url, options);\n    this._data = result.base64;\n    return this._data;\n  }\n\n  /**\n   * Gets the name of the file. Before save is called, this is the filename\n   * given by the user. After save is called, that name gets prefixed with a\n   * unique identifier.\n   *\n   * @returns {string}\n   */\n  name() {\n    return this._name;\n  }\n\n  /**\n   * Gets the url of the file. It is only available after you save the file or\n   * after you get the file from a Parse.Object.\n   *\n   * @param {object} options An object to specify url options\n   * @param {boolean} [options.forceSecure] force the url to be secure\n   * @returns {string | undefined}\n   */\n  url(options) {\n    options = options || {};\n    if (!this._url) {\n      return;\n    }\n    if (options.forceSecure) {\n      return this._url.replace(/^http:\\/\\//i, 'https://');\n    } else {\n      return this._url;\n    }\n  }\n\n  /**\n   * Gets the metadata of the file.\n   *\n   * @returns {object}\n   */\n  metadata() {\n    return this._metadata;\n  }\n\n  /**\n   * Gets the tags of the file.\n   *\n   * @returns {object}\n   */\n  tags() {\n    return this._tags;\n  }\n\n  /**\n   * Saves the file to the Parse cloud.\n   *\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *     behalf of a specific user.\n   *   <li>progress: callback for upload progress. For example:\n   * <pre>\n   * let parseFile = new Parse.File(name, file);\n   * parseFile.save({\n   *   progress: (progressValue, loaded, total) => {\n   *     if (progressValue !== null) {\n   *       // Update the UI using progressValue\n   *     }\n   *   }\n   * });\n   * </pre>\n   * </ul>\n   * @returns {Promise | undefined} Promise that is resolved when the save finishes.\n   */\n  save(options) {\n    options = options || {};\n    options.requestTask = task => this._requestTask = task;\n    options.metadata = this._metadata;\n    options.tags = this._tags;\n    const controller = _CoreManager.default.getFileController();\n    if (!this._previousSave) {\n      if (this._source.format === 'file') {\n        this._previousSave = controller.saveFile(this._name, this._source, options).then(res => {\n          this._name = res.name;\n          this._url = res.url;\n          this._data = null;\n          this._requestTask = null;\n          return this;\n        });\n      } else if (this._source.format === 'uri') {\n        this._previousSave = controller.download(this._source.uri, options).then(result => {\n          if (!(result && result.base64)) {\n            return {};\n          }\n          const newSource = {\n            format: 'base64',\n            base64: result.base64,\n            type: result.contentType\n          };\n          this._data = result.base64;\n          this._requestTask = null;\n          return controller.saveBase64(this._name, newSource, options);\n        }).then(res => {\n          this._name = res.name;\n          this._url = res.url;\n          this._requestTask = null;\n          return this;\n        });\n      } else {\n        this._previousSave = controller.saveBase64(this._name, this._source, options).then(res => {\n          this._name = res.name;\n          this._url = res.url;\n          this._requestTask = null;\n          return this;\n        });\n      }\n    }\n    if (this._previousSave) {\n      return this._previousSave;\n    }\n  }\n\n  /**\n   * Aborts the request if it has already been sent.\n   */\n  cancel() {\n    if (this._requestTask && typeof this._requestTask.abort === 'function') {\n      this._requestTask._aborted = true;\n      this._requestTask.abort();\n    }\n    this._requestTask = null;\n  }\n\n  /**\n   * Deletes the file from the Parse cloud.\n   * In Cloud Code and Node only with Master Key.\n   *\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   * <pre>\n   * @returns {Promise} Promise that is resolved when the delete finishes.\n   */\n  destroy() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (!this._name) {\n      throw new _ParseError.default(_ParseError.default.FILE_DELETE_UNNAMED_ERROR, 'Cannot delete an unnamed file.');\n    }\n    const destroyOptions = {\n      useMasterKey: true\n    };\n    if (Object.hasOwn(options, 'useMasterKey')) {\n      destroyOptions.useMasterKey = !!options.useMasterKey;\n    }\n    const controller = _CoreManager.default.getFileController();\n    return controller.deleteFile(this._name, destroyOptions).then(() => {\n      this._data = undefined;\n      this._requestTask = null;\n      return this;\n    });\n  }\n  toJSON() {\n    return {\n      __type: 'File',\n      name: this._name,\n      url: this._url\n    };\n  }\n  equals(other) {\n    if (this === other) {\n      return true;\n    }\n    // Unsaved Files are never equal, since they will be saved to different URLs\n    return other instanceof ParseFile && this.name() === other.name() && this.url() === other.url() && typeof this.url() !== 'undefined';\n  }\n\n  /**\n   * Sets metadata to be saved with file object. Overwrites existing metadata\n   *\n   * @param {object} metadata Key value pairs to be stored with file object\n   */\n  setMetadata(metadata) {\n    if (metadata && typeof metadata === 'object') {\n      var _context4;\n      (0, _forEach.default)(_context4 = (0, _keys.default)(metadata)).call(_context4, key => {\n        this.addMetadata(key, metadata[key]);\n      });\n    }\n  }\n\n  /**\n   * Sets metadata to be saved with file object. Adds to existing metadata.\n   *\n   * @param {string} key key to store the metadata\n   * @param {*} value metadata\n   */\n  addMetadata(key, value) {\n    if (typeof key === 'string') {\n      this._metadata[key] = value;\n    }\n  }\n\n  /**\n   * Sets tags to be saved with file object. Overwrites existing tags\n   *\n   * @param {object} tags Key value pairs to be stored with file object\n   */\n  setTags(tags) {\n    if (tags && typeof tags === 'object') {\n      var _context5;\n      (0, _forEach.default)(_context5 = (0, _keys.default)(tags)).call(_context5, key => {\n        this.addTag(key, tags[key]);\n      });\n    }\n  }\n\n  /**\n   * Sets tags to be saved with file object. Adds to existing tags.\n   *\n   * @param {string} key key to store tags\n   * @param {*} value tag\n   */\n  addTag(key, value) {\n    if (typeof key === 'string') {\n      this._tags[key] = value;\n    }\n  }\n  static fromJSON(obj) {\n    if (obj.__type !== 'File') {\n      throw new TypeError('JSON object does not represent a ParseFile');\n    }\n    const file = new ParseFile(obj.name);\n    file._url = obj.url;\n    return file;\n  }\n  static encodeBase64(bytes) {\n    const chunks = [];\n    chunks.length = Math.ceil(bytes.length / 3);\n    for (let i = 0; i < chunks.length; i++) {\n      const b1 = bytes[i * 3];\n      const b2 = bytes[i * 3 + 1] || 0;\n      const b3 = bytes[i * 3 + 2] || 0;\n      const has2 = i * 3 + 1 < bytes.length;\n      const has3 = i * 3 + 2 < bytes.length;\n      chunks[i] = [b64Digit(b1 >> 2 & 0x3f), b64Digit(b1 << 4 & 0x30 | b2 >> 4 & 0x0f), has2 ? b64Digit(b2 << 2 & 0x3c | b3 >> 6 & 0x03) : '=', has3 ? b64Digit(b3 & 0x3f) : '='].join('');\n    }\n    return chunks.join('');\n  }\n}\nconst DefaultController = {\n  saveFile: async function (name, source, options) {\n    if (source.format !== 'file') {\n      throw new Error('saveFile can only be used with File-type sources.');\n    }\n    const base64Data = await new _promise.default((res, rej) => {\n      const reader = new FileReader();\n      reader.onload = () => res(reader.result);\n      reader.onerror = error => rej(error);\n      reader.readAsDataURL(source.file);\n    });\n    // we only want the data after the comma\n    // For example: \"data:application/pdf;base64,JVBERi0xLjQKJ...\" we would only want \"JVBERi0xLjQKJ...\"\n    const [first, second] = base64Data.split(',');\n    // in the event there is no 'data:application/pdf;base64,' at the beginning of the base64 string\n    // use the entire string instead\n    const data = second ? second : first;\n    const newSource = {\n      format: 'base64',\n      base64: data,\n      type: source.type || (source.file ? source.file.type : undefined)\n    };\n    return await DefaultController.saveBase64(name, newSource, options);\n  },\n  saveBase64: function (name, source) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    if (source.format !== 'base64') {\n      throw new Error('saveBase64 can only be used with Base64-type sources.');\n    }\n    const data = {\n      base64: source.base64,\n      fileData: {\n        metadata: {\n          ...options.metadata\n        },\n        tags: {\n          ...options.tags\n        }\n      }\n    };\n    delete options.metadata;\n    delete options.tags;\n    if (source.type) {\n      data._ContentType = source.type;\n    }\n    return _CoreManager.default.getRESTController().request('POST', 'files/' + name, data, options);\n  },\n  download: async function (uri, options) {\n    const controller = new AbortController();\n    options.requestTask(controller);\n    const {\n      signal\n    } = controller;\n    try {\n      const response = await fetch(uri, {\n        signal\n      });\n      const reader = response.body.getReader();\n      const length = +response.headers.get('Content-Length') || 0;\n      const contentType = response.headers.get('Content-Type');\n      if (length === 0) {\n        options.progress?.(null, null, null);\n        return {\n          base64: '',\n          contentType\n        };\n      }\n      let recieved = 0;\n      const chunks = [];\n      while (true) {\n        const {\n          done,\n          value\n        } = await reader.read();\n        if (done) {\n          break;\n        }\n        chunks.push(value);\n        recieved += value?.length || 0;\n        options.progress?.(recieved / length, recieved, length);\n      }\n      const body = new Uint8Array(recieved);\n      let offset = 0;\n      for (const chunk of chunks) {\n        body.set(chunk, offset);\n        offset += chunk.length;\n      }\n      return {\n        base64: ParseFile.encodeBase64(body),\n        contentType\n      };\n    } catch (error) {\n      if (error.name === 'AbortError') {\n        return {};\n      } else {\n        throw error;\n      }\n    }\n  },\n  deleteFile: function (name, options) {\n    const headers = {\n      'X-Parse-Application-ID': _CoreManager.default.get('APPLICATION_ID')\n    };\n    if (options.useMasterKey) {\n      headers['X-Parse-Master-Key'] = _CoreManager.default.get('MASTER_KEY');\n    }\n    let url = _CoreManager.default.get('SERVER_URL');\n    if (url[url.length - 1] !== '/') {\n      url += '/';\n    }\n    url += 'files/' + name;\n    return _CoreManager.default.getRESTController().ajax('DELETE', url, '', headers).catch(response => {\n      // TODO: return JSON object in server\n      if (!response || response.toString() === 'SyntaxError: Unexpected end of JSON input') {\n        return _promise.default.resolve();\n      } else {\n        return _CoreManager.default.getRESTController().handleError(response);\n      }\n    });\n  }\n};\n_CoreManager.default.setFileController(DefaultController);\nvar _default = exports.default = ParseFile;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}