{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\nvar _forEach = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/for-each\"));\nvar _indexOf = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/index-of\"));\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/keys\"));\nvar _slice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\"));\nvar _map = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/map\"));\nvar _filter = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/filter\"));\nvar _keys2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/keys\"));\nvar _concat = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/concat\"));\nvar _includes = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/includes\"));\nvar _sort = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/sort\"));\nvar _splice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/splice\"));\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/promise\"));\nvar _find = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/find\"));\nvar _bind = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/bind\"));\nvar _isArray = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\"));\nvar _entries = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/entries\"));\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\nvar _encode = _interopRequireDefault(require(\"./encode\"));\nvar _promiseUtils = require(\"./promiseUtils\");\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\nvar _ParseGeoPoint = _interopRequireDefault(require(\"./ParseGeoPoint\"));\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\nvar _OfflineQuery = _interopRequireDefault(require(\"./OfflineQuery\"));\nvar _LocalDatastoreUtils = require(\"./LocalDatastoreUtils\");\n/**\n * Converts a string into a regex that matches it.\n * Surrounding with \\Q .. \\E does this, we just need to escape any \\E's in\n * the text separately.\n *\n * @param s\n * @private\n * @returns {string}\n */\nfunction quote(s) {\n  return '\\\\Q' + s.replace('\\\\E', '\\\\E\\\\\\\\E\\\\Q') + '\\\\E';\n}\n\n/**\n * Extracts the class name from queries. If not all queries have the same\n * class name an error will be thrown.\n *\n * @param queries\n * @private\n * @returns {string}\n */\nfunction _getClassNameFromQueries(queries) {\n  let className = null;\n  (0, _forEach.default)(queries).call(queries, q => {\n    if (!className) {\n      className = q.className;\n    }\n    if (className !== q.className) {\n      throw new Error('All queries must be for the same class.');\n    }\n  });\n  return className;\n}\n\n/*\n * Handles pre-populating the result data of a query with select fields,\n * making sure that the data object contains keys for all objects that have\n * been requested with a select, so that our cached state updates correctly.\n */\nfunction handleSelectResult(data, select) {\n  const serverDataMask = {};\n  (0, _forEach.default)(select).call(select, field => {\n    const hasSubObjectSelect = (0, _indexOf.default)(field).call(field, '.') !== -1;\n    if (!hasSubObjectSelect && !Object.hasOwn(data, field)) {\n      // this field was selected, but is missing from the retrieved data\n      data[field] = undefined;\n    } else if (hasSubObjectSelect) {\n      // this field references a sub-object,\n      // so we need to walk down the path components\n      const pathComponents = field.split('.');\n      let obj = data;\n      let serverMask = serverDataMask;\n      (0, _forEach.default)(pathComponents).call(pathComponents, (component, index, arr) => {\n        // add keys if the expected data is missing\n        if (obj && !Object.hasOwn(obj, component)) {\n          obj[component] = undefined;\n        }\n        if (obj && typeof obj === 'object') {\n          obj = obj[component];\n        }\n\n        //add this path component to the server mask so we can fill it in later if needed\n        if (index < arr.length - 1) {\n          if (!serverMask[component]) {\n            serverMask[component] = {};\n          }\n          serverMask = serverMask[component];\n        }\n      });\n    }\n  });\n  if ((0, _keys.default)(serverDataMask).length > 0) {\n    // When selecting from sub-objects, we don't want to blow away the missing\n    // information that we may have retrieved before. We've already added any\n    // missing selected keys to sub-objects, but we still need to add in the\n    // data for any previously retrieved sub-objects that were not selected.\n\n    const serverData = _CoreManager.default.getObjectStateController().getServerData({\n      id: data.objectId,\n      className: data.className\n    });\n    copyMissingDataWithMask(serverData, data, serverDataMask, false);\n  }\n}\nfunction copyMissingDataWithMask(src, dest, mask, copyThisLevel) {\n  //copy missing elements at this level\n  if (copyThisLevel) {\n    for (const key in src) {\n      if (Object.hasOwn(src, key) && !Object.hasOwn(dest, key)) {\n        dest[key] = src[key];\n      }\n    }\n  }\n  for (const key in mask) {\n    if (dest[key] !== undefined && dest[key] !== null && src !== undefined && src !== null) {\n      //traverse into objects as needed\n      copyMissingDataWithMask(src[key], dest[key], mask[key], true);\n    }\n  }\n}\nfunction handleOfflineSort(a, b, sorts) {\n  let order = sorts[0];\n  const operator = (0, _slice.default)(order).call(order, 0, 1);\n  const isDescending = operator === '-';\n  if (isDescending) {\n    order = order.substring(1);\n  }\n  if (order === '_created_at') {\n    order = 'createdAt';\n  }\n  if (order === '_updated_at') {\n    order = 'updatedAt';\n  }\n  if (!/^[A-Za-z][0-9A-Za-z_]*$/.test(order) || order === 'password') {\n    throw new _ParseError.default(_ParseError.default.INVALID_KEY_NAME, `Invalid Key: ${order}`);\n  }\n  const field1 = a.get(order);\n  const field2 = b.get(order);\n  if (field1 < field2) {\n    return isDescending ? 1 : -1;\n  }\n  if (field1 > field2) {\n    return isDescending ? -1 : 1;\n  }\n  if (sorts.length > 1) {\n    const remainingSorts = (0, _slice.default)(sorts).call(sorts, 1);\n    return handleOfflineSort(a, b, remainingSorts);\n  }\n  return 0;\n}\n/**\n * Creates a new parse Parse.Query for the given Parse.Object subclass.\n *\n * <p>Parse.Query defines a query that is used to fetch Parse.Objects. The\n * most common use case is finding all objects that match a query through the\n * <code>find</code> method. for example, this sample code fetches all objects\n * of class <code>myclass</code>. it calls a different function depending on\n * whether the fetch succeeded or not.\n *\n * <pre>\n * var query = new Parse.Query(myclass);\n * query.find().then((results) => {\n *   // results is an array of parse.object.\n * }).catch((error) =>  {\n *  // error is an instance of parse.error.\n * });</pre></p>\n *\n * <p>a Parse.Query can also be used to retrieve a single object whose id is\n * known, through the get method. for example, this sample code fetches an\n * object of class <code>myclass</code> and id <code>myid</code>. it calls a\n * different function depending on whether the fetch succeeded or not.\n *\n * <pre>\n * var query = new Parse.Query(myclass);\n * query.get(myid).then((object) => {\n *     // object is an instance of parse.object.\n * }).catch((error) =>  {\n *  // error is an instance of parse.error.\n * });</pre></p>\n *\n * <p>a Parse.Query can also be used to count the number of objects that match\n * the query without retrieving all of those objects. for example, this\n * sample code counts the number of objects of the class <code>myclass</code>\n * <pre>\n * var query = new Parse.Query(myclass);\n * query.count().then((number) => {\n *     // there are number instances of myclass.\n * }).catch((error) => {\n *     // error is an instance of Parse.Error.\n * });</pre></p>\n *\n * @alias Parse.Query\n */\nclass ParseQuery {\n  /**\n   * @param {(string | Parse.Object)} objectClass An instance of a subclass of Parse.Object, or a Parse className string.\n   */\n  constructor(objectClass) {\n    /**\n     * @property {string} className\n     */\n    (0, _defineProperty2.default)(this, \"className\", void 0);\n    (0, _defineProperty2.default)(this, \"_where\", void 0);\n    (0, _defineProperty2.default)(this, \"_watch\", void 0);\n    (0, _defineProperty2.default)(this, \"_include\", void 0);\n    (0, _defineProperty2.default)(this, \"_exclude\", void 0);\n    (0, _defineProperty2.default)(this, \"_select\", void 0);\n    (0, _defineProperty2.default)(this, \"_limit\", void 0);\n    (0, _defineProperty2.default)(this, \"_skip\", void 0);\n    (0, _defineProperty2.default)(this, \"_count\", void 0);\n    (0, _defineProperty2.default)(this, \"_order\", void 0);\n    (0, _defineProperty2.default)(this, \"_readPreference\", void 0);\n    (0, _defineProperty2.default)(this, \"_includeReadPreference\", void 0);\n    (0, _defineProperty2.default)(this, \"_subqueryReadPreference\", void 0);\n    (0, _defineProperty2.default)(this, \"_queriesLocalDatastore\", void 0);\n    (0, _defineProperty2.default)(this, \"_localDatastorePinName\", void 0);\n    (0, _defineProperty2.default)(this, \"_extraOptions\", void 0);\n    (0, _defineProperty2.default)(this, \"_hint\", void 0);\n    (0, _defineProperty2.default)(this, \"_explain\", void 0);\n    (0, _defineProperty2.default)(this, \"_xhrRequest\", void 0);\n    (0, _defineProperty2.default)(this, \"_comment\", void 0);\n    if (typeof objectClass === 'string') {\n      if (objectClass === 'User' && _CoreManager.default.get('PERFORM_USER_REWRITE')) {\n        this.className = '_User';\n      } else {\n        this.className = objectClass;\n      }\n    } else if (objectClass instanceof _ParseObject.default) {\n      this.className = objectClass.className;\n    } else if (typeof objectClass === 'function') {\n      const objClass = objectClass;\n      if (typeof objClass.className === 'string') {\n        this.className = objClass.className;\n      } else {\n        const obj = new objClass();\n        this.className = obj.className;\n      }\n    } else {\n      throw new TypeError('A ParseQuery must be constructed with a ParseObject or class name.');\n    }\n    this._where = {};\n    this._watch = [];\n    this._include = [];\n    this._exclude = [];\n    this._count = false;\n    this._limit = -1; // negative limit is not sent in the server request\n    this._skip = 0;\n    this._readPreference = null;\n    this._includeReadPreference = null;\n    this._subqueryReadPreference = null;\n    this._queriesLocalDatastore = false;\n    this._localDatastorePinName = null;\n    this._extraOptions = {};\n    this._xhrRequest = {\n      task: null,\n      onchange: () => {}\n    };\n    this._comment = null;\n  }\n\n  /**\n   * Adds constraint that at least one of the passed in queries matches.\n   *\n   * @param {Array} queries\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  _orQuery(queries) {\n    const queryJSON = (0, _map.default)(queries).call(queries, q => {\n      return q.toJSON().where;\n    });\n    this._where.$or = queryJSON;\n    return this;\n  }\n\n  /**\n   * Adds constraint that all of the passed in queries match.\n   *\n   * @param {Array} queries\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  _andQuery(queries) {\n    const queryJSON = (0, _map.default)(queries).call(queries, q => {\n      return q.toJSON().where;\n    });\n    this._where.$and = queryJSON;\n    return this;\n  }\n\n  /**\n   * Adds constraint that none of the passed in queries match.\n   *\n   * @param {Array} queries\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  _norQuery(queries) {\n    const queryJSON = (0, _map.default)(queries).call(queries, q => {\n      return q.toJSON().where;\n    });\n    this._where.$nor = queryJSON;\n    return this;\n  }\n\n  /**\n   * Helper for condition queries\n   *\n   * @param key\n   * @param condition\n   * @param value\n   * @returns {Parse.Query}\n   */\n  _addCondition(key, condition, value) {\n    if (!this._where[key] || typeof this._where[key] === 'string') {\n      this._where[key] = {};\n    }\n    this._where[key][condition] = (0, _encode.default)(value, false, true);\n    return this;\n  }\n\n  /**\n   * Converts string for regular expression at the beginning\n   *\n   * @param string\n   * @returns {string}\n   */\n  _regexStartWith(string) {\n    return '^' + quote(string);\n  }\n  async _handleOfflineQuery(params) {\n    var _context;\n    _OfflineQuery.default.validateQuery(this);\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    const objects = await localDatastore._serializeObjectsFromPinName(this._localDatastorePinName);\n    let results = (0, _filter.default)(_context = (0, _map.default)(objects).call(objects, (json, _index, arr) => {\n      const object = _ParseObject.default.fromJSON(json, false);\n      if (json._localId && !json.objectId) {\n        object._localId = json._localId;\n      }\n      if (!_OfflineQuery.default.matchesQuery(this.className, object, arr, this)) {\n        return null;\n      }\n      return object;\n    })).call(_context, object => object !== null);\n    if ((0, _keys2.default)(params)) {\n      let keys = (0, _keys2.default)(params).split(',');\n      keys = (0, _concat.default)(keys).call(keys, ['className', 'objectId', 'createdAt', 'updatedAt', 'ACL']);\n      results = (0, _map.default)(results).call(results, object => {\n        var _context2;\n        const json = object._toFullJSON();\n        (0, _forEach.default)(_context2 = (0, _keys.default)(json)).call(_context2, key => {\n          if (!(0, _includes.default)(keys).call(keys, key)) {\n            delete json[key];\n          }\n        });\n        return _ParseObject.default.fromJSON(json, false);\n      });\n    }\n    if (params.order) {\n      const sorts = params.order.split(',');\n      (0, _sort.default)(results).call(results, (a, b) => {\n        return handleOfflineSort(a, b, sorts);\n      });\n    }\n    let count; // count total before applying limit/skip\n    if (params.count) {\n      count = results.length; // total count from response\n    }\n    if (params.skip) {\n      if (params.skip >= results.length) {\n        results = [];\n      } else {\n        results = (0, _splice.default)(results).call(results, params.skip, results.length);\n      }\n    }\n    let limit = results.length;\n    if (params.limit !== 0 && params.limit < results.length) {\n      limit = params.limit;\n    }\n    results = (0, _splice.default)(results).call(results, 0, limit);\n    if (typeof count === 'number') {\n      return {\n        results,\n        count\n      };\n    }\n    return results;\n  }\n\n  /**\n   * Returns a JSON representation of this query.\n   *\n   * @returns {object} The JSON representation of the query.\n   */\n  toJSON() {\n    const params = {\n      where: this._where\n    };\n    if (this._watch.length) {\n      params.watch = this._watch.join(',');\n    }\n    if (this._include.length) {\n      params.include = this._include.join(',');\n    }\n    if (this._exclude.length) {\n      params.excludeKeys = this._exclude.join(',');\n    }\n    if (this._select) {\n      params.keys = this._select.join(',');\n    }\n    if (this._count) {\n      params.count = 1;\n    }\n    if (this._limit >= 0) {\n      params.limit = this._limit;\n    }\n    if (this._skip > 0) {\n      params.skip = this._skip;\n    }\n    if (this._order) {\n      params.order = this._order.join(',');\n    }\n    if (this._readPreference) {\n      params.readPreference = this._readPreference;\n    }\n    if (this._includeReadPreference) {\n      params.includeReadPreference = this._includeReadPreference;\n    }\n    if (this._subqueryReadPreference) {\n      params.subqueryReadPreference = this._subqueryReadPreference;\n    }\n    if (this._hint) {\n      params.hint = this._hint;\n    }\n    if (this._explain) {\n      params.explain = true;\n    }\n    if (this._comment) {\n      params.comment = this._comment;\n    }\n    for (const key in this._extraOptions) {\n      params[key] = this._extraOptions[key];\n    }\n    return params;\n  }\n\n  /**\n   * Return a query with conditions from json, can be useful to send query from server side to client\n   * Not static, all query conditions was set before calling this method will be deleted.\n   * For example on the server side we have\n   * var query = new Parse.Query(\"className\");\n   * query.equalTo(key: value);\n   * query.limit(100);\n   * ... (others queries)\n   * Create JSON representation of Query Object\n   * var jsonFromServer = query.fromJSON();\n   *\n   * On client side getting query:\n   * var query = new Parse.Query(\"className\");\n   * query.fromJSON(jsonFromServer);\n   *\n   * and continue to query...\n   * query.skip(100).find().then(...);\n   *\n   * @param {QueryJSON} json from Parse.Query.toJSON() method\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  withJSON(json) {\n    if (json.where) {\n      this._where = json.where;\n    }\n    if (json.watch) {\n      this._watch = json.watch.split(',');\n    }\n    if (json.include) {\n      this._include = json.include.split(',');\n    }\n    if ((0, _keys2.default)(json)) {\n      this._select = (0, _keys2.default)(json).split(',');\n    }\n    if (json.excludeKeys) {\n      this._exclude = json.excludeKeys.split(',');\n    }\n    if (json.count) {\n      this._count = json.count === 1;\n    }\n    if (json.limit) {\n      this._limit = json.limit;\n    }\n    if (json.skip) {\n      this._skip = json.skip;\n    }\n    if (json.order) {\n      this._order = json.order.split(',');\n    }\n    if (json.readPreference) {\n      this._readPreference = json.readPreference;\n    }\n    if (json.includeReadPreference) {\n      this._includeReadPreference = json.includeReadPreference;\n    }\n    if (json.subqueryReadPreference) {\n      this._subqueryReadPreference = json.subqueryReadPreference;\n    }\n    if (json.hint) {\n      this._hint = json.hint;\n    }\n    if (json.explain) {\n      this._explain = !!json.explain;\n    }\n    if (json.comment) {\n      this._comment = json.comment;\n    }\n    for (const key in json) {\n      if (Object.hasOwn(json, key)) {\n        var _context3;\n        if ((0, _indexOf.default)(_context3 = ['where', 'include', 'keys', 'count', 'limit', 'skip', 'order', 'readPreference', 'includeReadPreference', 'subqueryReadPreference', 'hint', 'explain', 'comment']).call(_context3, key) === -1) {\n          this._extraOptions[key] = json[key];\n        }\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Static method to restore Parse.Query by json representation\n   * Internally calling Parse.Query.withJSON\n   *\n   * @param {string} className\n   * @param {QueryJSON} json from Parse.Query.toJSON() method\n   * @returns {Parse.Query} new created query\n   */\n  static fromJSON(className, json) {\n    const query = new ParseQuery(className);\n    return query.withJSON(json);\n  }\n\n  /**\n   * Constructs a Parse.Object whose id is already known by fetching data from\n   * the server. Unlike the <code>first</code> method, it never returns undefined.\n   *\n   * @param {string} objectId The id of the object to be fetched.\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n   *   <li>json: Return raw json without converting to Parse.Object\n   * </ul>\n   * @returns {Promise} A promise that is resolved with the result when\n   * the query completes.\n   */\n  get(objectId, options) {\n    this.equalTo('objectId', objectId);\n    const firstOptions = _ParseObject.default._getRequestOptions(options);\n    return this.first(firstOptions).then(response => {\n      if (response) {\n        return response;\n      }\n      const errorObject = new _ParseError.default(_ParseError.default.OBJECT_NOT_FOUND, 'Object not found.');\n      return _promise.default.reject(errorObject);\n    });\n  }\n\n  /**\n   * Retrieves a list of ParseObjects that satisfy this query.\n   *\n   * @param {object} options Valid options\n   * are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n   *   <li>json: Return raw json without converting to Parse.Object\n   * </ul>\n   * @returns {Promise} A promise that is resolved with the results when\n   * the query completes.\n   */\n  find(options) {\n    const findOptions = _ParseObject.default._getRequestOptions(options);\n    this._setRequestTask(findOptions);\n    const controller = _CoreManager.default.getQueryController();\n    const select = this._select;\n    if (this._queriesLocalDatastore) {\n      return this._handleOfflineQuery(this.toJSON());\n    }\n    return (0, _find.default)(controller).call(controller, this.className, this.toJSON(), findOptions).then(response => {\n      var _context4, _context5;\n      // Return generic object when explain is used\n      if (this._explain) {\n        return response.results;\n      }\n      const results = ((_context4 = response.results) == null ? void 0 : (0, _bind.default)(_context5 = Function.call).call(_context5, (0, _map.default)(_context4), _context4))?.(data => {\n        // In cases of relations, the server may send back a className\n        // on the top level of the payload\n        const override = response.className || this.className;\n        if (!data.className) {\n          data.className = override;\n        }\n\n        // Make sure the data object contains keys for all objects that\n        // have been requested with a select, so that our cached state\n        // updates correctly.\n        if (select) {\n          handleSelectResult(data, select);\n        }\n        if (findOptions.json) {\n          return data;\n        } else {\n          return _ParseObject.default.fromJSON(data, !select);\n        }\n      });\n      const count = response.count;\n      if (typeof count === 'number') {\n        return {\n          results,\n          count\n        };\n      } else {\n        return results;\n      }\n    });\n  }\n\n  /**\n   * Retrieves a complete list of ParseObjects that satisfy this query.\n   * Using `eachBatch` under the hood to fetch all the valid objects.\n   *\n   * @param {object} options Valid options are:<ul>\n   *   <li>batchSize: How many objects to yield in each batch (default: 100)\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>json: Return raw JSON without converting to Parse.Object.\n   * </ul>\n   * @returns {Promise} A promise that is resolved with the results when\n   * the query completes.\n   */\n  async findAll(options) {\n    let result = [];\n    await this.eachBatch(objects => {\n      result = [...result, ...objects];\n    }, options);\n    return result;\n  }\n\n  /**\n   * Counts the number of objects that match this query.\n   *\n   * @param {object} options\n   * @param {boolean} [options.useMasterKey]\n   * @param {string} [options.sessionToken]\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise} A promise that is resolved with the count when\n   * the query completes.\n   */\n  count(options) {\n    options = options || {};\n    const findOptions = _ParseObject.default._getRequestOptions(options);\n    this._setRequestTask(findOptions);\n    const controller = _CoreManager.default.getQueryController();\n    const params = this.toJSON();\n    params.limit = 0;\n    params.count = 1;\n    return (0, _find.default)(controller).call(controller, this.className, params, findOptions).then(result => {\n      return result.count;\n    });\n  }\n\n  /**\n   * Executes a distinct query and returns unique values\n   *\n   * @param {string} key A field to find distinct values\n   * @returns {Promise} A promise that is resolved with the query completes.\n   */\n  distinct(key) {\n    const distinctOptions = {\n      useMasterKey: true\n    };\n    this._setRequestTask(distinctOptions);\n    const params = {\n      distinct: key,\n      where: this._where,\n      hint: this._hint\n    };\n    const controller = _CoreManager.default.getQueryController();\n    return controller.aggregate(this.className, params, distinctOptions).then(results => {\n      return results.results;\n    });\n  }\n\n  /**\n   * Executes an aggregate query and returns aggregate results\n   *\n   * @param {(Array|object)} pipeline Array or Object of stages to process query\n   * @returns {Promise} A promise that is resolved with the query completes.\n   */\n  aggregate(pipeline) {\n    if (!(0, _isArray.default)(pipeline) && typeof pipeline !== 'object') {\n      throw new Error('Invalid pipeline must be Array or Object');\n    }\n    if ((0, _keys.default)(this._where || {}).length) {\n      if (!(0, _isArray.default)(pipeline)) {\n        pipeline = [pipeline];\n      }\n      pipeline.unshift({\n        $match: this._where\n      });\n    }\n    const params = {\n      pipeline,\n      hint: this._hint,\n      explain: this._explain,\n      readPreference: this._readPreference\n    };\n    const aggregateOptions = {\n      useMasterKey: true\n    };\n    this._setRequestTask(aggregateOptions);\n    const controller = _CoreManager.default.getQueryController();\n    return controller.aggregate(this.className, params, aggregateOptions).then(results => {\n      return results.results;\n    });\n  }\n\n  /**\n   * Retrieves at most one Parse.Object that satisfies this query.\n   *\n   * Returns the object if there is one, otherwise undefined.\n   *\n   * @param {object} options Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n   *   <li>json: Return raw json without converting to Parse.Object\n   * </ul>\n   * @returns {Promise} A promise that is resolved with the object when\n   * the query completes.\n   */\n  first() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const findOptions = _ParseObject.default._getRequestOptions(options);\n    this._setRequestTask(findOptions);\n    const controller = _CoreManager.default.getQueryController();\n    const params = this.toJSON();\n    params.limit = 1;\n    const select = this._select;\n    if (this._queriesLocalDatastore) {\n      return this._handleOfflineQuery(params).then(objects => {\n        if (!objects[0]) {\n          return undefined;\n        }\n        return objects[0];\n      });\n    }\n    return (0, _find.default)(controller).call(controller, this.className, params, findOptions).then(response => {\n      const objects = response.results;\n      if (!objects[0]) {\n        return undefined;\n      }\n      if (!objects[0].className) {\n        objects[0].className = this.className;\n      }\n\n      // Make sure the data object contains keys for all objects that\n      // have been requested with a select, so that our cached state\n      // updates correctly.\n      if (select) {\n        handleSelectResult(objects[0], select);\n      }\n      if (findOptions.json) {\n        return objects[0];\n      } else {\n        return _ParseObject.default.fromJSON(objects[0], !select);\n      }\n    });\n  }\n\n  /**\n   * Iterates over objects matching a query, calling a callback for each batch.\n   * If the callback returns a promise, the iteration will not continue until\n   * that promise has been fulfilled. If the callback returns a rejected\n   * promise, then iteration will stop with that error. The items are processed\n   * in an unspecified order. The query may not have any sort order, and may\n   * not use limit or skip.\n   *\n   * @param {Function} callback Callback that will be called with each result\n   *     of the query.\n   * @param {object} options Valid options are:<ul>\n   *   <li>batchSize: How many objects to yield in each batch (default: 100)\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n   * </ul>\n   * @returns {Promise} A promise that will be fulfilled once the\n   *     iteration has completed.\n   */\n  eachBatch(callback, options) {\n    options = options || {};\n    if (this._order || this._skip || this._limit >= 0) {\n      return _promise.default.reject('Cannot iterate on a query with sort, skip, or limit.');\n    }\n    const query = ParseQuery.fromJSON(this.className, this.toJSON());\n    query.ascending('objectId');\n    query._limit = options.batchSize || 100;\n    const findOptions = _ParseObject.default._getRequestOptions(options);\n    let finished = false;\n    let previousResults = [];\n    return (0, _promiseUtils.continueWhile)(() => {\n      return !finished;\n    }, async () => {\n      const [results] = await _promise.default.all([(0, _find.default)(query).call(query, findOptions), _promise.default.resolve(previousResults.length > 0 && callback(previousResults))]);\n      if (results.length >= query._limit) {\n        if (findOptions.json) {\n          query.greaterThan('objectId', results[results.length - 1].objectId);\n        } else {\n          query.greaterThan('objectId', results[results.length - 1].id);\n        }\n        previousResults = results;\n      } else if (results.length > 0) {\n        await _promise.default.resolve(callback(results));\n        finished = true;\n      } else {\n        finished = true;\n      }\n    });\n  }\n\n  /**\n   * Iterates over each result of a query, calling a callback for each one. If\n   * the callback returns a promise, the iteration will not continue until\n   * that promise has been fulfilled. If the callback returns a rejected\n   * promise, then iteration will stop with that error. The items are\n   * processed in an unspecified order. The query may not have any sort order,\n   * and may not use limit or skip.\n   *\n   * @param {Function} callback Callback that will be called with each result\n   *     of the query.\n   * @param {object} options Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>json: Return raw json without converting to Parse.Object\n   * </ul>\n   * @returns {Promise} A promise that will be fulfilled once the\n   *     iteration has completed.\n   */\n  each(callback, options) {\n    return this.eachBatch(results => {\n      let callbacksDone = _promise.default.resolve();\n      (0, _forEach.default)(results).call(results, result => {\n        callbacksDone = callbacksDone.then(() => {\n          return callback(result);\n        });\n      });\n      return callbacksDone;\n    }, options);\n  }\n\n  /**\n   * Adds a hint to force index selection. (https://docs.mongodb.com/manual/reference/operator/meta/hint/)\n   *\n   * @param {(string|object)} value String or Object of index that should be used when executing query\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  hint(value) {\n    if (typeof value === 'undefined') {\n      delete this._hint;\n    }\n    this._hint = value;\n    return this;\n  }\n\n  /**\n   * Investigates the query execution plan. Useful for optimizing queries. (https://docs.mongodb.com/manual/reference/operator/meta/explain/)\n   *\n   * @param {boolean} explain Used to toggle the information on the query plan.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  explain() {\n    let explain = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (typeof explain !== 'boolean') {\n      throw new Error('You can only set explain to a boolean value');\n    }\n    this._explain = explain;\n    return this;\n  }\n\n  /**\n   * Iterates over each result of a query, calling a callback for each one. If\n   * the callback returns a promise, the iteration will not continue until\n   * that promise has been fulfilled. If the callback returns a rejected\n   * promise, then iteration will stop with that error. The items are\n   * processed in an unspecified order. The query may not have any sort order,\n   * and may not use limit or skip.\n   *\n   * @param {Function} callback Callback <ul>\n   *   <li>currentObject: The current Parse.Object being processed in the array.</li>\n   *   <li>index: The index of the current Parse.Object being processed in the array.</li>\n   *   <li>query: The query map was called upon.</li>\n   * </ul>\n   * @param {object} options Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise} A promise that will be fulfilled once the\n   *     iteration has completed.\n   */\n  async map(callback, options) {\n    const array = [];\n    let index = 0;\n    await this.each(object => {\n      return _promise.default.resolve(callback(object, index, this)).then(result => {\n        array.push(result);\n        index += 1;\n      });\n    }, options);\n    return array;\n  }\n\n  /**\n   * Iterates over each result of a query, calling a callback for each one. If\n   * the callback returns a promise, the iteration will not continue until\n   * that promise has been fulfilled. If the callback returns a rejected\n   * promise, then iteration will stop with that error. The items are\n   * processed in an unspecified order. The query may not have any sort order,\n   * and may not use limit or skip.\n   *\n   * @param {Function} callback Callback <ul>\n   *   <li>accumulator: The accumulator accumulates the callback's return values. It is the accumulated value previously returned in the last invocation of the callback.</li>\n   *   <li>currentObject: The current Parse.Object being processed in the array.</li>\n   *   <li>index: The index of the current Parse.Object being processed in the array.</li>\n   * </ul>\n   * @param {*} initialValue A value to use as the first argument to the first call of the callback. If no initialValue is supplied, the first object in the query will be used and skipped.\n   * @param {object} options Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise} A promise that will be fulfilled once the\n   *     iteration has completed.\n   */\n  async reduce(callback, initialValue, options) {\n    let accumulator = initialValue;\n    let index = 0;\n    await this.each(object => {\n      // If no initial value was given, we take the first object from the query\n      // as the initial value and don't call the callback with it.\n      if (index === 0 && initialValue === undefined) {\n        accumulator = object;\n        index += 1;\n        return;\n      }\n      return _promise.default.resolve(callback(accumulator, object, index)).then(result => {\n        accumulator = result;\n        index += 1;\n      });\n    }, options);\n    if (index === 0 && initialValue === undefined) {\n      // Match Array.reduce behavior: \"Calling reduce() on an empty array\n      // without an initialValue will throw a TypeError\".\n      throw new TypeError('Reducing empty query result set with no initial value');\n    }\n    return accumulator;\n  }\n\n  /**\n   * Iterates over each result of a query, calling a callback for each one. If\n   * the callback returns a promise, the iteration will not continue until\n   * that promise has been fulfilled. If the callback returns a rejected\n   * promise, then iteration will stop with that error. The items are\n   * processed in an unspecified order. The query may not have any sort order,\n   * and may not use limit or skip.\n   *\n   * @param {Function} callback Callback <ul>\n   *   <li>currentObject: The current Parse.Object being processed in the array.</li>\n   *   <li>index: The index of the current Parse.Object being processed in the array.</li>\n   *   <li>query: The query filter was called upon.</li>\n   * </ul>\n   * @param {object} options Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise} A promise that will be fulfilled once the\n   *     iteration has completed.\n   */\n  async filter(callback, options) {\n    const array = [];\n    let index = 0;\n    await this.each(object => {\n      return _promise.default.resolve(callback(object, index, this)).then(flag => {\n        if (flag) {\n          array.push(object);\n        }\n        index += 1;\n      });\n    }, options);\n    return array;\n  }\n\n  /* Query Conditions */\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be equal to the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param value The value that the Parse.Object must contain.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  equalTo(key, value) {\n    if (key && typeof key === 'object') {\n      var _context6;\n      (0, _forEach.default)(_context6 = (0, _entries.default)(key)).call(_context6, _ref => {\n        let [k, val] = _ref;\n        return this.equalTo(k, val);\n      });\n      return this;\n    }\n    if (typeof value === 'undefined') {\n      return this.doesNotExist(key);\n    }\n    this._where[key] = (0, _encode.default)(value, false, true);\n    return this;\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be not equal to the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param value The value that must not be equalled.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  notEqualTo(key, value) {\n    if (key && typeof key === 'object') {\n      var _context7;\n      (0, _forEach.default)(_context7 = (0, _entries.default)(key)).call(_context7, _ref2 => {\n        let [k, val] = _ref2;\n        return this.notEqualTo(k, val);\n      });\n      return this;\n    }\n    return this._addCondition(key, '$ne', value);\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be less than the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param value The value that provides an upper bound.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  lessThan(key, value) {\n    return this._addCondition(key, '$lt', value);\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be greater than the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param value The value that provides an lower bound.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  greaterThan(key, value) {\n    return this._addCondition(key, '$gt', value);\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be less than or equal to the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param value The value that provides an upper bound.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  lessThanOrEqualTo(key, value) {\n    return this._addCondition(key, '$lte', value);\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be greater than or equal to the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param {*} value The value that provides an lower bound.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  greaterThanOrEqualTo(key, value) {\n    return this._addCondition(key, '$gte', value);\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be contained in the provided list of values.\n   *\n   * @param {string} key The key to check.\n   * @param {Array<*>} values The values that will match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  containedIn(key, values) {\n    return this._addCondition(key, '$in', values);\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * not be contained in the provided list of values.\n   *\n   * @param {string} key The key to check.\n   * @param {Array<*>} values The values that will not match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  notContainedIn(key, values) {\n    return this._addCondition(key, '$nin', values);\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be contained by the provided list of values. Get objects where all array elements match.\n   *\n   * @param {string} key The key to check.\n   * @param {Array} values The values that will match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  containedBy(key, values) {\n    return this._addCondition(key, '$containedBy', values);\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * contain each one of the provided list of values.\n   *\n   * @param {string} key The key to check.  This key's value must be an array.\n   * @param {Array} values The values that will match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  containsAll(key, values) {\n    return this._addCondition(key, '$all', values);\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * contain each one of the provided list of values starting with given strings.\n   *\n   * @param {string} key The key to check.  This key's value must be an array.\n   * @param {Array<string>} values The string values that will match as starting string.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  containsAllStartingWith(key, values) {\n    if (!(0, _isArray.default)(values)) {\n      values = [values];\n    }\n    const regexObject = (0, _map.default)(values).call(values, value => {\n      return {\n        $regex: this._regexStartWith(value)\n      };\n    });\n    return this.containsAll(key, regexObject);\n  }\n\n  /**\n   * Adds a constraint for finding objects that contain the given key.\n   *\n   * @param {string} key The key that should exist.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  exists(key) {\n    return this._addCondition(key, '$exists', true);\n  }\n\n  /**\n   * Adds a constraint for finding objects that do not contain a given key.\n   *\n   * @param {string} key The key that should not exist\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  doesNotExist(key) {\n    return this._addCondition(key, '$exists', false);\n  }\n\n  /**\n   * Adds a regular expression constraint for finding string values that match\n   * the provided regular expression.\n   * This may be slow for large datasets.\n   *\n   * @param {string} key The key that the string to match is stored in.\n   * @param {RegExp | string} regex The regular expression pattern to match.\n   * @param {string} modifiers The regular expression mode.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  matches(key, regex, modifiers) {\n    this._addCondition(key, '$regex', regex);\n    if (!modifiers) {\n      modifiers = '';\n    }\n    if (typeof regex !== 'string') {\n      if (regex.ignoreCase) {\n        modifiers += 'i';\n      }\n      if (regex.multiline) {\n        modifiers += 'm';\n      }\n    }\n    if (modifiers.length) {\n      this._addCondition(key, '$options', modifiers);\n    }\n    return this;\n  }\n\n  /**\n   * Adds a constraint that requires that a key's value matches a Parse.Query\n   * constraint.\n   *\n   * @param {string} key The key that the contains the object to match the\n   *                     query.\n   * @param {Parse.Query} query The query that should match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  matchesQuery(key, query) {\n    const queryJSON = query.toJSON();\n    queryJSON.className = query.className;\n    return this._addCondition(key, '$inQuery', queryJSON);\n  }\n\n  /**\n   * Adds a constraint that requires that a key's value not matches a\n   * Parse.Query constraint.\n   *\n   * @param {string} key The key that the contains the object to match the\n   *                     query.\n   * @param {Parse.Query} query The query that should not match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  doesNotMatchQuery(key, query) {\n    const queryJSON = query.toJSON();\n    queryJSON.className = query.className;\n    return this._addCondition(key, '$notInQuery', queryJSON);\n  }\n\n  /**\n   * Adds a constraint that requires that a key's value matches a value in\n   * an object returned by a different Parse.Query.\n   *\n   * @param {string} key The key that contains the value that is being\n   *                     matched.\n   * @param {string} queryKey The key in the objects returned by the query to\n   *                          match against.\n   * @param {Parse.Query} query The query to run.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  matchesKeyInQuery(key, queryKey, query) {\n    const queryJSON = query.toJSON();\n    queryJSON.className = query.className;\n    return this._addCondition(key, '$select', {\n      key: queryKey,\n      query: queryJSON\n    });\n  }\n\n  /**\n   * Adds a constraint that requires that a key's value not match a value in\n   * an object returned by a different Parse.Query.\n   *\n   * @param {string} key The key that contains the value that is being\n   *                     excluded.\n   * @param {string} queryKey The key in the objects returned by the query to\n   *                          match against.\n   * @param {Parse.Query} query The query to run.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  doesNotMatchKeyInQuery(key, queryKey, query) {\n    const queryJSON = query.toJSON();\n    queryJSON.className = query.className;\n    return this._addCondition(key, '$dontSelect', {\n      key: queryKey,\n      query: queryJSON\n    });\n  }\n\n  /**\n   * Adds a constraint for finding string values that contain a provided\n   * string.  This may be slow for large datasets.\n   *\n   * @param {string} key The key that the string to match is stored in.\n   * @param {string} substring The substring that the value must contain.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  contains(key, substring) {\n    if (typeof substring !== 'string') {\n      throw new Error('The value being searched for must be a string.');\n    }\n    return this._addCondition(key, '$regex', quote(substring));\n  }\n\n  /**\n   * Adds a constraint for finding string values that contain a provided\n   * string. This may be slow for large datasets. Requires Parse-Server > 2.5.0\n   *\n   * In order to sort you must use select and ascending ($score is required)\n   *  <pre>\n   *   query.fullText('field', 'term');\n   *   query.ascending('$score');\n   *   query.select('$score');\n   *  </pre>\n   *\n   * To retrieve the weight / rank\n   *  <pre>\n   *   object->get('score');\n   *  </pre>\n   *\n   * You can define optionals by providing an object as a third parameter\n   *  <pre>\n   *   query.fullText('field', 'term', { language: 'es', diacriticSensitive: true });\n   *  </pre>\n   *\n   * @param {string} key The key that the string to match is stored in.\n   * @param {string} value The string to search\n   * @param {object} options (Optional)\n   * @param {string} options.language The language that determines the list of stop words for the search and the rules for the stemmer and tokenizer.\n   * @param {boolean} options.caseSensitive A boolean flag to enable or disable case sensitive search.\n   * @param {boolean} options.diacriticSensitive A boolean flag to enable or disable diacritic sensitive search.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  fullText(key, value, options) {\n    options = options || {};\n    if (!key) {\n      throw new Error('A key is required.');\n    }\n    if (!value) {\n      throw new Error('A search term is required');\n    }\n    if (typeof value !== 'string') {\n      throw new Error('The value being searched for must be a string.');\n    }\n    const fullOptions = {};\n    fullOptions.$term = value;\n    for (const option in options) {\n      switch (option) {\n        case 'language':\n          fullOptions.$language = options[option];\n          break;\n        case 'caseSensitive':\n          fullOptions.$caseSensitive = options[option];\n          break;\n        case 'diacriticSensitive':\n          fullOptions.$diacriticSensitive = options[option];\n          break;\n        default:\n          throw new Error(`Unknown option: ${option}`);\n      }\n    }\n    return this._addCondition(key, '$text', {\n      $search: fullOptions\n    });\n  }\n\n  /**\n   * Method to sort the full text search by text score\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  sortByTextScore() {\n    this.ascending('$score');\n    this.select(['$score']);\n    return this;\n  }\n\n  /**\n   * Adds a constraint for finding string values that start with a provided\n   * string.  This query will use the backend index, so it will be fast even\n   * for large datasets.\n   *\n   * @param {string} key The key that the string to match is stored in.\n   * @param {string} prefix The substring that the value must start with.\n   * @param {string} modifiers The regular expression mode.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  startsWith(key, prefix, modifiers) {\n    if (typeof prefix !== 'string') {\n      throw new Error('The value being searched for must be a string.');\n    }\n    return this.matches(key, this._regexStartWith(prefix), modifiers);\n  }\n\n  /**\n   * Adds a constraint for finding string values that end with a provided\n   * string.  This will be slow for large datasets.\n   *\n   * @param {string} key The key that the string to match is stored in.\n   * @param {string} suffix The substring that the value must end with.\n   * @param {string} modifiers The regular expression mode.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  endsWith(key, suffix, modifiers) {\n    if (typeof suffix !== 'string') {\n      throw new Error('The value being searched for must be a string.');\n    }\n    return this.matches(key, quote(suffix) + '$', modifiers);\n  }\n\n  /**\n   * Adds a proximity based constraint for finding objects with key point\n   * values near the point given.\n   *\n   * @param {string} key The key that the Parse.GeoPoint is stored in.\n   * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  near(key, point) {\n    if (!(point instanceof _ParseGeoPoint.default)) {\n      // Try to cast it as a GeoPoint\n      point = new _ParseGeoPoint.default(point);\n    }\n    return this._addCondition(key, '$nearSphere', point);\n  }\n\n  /**\n   * Adds a proximity based constraint for finding objects with key point\n   * values near the point given and within the maximum distance given.\n   *\n   * @param {string} key The key that the Parse.GeoPoint is stored in.\n   * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n   * @param {number} maxDistance Maximum distance (in radians) of results to return.\n   * @param {boolean} sorted A Bool value that is true if results should be\n   * sorted by distance ascending, false is no sorting is required,\n   * defaults to true.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  withinRadians(key, point, maxDistance, sorted) {\n    if (sorted || sorted === undefined) {\n      this.near(key, point);\n      return this._addCondition(key, '$maxDistance', maxDistance);\n    } else {\n      return this._addCondition(key, '$geoWithin', {\n        $centerSphere: [[point.longitude, point.latitude], maxDistance]\n      });\n    }\n  }\n\n  /**\n   * Adds a proximity based constraint for finding objects with key point\n   * values near the point given and within the maximum distance given.\n   * Radius of earth used is 3958.8 miles.\n   *\n   * @param {string} key The key that the Parse.GeoPoint is stored in.\n   * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n   * @param {number} maxDistance Maximum distance (in miles) of results to return.\n   * @param {boolean} sorted A Bool value that is true if results should be\n   * sorted by distance ascending, false is no sorting is required,\n   * defaults to true.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  withinMiles(key, point, maxDistance, sorted) {\n    return this.withinRadians(key, point, maxDistance / 3958.8, sorted);\n  }\n\n  /**\n   * Adds a proximity based constraint for finding objects with key point\n   * values near the point given and within the maximum distance given.\n   * Radius of earth used is 6371.0 kilometers.\n   *\n   * @param {string} key The key that the Parse.GeoPoint is stored in.\n   * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n   * @param {number} maxDistance Maximum distance (in kilometers) of results to return.\n   * @param {boolean} sorted A Bool value that is true if results should be\n   * sorted by distance ascending, false is no sorting is required,\n   * defaults to true.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  withinKilometers(key, point, maxDistance, sorted) {\n    return this.withinRadians(key, point, maxDistance / 6371.0, sorted);\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's\n   * coordinates be contained within a given rectangular geographic bounding\n   * box.\n   *\n   * @param {string} key The key to be constrained.\n   * @param {Parse.GeoPoint} southwest\n   *     The lower-left inclusive corner of the box.\n   * @param {Parse.GeoPoint} northeast\n   *     The upper-right inclusive corner of the box.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  withinGeoBox(key, southwest, northeast) {\n    if (!(southwest instanceof _ParseGeoPoint.default)) {\n      southwest = new _ParseGeoPoint.default(southwest);\n    }\n    if (!(northeast instanceof _ParseGeoPoint.default)) {\n      northeast = new _ParseGeoPoint.default(northeast);\n    }\n    this._addCondition(key, '$within', {\n      $box: [southwest, northeast]\n    });\n    return this;\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's\n   * coordinates be contained within and on the bounds of a given polygon.\n   * Supports closed and open (last point is connected to first) paths\n   *\n   * Polygon must have at least 3 points\n   *\n   * @param {string} key The key to be constrained.\n   * @param {Array} points Array of Coordinates / GeoPoints\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  withinPolygon(key, points) {\n    return this._addCondition(key, '$geoWithin', {\n      $polygon: points\n    });\n  }\n\n  /**\n   * Add a constraint to the query that requires a particular key's\n   * coordinates that contains a ParseGeoPoint\n   *\n   * @param {string} key The key to be constrained.\n   * @param {Parse.GeoPoint} point\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  polygonContains(key, point) {\n    return this._addCondition(key, '$geoIntersects', {\n      $point: point\n    });\n  }\n\n  /* Query Orderings */\n\n  /**\n   * Sorts the results in ascending order by the given key.\n   *\n   * @param {(string|string[])} keys The key to order by, which is a\n   * string of comma separated values, or an Array of keys, or multiple keys.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  ascending() {\n    this._order = [];\n    for (var _len = arguments.length, keys = new Array(_len), _key = 0; _key < _len; _key++) {\n      keys[_key] = arguments[_key];\n    }\n    return this.addAscending.apply(this, keys);\n  }\n\n  /**\n   * Sorts the results in ascending order by the given key,\n   * but can also add secondary sort descriptors without overwriting _order.\n   *\n   * @param {(string|string[])} keys The key to order by, which is a\n   * string of comma separated values, or an Array of keys, or multiple keys.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  addAscending() {\n    if (!this._order) {\n      this._order = [];\n    }\n    for (var _len2 = arguments.length, keys = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      keys[_key2] = arguments[_key2];\n    }\n    (0, _forEach.default)(keys).call(keys, key => {\n      var _context8;\n      if ((0, _isArray.default)(key)) {\n        key = key.join();\n      }\n      this._order = (0, _concat.default)(_context8 = this._order).call(_context8, key.replace(/\\s/g, '').split(','));\n    });\n    return this;\n  }\n\n  /**\n   * Sorts the results in descending order by the given key.\n   *\n   * @param {(string|string[])} keys The key to order by, which is a\n   * string of comma separated values, or an Array of keys, or multiple keys.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  descending() {\n    this._order = [];\n    for (var _len3 = arguments.length, keys = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      keys[_key3] = arguments[_key3];\n    }\n    return this.addDescending.apply(this, keys);\n  }\n\n  /**\n   * Sorts the results in descending order by the given key,\n   * but can also add secondary sort descriptors without overwriting _order.\n   *\n   * @param {(string|string[])} keys The key to order by, which is a\n   * string of comma separated values, or an Array of keys, or multiple keys.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  addDescending() {\n    if (!this._order) {\n      this._order = [];\n    }\n    for (var _len4 = arguments.length, keys = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      keys[_key4] = arguments[_key4];\n    }\n    (0, _forEach.default)(keys).call(keys, key => {\n      var _context9, _context0;\n      if ((0, _isArray.default)(key)) {\n        key = key.join();\n      }\n      this._order = (0, _concat.default)(_context9 = this._order).call(_context9, (0, _map.default)(_context0 = key.replace(/\\s/g, '').split(',')).call(_context0, k => {\n        return '-' + k;\n      }));\n    });\n    return this;\n  }\n\n  /* Query Options */\n\n  /**\n   * Sets the number of results to skip before returning any results.\n   * This is useful for pagination.\n   * Default is to skip zero results.\n   *\n   * @param {number} n the number of results to skip.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  skip(n) {\n    if (typeof n !== 'number' || n < 0) {\n      throw new Error('You can only skip by a positive number');\n    }\n    this._skip = n;\n    return this;\n  }\n\n  /**\n   * Sets the limit of the number of results to return. The default limit is 100.\n   *\n   * @param {number} n the number of results to limit to.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  limit(n) {\n    if (typeof n !== 'number') {\n      throw new Error('You can only set the limit to a numeric value');\n    }\n    this._limit = n;\n    return this;\n  }\n\n  /**\n   * Sets the flag to include with response the total number of objects satisfying this query,\n   * despite limits/skip. Might be useful for pagination.\n   * Note that result of this query will be wrapped as an object with\n   * `results`: holding {ParseObject} array and `count`: integer holding total number\n   *\n   * @param {boolean} includeCount false - disable, true - enable.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  withCount() {\n    let includeCount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (typeof includeCount !== 'boolean') {\n      throw new Error('You can only set withCount to a boolean value');\n    }\n    this._count = includeCount;\n    return this;\n  }\n  /**\n   * Includes nested Parse.Objects for the provided key.  You can use dot\n   * notation to specify which fields in the included object are also fetched.\n   *\n   * You can include all nested Parse.Objects by passing in '*'.\n   * Requires Parse Server 3.0.0+\n   * <pre>query.include('*');</pre>\n   *\n   * @param {...string|Array<string>} keys The name(s) of the key(s) to include.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  include() {\n    for (var _len5 = arguments.length, keys = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      keys[_key5] = arguments[_key5];\n    }\n    (0, _forEach.default)(keys).call(keys, key => {\n      if ((0, _isArray.default)(key)) {\n        var _context1;\n        this._include = (0, _concat.default)(_context1 = this._include).call(_context1, key);\n      } else {\n        this._include.push(key);\n      }\n    });\n    return this;\n  }\n\n  /**\n   * Includes all nested Parse.Objects one level deep.\n   *\n   * Requires Parse Server 3.0.0+\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  includeAll() {\n    return this.include('*');\n  }\n\n  /**\n   * Restricts the fields of the returned Parse.Objects to include only the\n   * provided keys.  If this is called multiple times, then all of the keys\n   * specified in each of the calls will be included.\n   *\n   * @param {...string|Array<string>} keys The name(s) of the key(s) to include.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  select() {\n    if (!this._select) {\n      this._select = [];\n    }\n    for (var _len6 = arguments.length, keys = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      keys[_key6] = arguments[_key6];\n    }\n    (0, _forEach.default)(keys).call(keys, key => {\n      if ((0, _isArray.default)(key)) {\n        var _context10;\n        this._select = (0, _concat.default)(_context10 = this._select).call(_context10, key);\n      } else {\n        this._select.push(key);\n      }\n    });\n    return this;\n  }\n\n  /**\n   * Restricts the fields of the returned Parse.Objects to all keys except the\n   * provided keys. Exclude takes precedence over select and include.\n   *\n   * Requires Parse Server 3.6.0+\n   *\n   * @param {...string|Array<string>} keys The name(s) of the key(s) to exclude.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  exclude() {\n    for (var _len7 = arguments.length, keys = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      keys[_key7] = arguments[_key7];\n    }\n    (0, _forEach.default)(keys).call(keys, key => {\n      if ((0, _isArray.default)(key)) {\n        var _context11;\n        this._exclude = (0, _concat.default)(_context11 = this._exclude).call(_context11, key);\n      } else {\n        this._exclude.push(key);\n      }\n    });\n    return this;\n  }\n\n  /**\n   * Restricts live query to trigger only for watched fields.\n   *\n   * Requires Parse Server 6.0.0+\n   *\n   * @param {...string|Array<string>} keys The name(s) of the key(s) to watch.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  watch() {\n    for (var _len8 = arguments.length, keys = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n      keys[_key8] = arguments[_key8];\n    }\n    (0, _forEach.default)(keys).call(keys, key => {\n      if ((0, _isArray.default)(key)) {\n        var _context12;\n        this._watch = (0, _concat.default)(_context12 = this._watch).call(_context12, key);\n      } else {\n        this._watch.push(key);\n      }\n    });\n    return this;\n  }\n\n  /**\n   * Changes the read preference that the backend will use when performing the query to the database.\n   *\n   * @param {string} readPreference The read preference for the main query.\n   * @param {string} includeReadPreference The read preference for the queries to include pointers.\n   * @param {string} subqueryReadPreference The read preference for the sub queries.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  readPreference(readPreference, includeReadPreference, subqueryReadPreference) {\n    this._readPreference = readPreference;\n    this._includeReadPreference = includeReadPreference || null;\n    this._subqueryReadPreference = subqueryReadPreference || null;\n    return this;\n  }\n\n  /**\n   * Subscribe this query to get liveQuery updates\n   *\n   * @param {string} sessionToken (optional) Defaults to the currentUser\n   * @returns {Promise<LiveQuerySubscription>} Returns the liveQuerySubscription, it's an event emitter\n   * which can be used to get liveQuery updates.\n   */\n  async subscribe(sessionToken) {\n    const currentUser = await _CoreManager.default.getUserController().currentUserAsync();\n    if (!sessionToken) {\n      sessionToken = currentUser ? currentUser.getSessionToken() || undefined : undefined;\n    }\n    const liveQueryClient = await _CoreManager.default.getLiveQueryController().getDefaultLiveQueryClient();\n    if (liveQueryClient.shouldOpen()) {\n      liveQueryClient.open();\n    }\n    const subscription = liveQueryClient.subscribe(this, sessionToken);\n    return subscription.subscribePromise.then(() => {\n      return subscription;\n    });\n  }\n\n  /**\n   * Constructs a Parse.Query that is the OR of the passed in queries.  For\n   * example:\n   * <pre>var compoundQuery = Parse.Query.or(query1, query2, query3);</pre>\n   *\n   * will create a compoundQuery that is an or of the query1, query2, and\n   * query3.\n   *\n   * @param {...Parse.Query} queries The list of queries to OR.\n   * @static\n   * @returns {Parse.Query} The query that is the OR of the passed in queries.\n   */\n  static or() {\n    for (var _len9 = arguments.length, queries = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n      queries[_key9] = arguments[_key9];\n    }\n    const className = _getClassNameFromQueries(queries);\n    const query = new ParseQuery(className);\n    query._orQuery(queries);\n    return query;\n  }\n\n  /**\n   * Constructs a Parse.Query that is the AND of the passed in queries.  For\n   * example:\n   * <pre>var compoundQuery = Parse.Query.and(query1, query2, query3);</pre>\n   *\n   * will create a compoundQuery that is an and of the query1, query2, and\n   * query3.\n   *\n   * @param {...Parse.Query} queries The list of queries to AND.\n   * @static\n   * @returns {Parse.Query} The query that is the AND of the passed in queries.\n   */\n  static and() {\n    for (var _len0 = arguments.length, queries = new Array(_len0), _key0 = 0; _key0 < _len0; _key0++) {\n      queries[_key0] = arguments[_key0];\n    }\n    const className = _getClassNameFromQueries(queries);\n    const query = new ParseQuery(className);\n    query._andQuery(queries);\n    return query;\n  }\n\n  /**\n   * Constructs a Parse.Query that is the NOR of the passed in queries.  For\n   * example:\n   * <pre>const compoundQuery = Parse.Query.nor(query1, query2, query3);</pre>\n   *\n   * will create a compoundQuery that is a nor of the query1, query2, and\n   * query3.\n   *\n   * @param {...Parse.Query} queries The list of queries to NOR.\n   * @static\n   * @returns {Parse.Query} The query that is the NOR of the passed in queries.\n   */\n  static nor() {\n    for (var _len1 = arguments.length, queries = new Array(_len1), _key1 = 0; _key1 < _len1; _key1++) {\n      queries[_key1] = arguments[_key1];\n    }\n    const className = _getClassNameFromQueries(queries);\n    const query = new ParseQuery(className);\n    query._norQuery(queries);\n    return query;\n  }\n\n  /**\n   * Change the source of this query to the server.\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  fromNetwork() {\n    this._queriesLocalDatastore = false;\n    this._localDatastorePinName = null;\n    return this;\n  }\n\n  /**\n   * Changes the source of this query to all pinned objects.\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  fromLocalDatastore() {\n    return this.fromPinWithName(null);\n  }\n\n  /**\n   * Changes the source of this query to the default group of pinned objects.\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  fromPin() {\n    return this.fromPinWithName(_LocalDatastoreUtils.DEFAULT_PIN);\n  }\n\n  /**\n   * Changes the source of this query to a specific group of pinned objects.\n   *\n   * @param {string} name The name of query source.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  fromPinWithName(name) {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    if (localDatastore.checkIfEnabled()) {\n      this._queriesLocalDatastore = true;\n      this._localDatastorePinName = name;\n    }\n    return this;\n  }\n\n  /**\n   * Cancels the current network request (if any is running).\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  cancel() {\n    if (this._xhrRequest.task && typeof this._xhrRequest.task.abort === 'function') {\n      this._xhrRequest.task._aborted = true;\n      this._xhrRequest.task.abort();\n      this._xhrRequest.task = null;\n      this._xhrRequest.onchange = () => {};\n      return this;\n    }\n    this._xhrRequest.onchange = () => this.cancel();\n    return this;\n  }\n  _setRequestTask(options) {\n    options.requestTask = task => {\n      this._xhrRequest.task = task;\n      this._xhrRequest.onchange();\n    };\n  }\n\n  /**\n   * Sets a comment to the query so that the query\n   * can be identified when using a the profiler for MongoDB.\n   *\n   * @param {string} value a comment can make your profile data easier to interpret and trace.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  comment(value) {\n    if (value == null) {\n      delete this._comment;\n      return this;\n    }\n    if (typeof value !== 'string') {\n      throw new Error('The value of a comment to be sent with this query must be a string.');\n    }\n    this._comment = value;\n    return this;\n  }\n}\nconst DefaultController = {\n  find(className, params, options) {\n    const RESTController = _CoreManager.default.getRESTController();\n    return RESTController.request('GET', 'classes/' + className, params, options);\n  },\n  aggregate(className, params, options) {\n    const RESTController = _CoreManager.default.getRESTController();\n    return RESTController.request('GET', 'aggregate/' + className, params, options);\n  }\n};\n_CoreManager.default.setParseQuery(ParseQuery);\n_CoreManager.default.setQueryController(DefaultController);\nvar _default = exports.default = ParseQuery;","map":{"version":3,"names":["_Object$defineProperty","require","_interopRequireDefault","exports","value","default","_defineProperty2","_forEach","_indexOf","_keys","_slice","_map","_filter","_keys2","_concat","_includes","_sort","_splice","_promise","_find","_bind","_isArray","_entries","_CoreManager","_encode","_promiseUtils","_ParseError","_ParseGeoPoint","_ParseObject","_OfflineQuery","_LocalDatastoreUtils","quote","s","replace","_getClassNameFromQueries","queries","className","call","q","Error","handleSelectResult","data","select","serverDataMask","field","hasSubObjectSelect","Object","hasOwn","undefined","pathComponents","split","obj","serverMask","component","index","arr","length","serverData","getObjectStateController","getServerData","id","objectId","copyMissingDataWithMask","src","dest","mask","copyThisLevel","key","handleOfflineSort","a","b","sorts","order","operator","isDescending","substring","test","INVALID_KEY_NAME","field1","get","field2","remainingSorts","ParseQuery","constructor","objectClass","objClass","TypeError","_where","_watch","_include","_exclude","_count","_limit","_skip","_readPreference","_includeReadPreference","_subqueryReadPreference","_queriesLocalDatastore","_localDatastorePinName","_extraOptions","_xhrRequest","task","onchange","_comment","_orQuery","queryJSON","toJSON","where","$or","_andQuery","$and","_norQuery","$nor","_addCondition","condition","_regexStartWith","string","_handleOfflineQuery","params","_context","validateQuery","localDatastore","getLocalDatastore","objects","_serializeObjectsFromPinName","results","json","_index","object","fromJSON","_localId","matchesQuery","keys","_context2","_toFullJSON","count","skip","limit","watch","join","include","excludeKeys","_select","_order","readPreference","includeReadPreference","subqueryReadPreference","_hint","hint","_explain","explain","comment","withJSON","_context3","query","options","equalTo","firstOptions","_getRequestOptions","first","then","response","errorObject","OBJECT_NOT_FOUND","reject","find","findOptions","_setRequestTask","controller","getQueryController","_context4","_context5","Function","override","findAll","result","eachBatch","distinct","distinctOptions","useMasterKey","aggregate","pipeline","unshift","$match","aggregateOptions","arguments","callback","ascending","batchSize","finished","previousResults","continueWhile","all","resolve","greaterThan","each","callbacksDone","map","array","push","reduce","initialValue","accumulator","filter","flag","_context6","_ref","k","val","doesNotExist","notEqualTo","_context7","_ref2","lessThan","lessThanOrEqualTo","greaterThanOrEqualTo","containedIn","values","notContainedIn","containedBy","containsAll","containsAllStartingWith","regexObject","$regex","exists","matches","regex","modifiers","ignoreCase","multiline","doesNotMatchQuery","matchesKeyInQuery","queryKey","doesNotMatchKeyInQuery","contains","fullText","fullOptions","$term","option","$language","$caseSensitive","$diacriticSensitive","$search","sortByTextScore","startsWith","prefix","endsWith","suffix","near","point","withinRadians","maxDistance","sorted","$centerSphere","longitude","latitude","withinMiles","withinKilometers","withinGeoBox","southwest","northeast","$box","withinPolygon","points","$polygon","polygonContains","$point","_len","Array","_key","addAscending","apply","_len2","_key2","_context8","descending","_len3","_key3","addDescending","_len4","_key4","_context9","_context0","n","withCount","includeCount","_len5","_key5","_context1","includeAll","_len6","_key6","_context10","exclude","_len7","_key7","_context11","_len8","_key8","_context12","subscribe","sessionToken","currentUser","getUserController","currentUserAsync","getSessionToken","liveQueryClient","getLiveQueryController","getDefaultLiveQueryClient","shouldOpen","open","subscription","subscribePromise","or","_len9","_key9","and","_len0","_key0","nor","_len1","_key1","fromNetwork","fromLocalDatastore","fromPinWithName","fromPin","DEFAULT_PIN","name","checkIfEnabled","cancel","abort","_aborted","requestTask","DefaultController","RESTController","getRESTController","request","setParseQuery","setQueryController","_default"],"sources":["/home/snx/Desktop/CS_School/node_modules/parse/lib/browser/ParseQuery.js"],"sourcesContent":["\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/defineProperty\"));\nvar _forEach = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/for-each\"));\nvar _indexOf = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/index-of\"));\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/keys\"));\nvar _slice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\"));\nvar _map = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/map\"));\nvar _filter = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/filter\"));\nvar _keys2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/keys\"));\nvar _concat = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/concat\"));\nvar _includes = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/includes\"));\nvar _sort = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/sort\"));\nvar _splice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/splice\"));\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/promise\"));\nvar _find = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/find\"));\nvar _bind = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/bind\"));\nvar _isArray = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\"));\nvar _entries = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/entries\"));\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\nvar _encode = _interopRequireDefault(require(\"./encode\"));\nvar _promiseUtils = require(\"./promiseUtils\");\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\nvar _ParseGeoPoint = _interopRequireDefault(require(\"./ParseGeoPoint\"));\nvar _ParseObject = _interopRequireDefault(require(\"./ParseObject\"));\nvar _OfflineQuery = _interopRequireDefault(require(\"./OfflineQuery\"));\nvar _LocalDatastoreUtils = require(\"./LocalDatastoreUtils\");\n/**\n * Converts a string into a regex that matches it.\n * Surrounding with \\Q .. \\E does this, we just need to escape any \\E's in\n * the text separately.\n *\n * @param s\n * @private\n * @returns {string}\n */\nfunction quote(s) {\n  return '\\\\Q' + s.replace('\\\\E', '\\\\E\\\\\\\\E\\\\Q') + '\\\\E';\n}\n\n/**\n * Extracts the class name from queries. If not all queries have the same\n * class name an error will be thrown.\n *\n * @param queries\n * @private\n * @returns {string}\n */\nfunction _getClassNameFromQueries(queries) {\n  let className = null;\n  (0, _forEach.default)(queries).call(queries, q => {\n    if (!className) {\n      className = q.className;\n    }\n    if (className !== q.className) {\n      throw new Error('All queries must be for the same class.');\n    }\n  });\n  return className;\n}\n\n/*\n * Handles pre-populating the result data of a query with select fields,\n * making sure that the data object contains keys for all objects that have\n * been requested with a select, so that our cached state updates correctly.\n */\nfunction handleSelectResult(data, select) {\n  const serverDataMask = {};\n  (0, _forEach.default)(select).call(select, field => {\n    const hasSubObjectSelect = (0, _indexOf.default)(field).call(field, '.') !== -1;\n    if (!hasSubObjectSelect && !Object.hasOwn(data, field)) {\n      // this field was selected, but is missing from the retrieved data\n      data[field] = undefined;\n    } else if (hasSubObjectSelect) {\n      // this field references a sub-object,\n      // so we need to walk down the path components\n      const pathComponents = field.split('.');\n      let obj = data;\n      let serverMask = serverDataMask;\n      (0, _forEach.default)(pathComponents).call(pathComponents, (component, index, arr) => {\n        // add keys if the expected data is missing\n        if (obj && !Object.hasOwn(obj, component)) {\n          obj[component] = undefined;\n        }\n        if (obj && typeof obj === 'object') {\n          obj = obj[component];\n        }\n\n        //add this path component to the server mask so we can fill it in later if needed\n        if (index < arr.length - 1) {\n          if (!serverMask[component]) {\n            serverMask[component] = {};\n          }\n          serverMask = serverMask[component];\n        }\n      });\n    }\n  });\n  if ((0, _keys.default)(serverDataMask).length > 0) {\n    // When selecting from sub-objects, we don't want to blow away the missing\n    // information that we may have retrieved before. We've already added any\n    // missing selected keys to sub-objects, but we still need to add in the\n    // data for any previously retrieved sub-objects that were not selected.\n\n    const serverData = _CoreManager.default.getObjectStateController().getServerData({\n      id: data.objectId,\n      className: data.className\n    });\n    copyMissingDataWithMask(serverData, data, serverDataMask, false);\n  }\n}\nfunction copyMissingDataWithMask(src, dest, mask, copyThisLevel) {\n  //copy missing elements at this level\n  if (copyThisLevel) {\n    for (const key in src) {\n      if (Object.hasOwn(src, key) && !Object.hasOwn(dest, key)) {\n        dest[key] = src[key];\n      }\n    }\n  }\n  for (const key in mask) {\n    if (dest[key] !== undefined && dest[key] !== null && src !== undefined && src !== null) {\n      //traverse into objects as needed\n      copyMissingDataWithMask(src[key], dest[key], mask[key], true);\n    }\n  }\n}\nfunction handleOfflineSort(a, b, sorts) {\n  let order = sorts[0];\n  const operator = (0, _slice.default)(order).call(order, 0, 1);\n  const isDescending = operator === '-';\n  if (isDescending) {\n    order = order.substring(1);\n  }\n  if (order === '_created_at') {\n    order = 'createdAt';\n  }\n  if (order === '_updated_at') {\n    order = 'updatedAt';\n  }\n  if (!/^[A-Za-z][0-9A-Za-z_]*$/.test(order) || order === 'password') {\n    throw new _ParseError.default(_ParseError.default.INVALID_KEY_NAME, `Invalid Key: ${order}`);\n  }\n  const field1 = a.get(order);\n  const field2 = b.get(order);\n  if (field1 < field2) {\n    return isDescending ? 1 : -1;\n  }\n  if (field1 > field2) {\n    return isDescending ? -1 : 1;\n  }\n  if (sorts.length > 1) {\n    const remainingSorts = (0, _slice.default)(sorts).call(sorts, 1);\n    return handleOfflineSort(a, b, remainingSorts);\n  }\n  return 0;\n}\n/**\n * Creates a new parse Parse.Query for the given Parse.Object subclass.\n *\n * <p>Parse.Query defines a query that is used to fetch Parse.Objects. The\n * most common use case is finding all objects that match a query through the\n * <code>find</code> method. for example, this sample code fetches all objects\n * of class <code>myclass</code>. it calls a different function depending on\n * whether the fetch succeeded or not.\n *\n * <pre>\n * var query = new Parse.Query(myclass);\n * query.find().then((results) => {\n *   // results is an array of parse.object.\n * }).catch((error) =>  {\n *  // error is an instance of parse.error.\n * });</pre></p>\n *\n * <p>a Parse.Query can also be used to retrieve a single object whose id is\n * known, through the get method. for example, this sample code fetches an\n * object of class <code>myclass</code> and id <code>myid</code>. it calls a\n * different function depending on whether the fetch succeeded or not.\n *\n * <pre>\n * var query = new Parse.Query(myclass);\n * query.get(myid).then((object) => {\n *     // object is an instance of parse.object.\n * }).catch((error) =>  {\n *  // error is an instance of parse.error.\n * });</pre></p>\n *\n * <p>a Parse.Query can also be used to count the number of objects that match\n * the query without retrieving all of those objects. for example, this\n * sample code counts the number of objects of the class <code>myclass</code>\n * <pre>\n * var query = new Parse.Query(myclass);\n * query.count().then((number) => {\n *     // there are number instances of myclass.\n * }).catch((error) => {\n *     // error is an instance of Parse.Error.\n * });</pre></p>\n *\n * @alias Parse.Query\n */\nclass ParseQuery {\n  /**\n   * @param {(string | Parse.Object)} objectClass An instance of a subclass of Parse.Object, or a Parse className string.\n   */\n  constructor(objectClass) {\n    /**\n     * @property {string} className\n     */\n    (0, _defineProperty2.default)(this, \"className\", void 0);\n    (0, _defineProperty2.default)(this, \"_where\", void 0);\n    (0, _defineProperty2.default)(this, \"_watch\", void 0);\n    (0, _defineProperty2.default)(this, \"_include\", void 0);\n    (0, _defineProperty2.default)(this, \"_exclude\", void 0);\n    (0, _defineProperty2.default)(this, \"_select\", void 0);\n    (0, _defineProperty2.default)(this, \"_limit\", void 0);\n    (0, _defineProperty2.default)(this, \"_skip\", void 0);\n    (0, _defineProperty2.default)(this, \"_count\", void 0);\n    (0, _defineProperty2.default)(this, \"_order\", void 0);\n    (0, _defineProperty2.default)(this, \"_readPreference\", void 0);\n    (0, _defineProperty2.default)(this, \"_includeReadPreference\", void 0);\n    (0, _defineProperty2.default)(this, \"_subqueryReadPreference\", void 0);\n    (0, _defineProperty2.default)(this, \"_queriesLocalDatastore\", void 0);\n    (0, _defineProperty2.default)(this, \"_localDatastorePinName\", void 0);\n    (0, _defineProperty2.default)(this, \"_extraOptions\", void 0);\n    (0, _defineProperty2.default)(this, \"_hint\", void 0);\n    (0, _defineProperty2.default)(this, \"_explain\", void 0);\n    (0, _defineProperty2.default)(this, \"_xhrRequest\", void 0);\n    (0, _defineProperty2.default)(this, \"_comment\", void 0);\n    if (typeof objectClass === 'string') {\n      if (objectClass === 'User' && _CoreManager.default.get('PERFORM_USER_REWRITE')) {\n        this.className = '_User';\n      } else {\n        this.className = objectClass;\n      }\n    } else if (objectClass instanceof _ParseObject.default) {\n      this.className = objectClass.className;\n    } else if (typeof objectClass === 'function') {\n      const objClass = objectClass;\n      if (typeof objClass.className === 'string') {\n        this.className = objClass.className;\n      } else {\n        const obj = new objClass();\n        this.className = obj.className;\n      }\n    } else {\n      throw new TypeError('A ParseQuery must be constructed with a ParseObject or class name.');\n    }\n    this._where = {};\n    this._watch = [];\n    this._include = [];\n    this._exclude = [];\n    this._count = false;\n    this._limit = -1; // negative limit is not sent in the server request\n    this._skip = 0;\n    this._readPreference = null;\n    this._includeReadPreference = null;\n    this._subqueryReadPreference = null;\n    this._queriesLocalDatastore = false;\n    this._localDatastorePinName = null;\n    this._extraOptions = {};\n    this._xhrRequest = {\n      task: null,\n      onchange: () => {}\n    };\n    this._comment = null;\n  }\n\n  /**\n   * Adds constraint that at least one of the passed in queries matches.\n   *\n   * @param {Array} queries\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  _orQuery(queries) {\n    const queryJSON = (0, _map.default)(queries).call(queries, q => {\n      return q.toJSON().where;\n    });\n    this._where.$or = queryJSON;\n    return this;\n  }\n\n  /**\n   * Adds constraint that all of the passed in queries match.\n   *\n   * @param {Array} queries\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  _andQuery(queries) {\n    const queryJSON = (0, _map.default)(queries).call(queries, q => {\n      return q.toJSON().where;\n    });\n    this._where.$and = queryJSON;\n    return this;\n  }\n\n  /**\n   * Adds constraint that none of the passed in queries match.\n   *\n   * @param {Array} queries\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  _norQuery(queries) {\n    const queryJSON = (0, _map.default)(queries).call(queries, q => {\n      return q.toJSON().where;\n    });\n    this._where.$nor = queryJSON;\n    return this;\n  }\n\n  /**\n   * Helper for condition queries\n   *\n   * @param key\n   * @param condition\n   * @param value\n   * @returns {Parse.Query}\n   */\n  _addCondition(key, condition, value) {\n    if (!this._where[key] || typeof this._where[key] === 'string') {\n      this._where[key] = {};\n    }\n    this._where[key][condition] = (0, _encode.default)(value, false, true);\n    return this;\n  }\n\n  /**\n   * Converts string for regular expression at the beginning\n   *\n   * @param string\n   * @returns {string}\n   */\n  _regexStartWith(string) {\n    return '^' + quote(string);\n  }\n  async _handleOfflineQuery(params) {\n    var _context;\n    _OfflineQuery.default.validateQuery(this);\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    const objects = await localDatastore._serializeObjectsFromPinName(this._localDatastorePinName);\n    let results = (0, _filter.default)(_context = (0, _map.default)(objects).call(objects, (json, _index, arr) => {\n      const object = _ParseObject.default.fromJSON(json, false);\n      if (json._localId && !json.objectId) {\n        object._localId = json._localId;\n      }\n      if (!_OfflineQuery.default.matchesQuery(this.className, object, arr, this)) {\n        return null;\n      }\n      return object;\n    })).call(_context, object => object !== null);\n    if ((0, _keys2.default)(params)) {\n      let keys = (0, _keys2.default)(params).split(',');\n      keys = (0, _concat.default)(keys).call(keys, ['className', 'objectId', 'createdAt', 'updatedAt', 'ACL']);\n      results = (0, _map.default)(results).call(results, object => {\n        var _context2;\n        const json = object._toFullJSON();\n        (0, _forEach.default)(_context2 = (0, _keys.default)(json)).call(_context2, key => {\n          if (!(0, _includes.default)(keys).call(keys, key)) {\n            delete json[key];\n          }\n        });\n        return _ParseObject.default.fromJSON(json, false);\n      });\n    }\n    if (params.order) {\n      const sorts = params.order.split(',');\n      (0, _sort.default)(results).call(results, (a, b) => {\n        return handleOfflineSort(a, b, sorts);\n      });\n    }\n    let count; // count total before applying limit/skip\n    if (params.count) {\n      count = results.length; // total count from response\n    }\n    if (params.skip) {\n      if (params.skip >= results.length) {\n        results = [];\n      } else {\n        results = (0, _splice.default)(results).call(results, params.skip, results.length);\n      }\n    }\n    let limit = results.length;\n    if (params.limit !== 0 && params.limit < results.length) {\n      limit = params.limit;\n    }\n    results = (0, _splice.default)(results).call(results, 0, limit);\n    if (typeof count === 'number') {\n      return {\n        results,\n        count\n      };\n    }\n    return results;\n  }\n\n  /**\n   * Returns a JSON representation of this query.\n   *\n   * @returns {object} The JSON representation of the query.\n   */\n  toJSON() {\n    const params = {\n      where: this._where\n    };\n    if (this._watch.length) {\n      params.watch = this._watch.join(',');\n    }\n    if (this._include.length) {\n      params.include = this._include.join(',');\n    }\n    if (this._exclude.length) {\n      params.excludeKeys = this._exclude.join(',');\n    }\n    if (this._select) {\n      params.keys = this._select.join(',');\n    }\n    if (this._count) {\n      params.count = 1;\n    }\n    if (this._limit >= 0) {\n      params.limit = this._limit;\n    }\n    if (this._skip > 0) {\n      params.skip = this._skip;\n    }\n    if (this._order) {\n      params.order = this._order.join(',');\n    }\n    if (this._readPreference) {\n      params.readPreference = this._readPreference;\n    }\n    if (this._includeReadPreference) {\n      params.includeReadPreference = this._includeReadPreference;\n    }\n    if (this._subqueryReadPreference) {\n      params.subqueryReadPreference = this._subqueryReadPreference;\n    }\n    if (this._hint) {\n      params.hint = this._hint;\n    }\n    if (this._explain) {\n      params.explain = true;\n    }\n    if (this._comment) {\n      params.comment = this._comment;\n    }\n    for (const key in this._extraOptions) {\n      params[key] = this._extraOptions[key];\n    }\n    return params;\n  }\n\n  /**\n   * Return a query with conditions from json, can be useful to send query from server side to client\n   * Not static, all query conditions was set before calling this method will be deleted.\n   * For example on the server side we have\n   * var query = new Parse.Query(\"className\");\n   * query.equalTo(key: value);\n   * query.limit(100);\n   * ... (others queries)\n   * Create JSON representation of Query Object\n   * var jsonFromServer = query.fromJSON();\n   *\n   * On client side getting query:\n   * var query = new Parse.Query(\"className\");\n   * query.fromJSON(jsonFromServer);\n   *\n   * and continue to query...\n   * query.skip(100).find().then(...);\n   *\n   * @param {QueryJSON} json from Parse.Query.toJSON() method\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  withJSON(json) {\n    if (json.where) {\n      this._where = json.where;\n    }\n    if (json.watch) {\n      this._watch = json.watch.split(',');\n    }\n    if (json.include) {\n      this._include = json.include.split(',');\n    }\n    if ((0, _keys2.default)(json)) {\n      this._select = (0, _keys2.default)(json).split(',');\n    }\n    if (json.excludeKeys) {\n      this._exclude = json.excludeKeys.split(',');\n    }\n    if (json.count) {\n      this._count = json.count === 1;\n    }\n    if (json.limit) {\n      this._limit = json.limit;\n    }\n    if (json.skip) {\n      this._skip = json.skip;\n    }\n    if (json.order) {\n      this._order = json.order.split(',');\n    }\n    if (json.readPreference) {\n      this._readPreference = json.readPreference;\n    }\n    if (json.includeReadPreference) {\n      this._includeReadPreference = json.includeReadPreference;\n    }\n    if (json.subqueryReadPreference) {\n      this._subqueryReadPreference = json.subqueryReadPreference;\n    }\n    if (json.hint) {\n      this._hint = json.hint;\n    }\n    if (json.explain) {\n      this._explain = !!json.explain;\n    }\n    if (json.comment) {\n      this._comment = json.comment;\n    }\n    for (const key in json) {\n      if (Object.hasOwn(json, key)) {\n        var _context3;\n        if ((0, _indexOf.default)(_context3 = ['where', 'include', 'keys', 'count', 'limit', 'skip', 'order', 'readPreference', 'includeReadPreference', 'subqueryReadPreference', 'hint', 'explain', 'comment']).call(_context3, key) === -1) {\n          this._extraOptions[key] = json[key];\n        }\n      }\n    }\n    return this;\n  }\n\n  /**\n   * Static method to restore Parse.Query by json representation\n   * Internally calling Parse.Query.withJSON\n   *\n   * @param {string} className\n   * @param {QueryJSON} json from Parse.Query.toJSON() method\n   * @returns {Parse.Query} new created query\n   */\n  static fromJSON(className, json) {\n    const query = new ParseQuery(className);\n    return query.withJSON(json);\n  }\n\n  /**\n   * Constructs a Parse.Object whose id is already known by fetching data from\n   * the server. Unlike the <code>first</code> method, it never returns undefined.\n   *\n   * @param {string} objectId The id of the object to be fetched.\n   * @param {object} options\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n   *   <li>json: Return raw json without converting to Parse.Object\n   * </ul>\n   * @returns {Promise} A promise that is resolved with the result when\n   * the query completes.\n   */\n  get(objectId, options) {\n    this.equalTo('objectId', objectId);\n    const firstOptions = _ParseObject.default._getRequestOptions(options);\n    return this.first(firstOptions).then(response => {\n      if (response) {\n        return response;\n      }\n      const errorObject = new _ParseError.default(_ParseError.default.OBJECT_NOT_FOUND, 'Object not found.');\n      return _promise.default.reject(errorObject);\n    });\n  }\n\n  /**\n   * Retrieves a list of ParseObjects that satisfy this query.\n   *\n   * @param {object} options Valid options\n   * are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n   *   <li>json: Return raw json without converting to Parse.Object\n   * </ul>\n   * @returns {Promise} A promise that is resolved with the results when\n   * the query completes.\n   */\n  find(options) {\n    const findOptions = _ParseObject.default._getRequestOptions(options);\n    this._setRequestTask(findOptions);\n    const controller = _CoreManager.default.getQueryController();\n    const select = this._select;\n    if (this._queriesLocalDatastore) {\n      return this._handleOfflineQuery(this.toJSON());\n    }\n    return (0, _find.default)(controller).call(controller, this.className, this.toJSON(), findOptions).then(response => {\n      var _context4, _context5;\n      // Return generic object when explain is used\n      if (this._explain) {\n        return response.results;\n      }\n      const results = ((_context4 = response.results) == null ? void 0 : (0, _bind.default)(_context5 = Function.call).call(_context5, (0, _map.default)(_context4), _context4))?.(data => {\n        // In cases of relations, the server may send back a className\n        // on the top level of the payload\n        const override = response.className || this.className;\n        if (!data.className) {\n          data.className = override;\n        }\n\n        // Make sure the data object contains keys for all objects that\n        // have been requested with a select, so that our cached state\n        // updates correctly.\n        if (select) {\n          handleSelectResult(data, select);\n        }\n        if (findOptions.json) {\n          return data;\n        } else {\n          return _ParseObject.default.fromJSON(data, !select);\n        }\n      });\n      const count = response.count;\n      if (typeof count === 'number') {\n        return {\n          results,\n          count\n        };\n      } else {\n        return results;\n      }\n    });\n  }\n\n  /**\n   * Retrieves a complete list of ParseObjects that satisfy this query.\n   * Using `eachBatch` under the hood to fetch all the valid objects.\n   *\n   * @param {object} options Valid options are:<ul>\n   *   <li>batchSize: How many objects to yield in each batch (default: 100)\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>json: Return raw JSON without converting to Parse.Object.\n   * </ul>\n   * @returns {Promise} A promise that is resolved with the results when\n   * the query completes.\n   */\n  async findAll(options) {\n    let result = [];\n    await this.eachBatch(objects => {\n      result = [...result, ...objects];\n    }, options);\n    return result;\n  }\n\n  /**\n   * Counts the number of objects that match this query.\n   *\n   * @param {object} options\n   * @param {boolean} [options.useMasterKey]\n   * @param {string} [options.sessionToken]\n   * Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise} A promise that is resolved with the count when\n   * the query completes.\n   */\n  count(options) {\n    options = options || {};\n    const findOptions = _ParseObject.default._getRequestOptions(options);\n    this._setRequestTask(findOptions);\n    const controller = _CoreManager.default.getQueryController();\n    const params = this.toJSON();\n    params.limit = 0;\n    params.count = 1;\n    return (0, _find.default)(controller).call(controller, this.className, params, findOptions).then(result => {\n      return result.count;\n    });\n  }\n\n  /**\n   * Executes a distinct query and returns unique values\n   *\n   * @param {string} key A field to find distinct values\n   * @returns {Promise} A promise that is resolved with the query completes.\n   */\n  distinct(key) {\n    const distinctOptions = {\n      useMasterKey: true\n    };\n    this._setRequestTask(distinctOptions);\n    const params = {\n      distinct: key,\n      where: this._where,\n      hint: this._hint\n    };\n    const controller = _CoreManager.default.getQueryController();\n    return controller.aggregate(this.className, params, distinctOptions).then(results => {\n      return results.results;\n    });\n  }\n\n  /**\n   * Executes an aggregate query and returns aggregate results\n   *\n   * @param {(Array|object)} pipeline Array or Object of stages to process query\n   * @returns {Promise} A promise that is resolved with the query completes.\n   */\n  aggregate(pipeline) {\n    if (!(0, _isArray.default)(pipeline) && typeof pipeline !== 'object') {\n      throw new Error('Invalid pipeline must be Array or Object');\n    }\n    if ((0, _keys.default)(this._where || {}).length) {\n      if (!(0, _isArray.default)(pipeline)) {\n        pipeline = [pipeline];\n      }\n      pipeline.unshift({\n        $match: this._where\n      });\n    }\n    const params = {\n      pipeline,\n      hint: this._hint,\n      explain: this._explain,\n      readPreference: this._readPreference\n    };\n    const aggregateOptions = {\n      useMasterKey: true\n    };\n    this._setRequestTask(aggregateOptions);\n    const controller = _CoreManager.default.getQueryController();\n    return controller.aggregate(this.className, params, aggregateOptions).then(results => {\n      return results.results;\n    });\n  }\n\n  /**\n   * Retrieves at most one Parse.Object that satisfies this query.\n   *\n   * Returns the object if there is one, otherwise undefined.\n   *\n   * @param {object} options Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n   *   <li>json: Return raw json without converting to Parse.Object\n   * </ul>\n   * @returns {Promise} A promise that is resolved with the object when\n   * the query completes.\n   */\n  first() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const findOptions = _ParseObject.default._getRequestOptions(options);\n    this._setRequestTask(findOptions);\n    const controller = _CoreManager.default.getQueryController();\n    const params = this.toJSON();\n    params.limit = 1;\n    const select = this._select;\n    if (this._queriesLocalDatastore) {\n      return this._handleOfflineQuery(params).then(objects => {\n        if (!objects[0]) {\n          return undefined;\n        }\n        return objects[0];\n      });\n    }\n    return (0, _find.default)(controller).call(controller, this.className, params, findOptions).then(response => {\n      const objects = response.results;\n      if (!objects[0]) {\n        return undefined;\n      }\n      if (!objects[0].className) {\n        objects[0].className = this.className;\n      }\n\n      // Make sure the data object contains keys for all objects that\n      // have been requested with a select, so that our cached state\n      // updates correctly.\n      if (select) {\n        handleSelectResult(objects[0], select);\n      }\n      if (findOptions.json) {\n        return objects[0];\n      } else {\n        return _ParseObject.default.fromJSON(objects[0], !select);\n      }\n    });\n  }\n\n  /**\n   * Iterates over objects matching a query, calling a callback for each batch.\n   * If the callback returns a promise, the iteration will not continue until\n   * that promise has been fulfilled. If the callback returns a rejected\n   * promise, then iteration will stop with that error. The items are processed\n   * in an unspecified order. The query may not have any sort order, and may\n   * not use limit or skip.\n   *\n   * @param {Function} callback Callback that will be called with each result\n   *     of the query.\n   * @param {object} options Valid options are:<ul>\n   *   <li>batchSize: How many objects to yield in each batch (default: 100)\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>context: A dictionary that is accessible in Cloud Code `beforeFind` trigger.\n   * </ul>\n   * @returns {Promise} A promise that will be fulfilled once the\n   *     iteration has completed.\n   */\n  eachBatch(callback, options) {\n    options = options || {};\n    if (this._order || this._skip || this._limit >= 0) {\n      return _promise.default.reject('Cannot iterate on a query with sort, skip, or limit.');\n    }\n    const query = ParseQuery.fromJSON(this.className, this.toJSON());\n    query.ascending('objectId');\n    query._limit = options.batchSize || 100;\n    const findOptions = _ParseObject.default._getRequestOptions(options);\n    let finished = false;\n    let previousResults = [];\n    return (0, _promiseUtils.continueWhile)(() => {\n      return !finished;\n    }, async () => {\n      const [results] = await _promise.default.all([(0, _find.default)(query).call(query, findOptions), _promise.default.resolve(previousResults.length > 0 && callback(previousResults))]);\n      if (results.length >= query._limit) {\n        if (findOptions.json) {\n          query.greaterThan('objectId', results[results.length - 1].objectId);\n        } else {\n          query.greaterThan('objectId', results[results.length - 1].id);\n        }\n        previousResults = results;\n      } else if (results.length > 0) {\n        await _promise.default.resolve(callback(results));\n        finished = true;\n      } else {\n        finished = true;\n      }\n    });\n  }\n\n  /**\n   * Iterates over each result of a query, calling a callback for each one. If\n   * the callback returns a promise, the iteration will not continue until\n   * that promise has been fulfilled. If the callback returns a rejected\n   * promise, then iteration will stop with that error. The items are\n   * processed in an unspecified order. The query may not have any sort order,\n   * and may not use limit or skip.\n   *\n   * @param {Function} callback Callback that will be called with each result\n   *     of the query.\n   * @param {object} options Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   *   <li>json: Return raw json without converting to Parse.Object\n   * </ul>\n   * @returns {Promise} A promise that will be fulfilled once the\n   *     iteration has completed.\n   */\n  each(callback, options) {\n    return this.eachBatch(results => {\n      let callbacksDone = _promise.default.resolve();\n      (0, _forEach.default)(results).call(results, result => {\n        callbacksDone = callbacksDone.then(() => {\n          return callback(result);\n        });\n      });\n      return callbacksDone;\n    }, options);\n  }\n\n  /**\n   * Adds a hint to force index selection. (https://docs.mongodb.com/manual/reference/operator/meta/hint/)\n   *\n   * @param {(string|object)} value String or Object of index that should be used when executing query\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  hint(value) {\n    if (typeof value === 'undefined') {\n      delete this._hint;\n    }\n    this._hint = value;\n    return this;\n  }\n\n  /**\n   * Investigates the query execution plan. Useful for optimizing queries. (https://docs.mongodb.com/manual/reference/operator/meta/explain/)\n   *\n   * @param {boolean} explain Used to toggle the information on the query plan.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  explain() {\n    let explain = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (typeof explain !== 'boolean') {\n      throw new Error('You can only set explain to a boolean value');\n    }\n    this._explain = explain;\n    return this;\n  }\n\n  /**\n   * Iterates over each result of a query, calling a callback for each one. If\n   * the callback returns a promise, the iteration will not continue until\n   * that promise has been fulfilled. If the callback returns a rejected\n   * promise, then iteration will stop with that error. The items are\n   * processed in an unspecified order. The query may not have any sort order,\n   * and may not use limit or skip.\n   *\n   * @param {Function} callback Callback <ul>\n   *   <li>currentObject: The current Parse.Object being processed in the array.</li>\n   *   <li>index: The index of the current Parse.Object being processed in the array.</li>\n   *   <li>query: The query map was called upon.</li>\n   * </ul>\n   * @param {object} options Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise} A promise that will be fulfilled once the\n   *     iteration has completed.\n   */\n  async map(callback, options) {\n    const array = [];\n    let index = 0;\n    await this.each(object => {\n      return _promise.default.resolve(callback(object, index, this)).then(result => {\n        array.push(result);\n        index += 1;\n      });\n    }, options);\n    return array;\n  }\n\n  /**\n   * Iterates over each result of a query, calling a callback for each one. If\n   * the callback returns a promise, the iteration will not continue until\n   * that promise has been fulfilled. If the callback returns a rejected\n   * promise, then iteration will stop with that error. The items are\n   * processed in an unspecified order. The query may not have any sort order,\n   * and may not use limit or skip.\n   *\n   * @param {Function} callback Callback <ul>\n   *   <li>accumulator: The accumulator accumulates the callback's return values. It is the accumulated value previously returned in the last invocation of the callback.</li>\n   *   <li>currentObject: The current Parse.Object being processed in the array.</li>\n   *   <li>index: The index of the current Parse.Object being processed in the array.</li>\n   * </ul>\n   * @param {*} initialValue A value to use as the first argument to the first call of the callback. If no initialValue is supplied, the first object in the query will be used and skipped.\n   * @param {object} options Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise} A promise that will be fulfilled once the\n   *     iteration has completed.\n   */\n  async reduce(callback, initialValue, options) {\n    let accumulator = initialValue;\n    let index = 0;\n    await this.each(object => {\n      // If no initial value was given, we take the first object from the query\n      // as the initial value and don't call the callback with it.\n      if (index === 0 && initialValue === undefined) {\n        accumulator = object;\n        index += 1;\n        return;\n      }\n      return _promise.default.resolve(callback(accumulator, object, index)).then(result => {\n        accumulator = result;\n        index += 1;\n      });\n    }, options);\n    if (index === 0 && initialValue === undefined) {\n      // Match Array.reduce behavior: \"Calling reduce() on an empty array\n      // without an initialValue will throw a TypeError\".\n      throw new TypeError('Reducing empty query result set with no initial value');\n    }\n    return accumulator;\n  }\n\n  /**\n   * Iterates over each result of a query, calling a callback for each one. If\n   * the callback returns a promise, the iteration will not continue until\n   * that promise has been fulfilled. If the callback returns a rejected\n   * promise, then iteration will stop with that error. The items are\n   * processed in an unspecified order. The query may not have any sort order,\n   * and may not use limit or skip.\n   *\n   * @param {Function} callback Callback <ul>\n   *   <li>currentObject: The current Parse.Object being processed in the array.</li>\n   *   <li>index: The index of the current Parse.Object being processed in the array.</li>\n   *   <li>query: The query filter was called upon.</li>\n   * </ul>\n   * @param {object} options Valid options are:<ul>\n   *   <li>useMasterKey: In Cloud Code and Node only, causes the Master Key to\n   *     be used for this request.\n   *   <li>sessionToken: A valid session token, used for making a request on\n   *       behalf of a specific user.\n   * </ul>\n   * @returns {Promise} A promise that will be fulfilled once the\n   *     iteration has completed.\n   */\n  async filter(callback, options) {\n    const array = [];\n    let index = 0;\n    await this.each(object => {\n      return _promise.default.resolve(callback(object, index, this)).then(flag => {\n        if (flag) {\n          array.push(object);\n        }\n        index += 1;\n      });\n    }, options);\n    return array;\n  }\n\n  /* Query Conditions */\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be equal to the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param value The value that the Parse.Object must contain.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  equalTo(key, value) {\n    if (key && typeof key === 'object') {\n      var _context6;\n      (0, _forEach.default)(_context6 = (0, _entries.default)(key)).call(_context6, _ref => {\n        let [k, val] = _ref;\n        return this.equalTo(k, val);\n      });\n      return this;\n    }\n    if (typeof value === 'undefined') {\n      return this.doesNotExist(key);\n    }\n    this._where[key] = (0, _encode.default)(value, false, true);\n    return this;\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be not equal to the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param value The value that must not be equalled.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  notEqualTo(key, value) {\n    if (key && typeof key === 'object') {\n      var _context7;\n      (0, _forEach.default)(_context7 = (0, _entries.default)(key)).call(_context7, _ref2 => {\n        let [k, val] = _ref2;\n        return this.notEqualTo(k, val);\n      });\n      return this;\n    }\n    return this._addCondition(key, '$ne', value);\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be less than the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param value The value that provides an upper bound.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  lessThan(key, value) {\n    return this._addCondition(key, '$lt', value);\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be greater than the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param value The value that provides an lower bound.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  greaterThan(key, value) {\n    return this._addCondition(key, '$gt', value);\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be less than or equal to the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param value The value that provides an upper bound.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  lessThanOrEqualTo(key, value) {\n    return this._addCondition(key, '$lte', value);\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be greater than or equal to the provided value.\n   *\n   * @param {string} key The key to check.\n   * @param {*} value The value that provides an lower bound.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  greaterThanOrEqualTo(key, value) {\n    return this._addCondition(key, '$gte', value);\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be contained in the provided list of values.\n   *\n   * @param {string} key The key to check.\n   * @param {Array<*>} values The values that will match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  containedIn(key, values) {\n    return this._addCondition(key, '$in', values);\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * not be contained in the provided list of values.\n   *\n   * @param {string} key The key to check.\n   * @param {Array<*>} values The values that will not match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  notContainedIn(key, values) {\n    return this._addCondition(key, '$nin', values);\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * be contained by the provided list of values. Get objects where all array elements match.\n   *\n   * @param {string} key The key to check.\n   * @param {Array} values The values that will match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  containedBy(key, values) {\n    return this._addCondition(key, '$containedBy', values);\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * contain each one of the provided list of values.\n   *\n   * @param {string} key The key to check.  This key's value must be an array.\n   * @param {Array} values The values that will match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  containsAll(key, values) {\n    return this._addCondition(key, '$all', values);\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's value to\n   * contain each one of the provided list of values starting with given strings.\n   *\n   * @param {string} key The key to check.  This key's value must be an array.\n   * @param {Array<string>} values The string values that will match as starting string.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  containsAllStartingWith(key, values) {\n    if (!(0, _isArray.default)(values)) {\n      values = [values];\n    }\n    const regexObject = (0, _map.default)(values).call(values, value => {\n      return {\n        $regex: this._regexStartWith(value)\n      };\n    });\n    return this.containsAll(key, regexObject);\n  }\n\n  /**\n   * Adds a constraint for finding objects that contain the given key.\n   *\n   * @param {string} key The key that should exist.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  exists(key) {\n    return this._addCondition(key, '$exists', true);\n  }\n\n  /**\n   * Adds a constraint for finding objects that do not contain a given key.\n   *\n   * @param {string} key The key that should not exist\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  doesNotExist(key) {\n    return this._addCondition(key, '$exists', false);\n  }\n\n  /**\n   * Adds a regular expression constraint for finding string values that match\n   * the provided regular expression.\n   * This may be slow for large datasets.\n   *\n   * @param {string} key The key that the string to match is stored in.\n   * @param {RegExp | string} regex The regular expression pattern to match.\n   * @param {string} modifiers The regular expression mode.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  matches(key, regex, modifiers) {\n    this._addCondition(key, '$regex', regex);\n    if (!modifiers) {\n      modifiers = '';\n    }\n    if (typeof regex !== 'string') {\n      if (regex.ignoreCase) {\n        modifiers += 'i';\n      }\n      if (regex.multiline) {\n        modifiers += 'm';\n      }\n    }\n    if (modifiers.length) {\n      this._addCondition(key, '$options', modifiers);\n    }\n    return this;\n  }\n\n  /**\n   * Adds a constraint that requires that a key's value matches a Parse.Query\n   * constraint.\n   *\n   * @param {string} key The key that the contains the object to match the\n   *                     query.\n   * @param {Parse.Query} query The query that should match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  matchesQuery(key, query) {\n    const queryJSON = query.toJSON();\n    queryJSON.className = query.className;\n    return this._addCondition(key, '$inQuery', queryJSON);\n  }\n\n  /**\n   * Adds a constraint that requires that a key's value not matches a\n   * Parse.Query constraint.\n   *\n   * @param {string} key The key that the contains the object to match the\n   *                     query.\n   * @param {Parse.Query} query The query that should not match.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  doesNotMatchQuery(key, query) {\n    const queryJSON = query.toJSON();\n    queryJSON.className = query.className;\n    return this._addCondition(key, '$notInQuery', queryJSON);\n  }\n\n  /**\n   * Adds a constraint that requires that a key's value matches a value in\n   * an object returned by a different Parse.Query.\n   *\n   * @param {string} key The key that contains the value that is being\n   *                     matched.\n   * @param {string} queryKey The key in the objects returned by the query to\n   *                          match against.\n   * @param {Parse.Query} query The query to run.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  matchesKeyInQuery(key, queryKey, query) {\n    const queryJSON = query.toJSON();\n    queryJSON.className = query.className;\n    return this._addCondition(key, '$select', {\n      key: queryKey,\n      query: queryJSON\n    });\n  }\n\n  /**\n   * Adds a constraint that requires that a key's value not match a value in\n   * an object returned by a different Parse.Query.\n   *\n   * @param {string} key The key that contains the value that is being\n   *                     excluded.\n   * @param {string} queryKey The key in the objects returned by the query to\n   *                          match against.\n   * @param {Parse.Query} query The query to run.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  doesNotMatchKeyInQuery(key, queryKey, query) {\n    const queryJSON = query.toJSON();\n    queryJSON.className = query.className;\n    return this._addCondition(key, '$dontSelect', {\n      key: queryKey,\n      query: queryJSON\n    });\n  }\n\n  /**\n   * Adds a constraint for finding string values that contain a provided\n   * string.  This may be slow for large datasets.\n   *\n   * @param {string} key The key that the string to match is stored in.\n   * @param {string} substring The substring that the value must contain.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  contains(key, substring) {\n    if (typeof substring !== 'string') {\n      throw new Error('The value being searched for must be a string.');\n    }\n    return this._addCondition(key, '$regex', quote(substring));\n  }\n\n  /**\n   * Adds a constraint for finding string values that contain a provided\n   * string. This may be slow for large datasets. Requires Parse-Server > 2.5.0\n   *\n   * In order to sort you must use select and ascending ($score is required)\n   *  <pre>\n   *   query.fullText('field', 'term');\n   *   query.ascending('$score');\n   *   query.select('$score');\n   *  </pre>\n   *\n   * To retrieve the weight / rank\n   *  <pre>\n   *   object->get('score');\n   *  </pre>\n   *\n   * You can define optionals by providing an object as a third parameter\n   *  <pre>\n   *   query.fullText('field', 'term', { language: 'es', diacriticSensitive: true });\n   *  </pre>\n   *\n   * @param {string} key The key that the string to match is stored in.\n   * @param {string} value The string to search\n   * @param {object} options (Optional)\n   * @param {string} options.language The language that determines the list of stop words for the search and the rules for the stemmer and tokenizer.\n   * @param {boolean} options.caseSensitive A boolean flag to enable or disable case sensitive search.\n   * @param {boolean} options.diacriticSensitive A boolean flag to enable or disable diacritic sensitive search.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  fullText(key, value, options) {\n    options = options || {};\n    if (!key) {\n      throw new Error('A key is required.');\n    }\n    if (!value) {\n      throw new Error('A search term is required');\n    }\n    if (typeof value !== 'string') {\n      throw new Error('The value being searched for must be a string.');\n    }\n    const fullOptions = {};\n    fullOptions.$term = value;\n    for (const option in options) {\n      switch (option) {\n        case 'language':\n          fullOptions.$language = options[option];\n          break;\n        case 'caseSensitive':\n          fullOptions.$caseSensitive = options[option];\n          break;\n        case 'diacriticSensitive':\n          fullOptions.$diacriticSensitive = options[option];\n          break;\n        default:\n          throw new Error(`Unknown option: ${option}`);\n      }\n    }\n    return this._addCondition(key, '$text', {\n      $search: fullOptions\n    });\n  }\n\n  /**\n   * Method to sort the full text search by text score\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  sortByTextScore() {\n    this.ascending('$score');\n    this.select(['$score']);\n    return this;\n  }\n\n  /**\n   * Adds a constraint for finding string values that start with a provided\n   * string.  This query will use the backend index, so it will be fast even\n   * for large datasets.\n   *\n   * @param {string} key The key that the string to match is stored in.\n   * @param {string} prefix The substring that the value must start with.\n   * @param {string} modifiers The regular expression mode.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  startsWith(key, prefix, modifiers) {\n    if (typeof prefix !== 'string') {\n      throw new Error('The value being searched for must be a string.');\n    }\n    return this.matches(key, this._regexStartWith(prefix), modifiers);\n  }\n\n  /**\n   * Adds a constraint for finding string values that end with a provided\n   * string.  This will be slow for large datasets.\n   *\n   * @param {string} key The key that the string to match is stored in.\n   * @param {string} suffix The substring that the value must end with.\n   * @param {string} modifiers The regular expression mode.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  endsWith(key, suffix, modifiers) {\n    if (typeof suffix !== 'string') {\n      throw new Error('The value being searched for must be a string.');\n    }\n    return this.matches(key, quote(suffix) + '$', modifiers);\n  }\n\n  /**\n   * Adds a proximity based constraint for finding objects with key point\n   * values near the point given.\n   *\n   * @param {string} key The key that the Parse.GeoPoint is stored in.\n   * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  near(key, point) {\n    if (!(point instanceof _ParseGeoPoint.default)) {\n      // Try to cast it as a GeoPoint\n      point = new _ParseGeoPoint.default(point);\n    }\n    return this._addCondition(key, '$nearSphere', point);\n  }\n\n  /**\n   * Adds a proximity based constraint for finding objects with key point\n   * values near the point given and within the maximum distance given.\n   *\n   * @param {string} key The key that the Parse.GeoPoint is stored in.\n   * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n   * @param {number} maxDistance Maximum distance (in radians) of results to return.\n   * @param {boolean} sorted A Bool value that is true if results should be\n   * sorted by distance ascending, false is no sorting is required,\n   * defaults to true.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  withinRadians(key, point, maxDistance, sorted) {\n    if (sorted || sorted === undefined) {\n      this.near(key, point);\n      return this._addCondition(key, '$maxDistance', maxDistance);\n    } else {\n      return this._addCondition(key, '$geoWithin', {\n        $centerSphere: [[point.longitude, point.latitude], maxDistance]\n      });\n    }\n  }\n\n  /**\n   * Adds a proximity based constraint for finding objects with key point\n   * values near the point given and within the maximum distance given.\n   * Radius of earth used is 3958.8 miles.\n   *\n   * @param {string} key The key that the Parse.GeoPoint is stored in.\n   * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n   * @param {number} maxDistance Maximum distance (in miles) of results to return.\n   * @param {boolean} sorted A Bool value that is true if results should be\n   * sorted by distance ascending, false is no sorting is required,\n   * defaults to true.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  withinMiles(key, point, maxDistance, sorted) {\n    return this.withinRadians(key, point, maxDistance / 3958.8, sorted);\n  }\n\n  /**\n   * Adds a proximity based constraint for finding objects with key point\n   * values near the point given and within the maximum distance given.\n   * Radius of earth used is 6371.0 kilometers.\n   *\n   * @param {string} key The key that the Parse.GeoPoint is stored in.\n   * @param {Parse.GeoPoint} point The reference Parse.GeoPoint that is used.\n   * @param {number} maxDistance Maximum distance (in kilometers) of results to return.\n   * @param {boolean} sorted A Bool value that is true if results should be\n   * sorted by distance ascending, false is no sorting is required,\n   * defaults to true.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  withinKilometers(key, point, maxDistance, sorted) {\n    return this.withinRadians(key, point, maxDistance / 6371.0, sorted);\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's\n   * coordinates be contained within a given rectangular geographic bounding\n   * box.\n   *\n   * @param {string} key The key to be constrained.\n   * @param {Parse.GeoPoint} southwest\n   *     The lower-left inclusive corner of the box.\n   * @param {Parse.GeoPoint} northeast\n   *     The upper-right inclusive corner of the box.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  withinGeoBox(key, southwest, northeast) {\n    if (!(southwest instanceof _ParseGeoPoint.default)) {\n      southwest = new _ParseGeoPoint.default(southwest);\n    }\n    if (!(northeast instanceof _ParseGeoPoint.default)) {\n      northeast = new _ParseGeoPoint.default(northeast);\n    }\n    this._addCondition(key, '$within', {\n      $box: [southwest, northeast]\n    });\n    return this;\n  }\n\n  /**\n   * Adds a constraint to the query that requires a particular key's\n   * coordinates be contained within and on the bounds of a given polygon.\n   * Supports closed and open (last point is connected to first) paths\n   *\n   * Polygon must have at least 3 points\n   *\n   * @param {string} key The key to be constrained.\n   * @param {Array} points Array of Coordinates / GeoPoints\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  withinPolygon(key, points) {\n    return this._addCondition(key, '$geoWithin', {\n      $polygon: points\n    });\n  }\n\n  /**\n   * Add a constraint to the query that requires a particular key's\n   * coordinates that contains a ParseGeoPoint\n   *\n   * @param {string} key The key to be constrained.\n   * @param {Parse.GeoPoint} point\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  polygonContains(key, point) {\n    return this._addCondition(key, '$geoIntersects', {\n      $point: point\n    });\n  }\n\n  /* Query Orderings */\n\n  /**\n   * Sorts the results in ascending order by the given key.\n   *\n   * @param {(string|string[])} keys The key to order by, which is a\n   * string of comma separated values, or an Array of keys, or multiple keys.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  ascending() {\n    this._order = [];\n    for (var _len = arguments.length, keys = new Array(_len), _key = 0; _key < _len; _key++) {\n      keys[_key] = arguments[_key];\n    }\n    return this.addAscending.apply(this, keys);\n  }\n\n  /**\n   * Sorts the results in ascending order by the given key,\n   * but can also add secondary sort descriptors without overwriting _order.\n   *\n   * @param {(string|string[])} keys The key to order by, which is a\n   * string of comma separated values, or an Array of keys, or multiple keys.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  addAscending() {\n    if (!this._order) {\n      this._order = [];\n    }\n    for (var _len2 = arguments.length, keys = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      keys[_key2] = arguments[_key2];\n    }\n    (0, _forEach.default)(keys).call(keys, key => {\n      var _context8;\n      if ((0, _isArray.default)(key)) {\n        key = key.join();\n      }\n      this._order = (0, _concat.default)(_context8 = this._order).call(_context8, key.replace(/\\s/g, '').split(','));\n    });\n    return this;\n  }\n\n  /**\n   * Sorts the results in descending order by the given key.\n   *\n   * @param {(string|string[])} keys The key to order by, which is a\n   * string of comma separated values, or an Array of keys, or multiple keys.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  descending() {\n    this._order = [];\n    for (var _len3 = arguments.length, keys = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      keys[_key3] = arguments[_key3];\n    }\n    return this.addDescending.apply(this, keys);\n  }\n\n  /**\n   * Sorts the results in descending order by the given key,\n   * but can also add secondary sort descriptors without overwriting _order.\n   *\n   * @param {(string|string[])} keys The key to order by, which is a\n   * string of comma separated values, or an Array of keys, or multiple keys.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  addDescending() {\n    if (!this._order) {\n      this._order = [];\n    }\n    for (var _len4 = arguments.length, keys = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n      keys[_key4] = arguments[_key4];\n    }\n    (0, _forEach.default)(keys).call(keys, key => {\n      var _context9, _context0;\n      if ((0, _isArray.default)(key)) {\n        key = key.join();\n      }\n      this._order = (0, _concat.default)(_context9 = this._order).call(_context9, (0, _map.default)(_context0 = key.replace(/\\s/g, '').split(',')).call(_context0, k => {\n        return '-' + k;\n      }));\n    });\n    return this;\n  }\n\n  /* Query Options */\n\n  /**\n   * Sets the number of results to skip before returning any results.\n   * This is useful for pagination.\n   * Default is to skip zero results.\n   *\n   * @param {number} n the number of results to skip.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  skip(n) {\n    if (typeof n !== 'number' || n < 0) {\n      throw new Error('You can only skip by a positive number');\n    }\n    this._skip = n;\n    return this;\n  }\n\n  /**\n   * Sets the limit of the number of results to return. The default limit is 100.\n   *\n   * @param {number} n the number of results to limit to.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  limit(n) {\n    if (typeof n !== 'number') {\n      throw new Error('You can only set the limit to a numeric value');\n    }\n    this._limit = n;\n    return this;\n  }\n\n  /**\n   * Sets the flag to include with response the total number of objects satisfying this query,\n   * despite limits/skip. Might be useful for pagination.\n   * Note that result of this query will be wrapped as an object with\n   * `results`: holding {ParseObject} array and `count`: integer holding total number\n   *\n   * @param {boolean} includeCount false - disable, true - enable.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  withCount() {\n    let includeCount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    if (typeof includeCount !== 'boolean') {\n      throw new Error('You can only set withCount to a boolean value');\n    }\n    this._count = includeCount;\n    return this;\n  }\n  /**\n   * Includes nested Parse.Objects for the provided key.  You can use dot\n   * notation to specify which fields in the included object are also fetched.\n   *\n   * You can include all nested Parse.Objects by passing in '*'.\n   * Requires Parse Server 3.0.0+\n   * <pre>query.include('*');</pre>\n   *\n   * @param {...string|Array<string>} keys The name(s) of the key(s) to include.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  include() {\n    for (var _len5 = arguments.length, keys = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      keys[_key5] = arguments[_key5];\n    }\n    (0, _forEach.default)(keys).call(keys, key => {\n      if ((0, _isArray.default)(key)) {\n        var _context1;\n        this._include = (0, _concat.default)(_context1 = this._include).call(_context1, key);\n      } else {\n        this._include.push(key);\n      }\n    });\n    return this;\n  }\n\n  /**\n   * Includes all nested Parse.Objects one level deep.\n   *\n   * Requires Parse Server 3.0.0+\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  includeAll() {\n    return this.include('*');\n  }\n\n  /**\n   * Restricts the fields of the returned Parse.Objects to include only the\n   * provided keys.  If this is called multiple times, then all of the keys\n   * specified in each of the calls will be included.\n   *\n   * @param {...string|Array<string>} keys The name(s) of the key(s) to include.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  select() {\n    if (!this._select) {\n      this._select = [];\n    }\n    for (var _len6 = arguments.length, keys = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      keys[_key6] = arguments[_key6];\n    }\n    (0, _forEach.default)(keys).call(keys, key => {\n      if ((0, _isArray.default)(key)) {\n        var _context10;\n        this._select = (0, _concat.default)(_context10 = this._select).call(_context10, key);\n      } else {\n        this._select.push(key);\n      }\n    });\n    return this;\n  }\n\n  /**\n   * Restricts the fields of the returned Parse.Objects to all keys except the\n   * provided keys. Exclude takes precedence over select and include.\n   *\n   * Requires Parse Server 3.6.0+\n   *\n   * @param {...string|Array<string>} keys The name(s) of the key(s) to exclude.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  exclude() {\n    for (var _len7 = arguments.length, keys = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      keys[_key7] = arguments[_key7];\n    }\n    (0, _forEach.default)(keys).call(keys, key => {\n      if ((0, _isArray.default)(key)) {\n        var _context11;\n        this._exclude = (0, _concat.default)(_context11 = this._exclude).call(_context11, key);\n      } else {\n        this._exclude.push(key);\n      }\n    });\n    return this;\n  }\n\n  /**\n   * Restricts live query to trigger only for watched fields.\n   *\n   * Requires Parse Server 6.0.0+\n   *\n   * @param {...string|Array<string>} keys The name(s) of the key(s) to watch.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  watch() {\n    for (var _len8 = arguments.length, keys = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n      keys[_key8] = arguments[_key8];\n    }\n    (0, _forEach.default)(keys).call(keys, key => {\n      if ((0, _isArray.default)(key)) {\n        var _context12;\n        this._watch = (0, _concat.default)(_context12 = this._watch).call(_context12, key);\n      } else {\n        this._watch.push(key);\n      }\n    });\n    return this;\n  }\n\n  /**\n   * Changes the read preference that the backend will use when performing the query to the database.\n   *\n   * @param {string} readPreference The read preference for the main query.\n   * @param {string} includeReadPreference The read preference for the queries to include pointers.\n   * @param {string} subqueryReadPreference The read preference for the sub queries.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  readPreference(readPreference, includeReadPreference, subqueryReadPreference) {\n    this._readPreference = readPreference;\n    this._includeReadPreference = includeReadPreference || null;\n    this._subqueryReadPreference = subqueryReadPreference || null;\n    return this;\n  }\n\n  /**\n   * Subscribe this query to get liveQuery updates\n   *\n   * @param {string} sessionToken (optional) Defaults to the currentUser\n   * @returns {Promise<LiveQuerySubscription>} Returns the liveQuerySubscription, it's an event emitter\n   * which can be used to get liveQuery updates.\n   */\n  async subscribe(sessionToken) {\n    const currentUser = await _CoreManager.default.getUserController().currentUserAsync();\n    if (!sessionToken) {\n      sessionToken = currentUser ? currentUser.getSessionToken() || undefined : undefined;\n    }\n    const liveQueryClient = await _CoreManager.default.getLiveQueryController().getDefaultLiveQueryClient();\n    if (liveQueryClient.shouldOpen()) {\n      liveQueryClient.open();\n    }\n    const subscription = liveQueryClient.subscribe(this, sessionToken);\n    return subscription.subscribePromise.then(() => {\n      return subscription;\n    });\n  }\n\n  /**\n   * Constructs a Parse.Query that is the OR of the passed in queries.  For\n   * example:\n   * <pre>var compoundQuery = Parse.Query.or(query1, query2, query3);</pre>\n   *\n   * will create a compoundQuery that is an or of the query1, query2, and\n   * query3.\n   *\n   * @param {...Parse.Query} queries The list of queries to OR.\n   * @static\n   * @returns {Parse.Query} The query that is the OR of the passed in queries.\n   */\n  static or() {\n    for (var _len9 = arguments.length, queries = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++) {\n      queries[_key9] = arguments[_key9];\n    }\n    const className = _getClassNameFromQueries(queries);\n    const query = new ParseQuery(className);\n    query._orQuery(queries);\n    return query;\n  }\n\n  /**\n   * Constructs a Parse.Query that is the AND of the passed in queries.  For\n   * example:\n   * <pre>var compoundQuery = Parse.Query.and(query1, query2, query3);</pre>\n   *\n   * will create a compoundQuery that is an and of the query1, query2, and\n   * query3.\n   *\n   * @param {...Parse.Query} queries The list of queries to AND.\n   * @static\n   * @returns {Parse.Query} The query that is the AND of the passed in queries.\n   */\n  static and() {\n    for (var _len0 = arguments.length, queries = new Array(_len0), _key0 = 0; _key0 < _len0; _key0++) {\n      queries[_key0] = arguments[_key0];\n    }\n    const className = _getClassNameFromQueries(queries);\n    const query = new ParseQuery(className);\n    query._andQuery(queries);\n    return query;\n  }\n\n  /**\n   * Constructs a Parse.Query that is the NOR of the passed in queries.  For\n   * example:\n   * <pre>const compoundQuery = Parse.Query.nor(query1, query2, query3);</pre>\n   *\n   * will create a compoundQuery that is a nor of the query1, query2, and\n   * query3.\n   *\n   * @param {...Parse.Query} queries The list of queries to NOR.\n   * @static\n   * @returns {Parse.Query} The query that is the NOR of the passed in queries.\n   */\n  static nor() {\n    for (var _len1 = arguments.length, queries = new Array(_len1), _key1 = 0; _key1 < _len1; _key1++) {\n      queries[_key1] = arguments[_key1];\n    }\n    const className = _getClassNameFromQueries(queries);\n    const query = new ParseQuery(className);\n    query._norQuery(queries);\n    return query;\n  }\n\n  /**\n   * Change the source of this query to the server.\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  fromNetwork() {\n    this._queriesLocalDatastore = false;\n    this._localDatastorePinName = null;\n    return this;\n  }\n\n  /**\n   * Changes the source of this query to all pinned objects.\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  fromLocalDatastore() {\n    return this.fromPinWithName(null);\n  }\n\n  /**\n   * Changes the source of this query to the default group of pinned objects.\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  fromPin() {\n    return this.fromPinWithName(_LocalDatastoreUtils.DEFAULT_PIN);\n  }\n\n  /**\n   * Changes the source of this query to a specific group of pinned objects.\n   *\n   * @param {string} name The name of query source.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  fromPinWithName(name) {\n    const localDatastore = _CoreManager.default.getLocalDatastore();\n    if (localDatastore.checkIfEnabled()) {\n      this._queriesLocalDatastore = true;\n      this._localDatastorePinName = name;\n    }\n    return this;\n  }\n\n  /**\n   * Cancels the current network request (if any is running).\n   *\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  cancel() {\n    if (this._xhrRequest.task && typeof this._xhrRequest.task.abort === 'function') {\n      this._xhrRequest.task._aborted = true;\n      this._xhrRequest.task.abort();\n      this._xhrRequest.task = null;\n      this._xhrRequest.onchange = () => {};\n      return this;\n    }\n    this._xhrRequest.onchange = () => this.cancel();\n    return this;\n  }\n  _setRequestTask(options) {\n    options.requestTask = task => {\n      this._xhrRequest.task = task;\n      this._xhrRequest.onchange();\n    };\n  }\n\n  /**\n   * Sets a comment to the query so that the query\n   * can be identified when using a the profiler for MongoDB.\n   *\n   * @param {string} value a comment can make your profile data easier to interpret and trace.\n   * @returns {Parse.Query} Returns the query, so you can chain this call.\n   */\n  comment(value) {\n    if (value == null) {\n      delete this._comment;\n      return this;\n    }\n    if (typeof value !== 'string') {\n      throw new Error('The value of a comment to be sent with this query must be a string.');\n    }\n    this._comment = value;\n    return this;\n  }\n}\nconst DefaultController = {\n  find(className, params, options) {\n    const RESTController = _CoreManager.default.getRESTController();\n    return RESTController.request('GET', 'classes/' + className, params, options);\n  },\n  aggregate(className, params, options) {\n    const RESTController = _CoreManager.default.getRESTController();\n    return RESTController.request('GET', 'aggregate/' + className, params, options);\n  }\n};\n_CoreManager.default.setParseQuery(ParseQuery);\n_CoreManager.default.setQueryController(DefaultController);\nvar _default = exports.default = ParseQuery;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}