{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _endsWith = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/ends-with\"));\nvar _slice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\"));\nvar _startsWith = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/starts-with\"));\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/promise\"));\nvar _stringify = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/json/stringify\"));\nvar _includes = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/includes\"));\nvar _forEach = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/for-each\"));\nvar _setTimeout2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/set-timeout\"));\nvar _uuid = _interopRequireDefault(require(\"./uuid\"));\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\nvar _promiseUtils = require(\"./promiseUtils\");\nvar _Xhr = require(\"./Xhr.weapp\");\n/* global XMLHttpRequest, XDomainRequest */\n\nlet useXDomainRequest = false;\n// @ts-ignore\nif (typeof XDomainRequest !== 'undefined' && !('withCredentials' in new XMLHttpRequest())) {\n  useXDomainRequest = true;\n}\nfunction getPath(base, pathname) {\n  if ((0, _endsWith.default)(base).call(base, '/')) {\n    base = (0, _slice.default)(base).call(base, 0, -1);\n  }\n  if (!(0, _startsWith.default)(pathname).call(pathname, '/')) {\n    pathname = '/' + pathname;\n  }\n  return base + pathname;\n}\nfunction ajaxIE9(method, url, data, _headers, options) {\n  return new _promise.default((resolve, reject) => {\n    // @ts-ignore\n    const xdr = new XDomainRequest();\n    xdr.onload = function () {\n      let response;\n      try {\n        response = JSON.parse(xdr.responseText);\n      } catch (e) {\n        reject(e);\n      }\n      if (response) {\n        resolve({\n          response\n        });\n      }\n    };\n    xdr.onerror = xdr.ontimeout = function () {\n      // Let's fake a real error message.\n      const fakeResponse = {\n        responseText: (0, _stringify.default)({\n          code: _ParseError.default.X_DOMAIN_REQUEST,\n          error: \"IE's XDomainRequest does not supply error info.\"\n        })\n      };\n      reject(fakeResponse);\n    };\n    xdr.onprogress = function () {\n      if (options && typeof options.progress === 'function') {\n        options.progress(xdr.responseText);\n      }\n    };\n    xdr.open(method, url);\n    xdr.send(data);\n    // @ts-ignore\n    if (options && typeof options.requestTask === 'function') {\n      // @ts-ignore\n      options.requestTask(xdr);\n    }\n  });\n}\nconst RESTController = {\n  async ajax(method, url, data, headers, options) {\n    var _context;\n    if (useXDomainRequest) {\n      return ajaxIE9(method, url, data, headers, options);\n    }\n    if (typeof fetch !== 'function') {\n      throw new Error('Cannot make a request: Fetch API not found.');\n    }\n    const promise = (0, _promiseUtils.resolvingPromise)();\n    const isIdempotent = _CoreManager.default.get('IDEMPOTENCY') && (0, _includes.default)(_context = ['POST', 'PUT']).call(_context, method);\n    const requestId = isIdempotent ? (0, _uuid.default)() : '';\n    let attempts = 0;\n    const dispatch = async function () {\n      const controller = new AbortController();\n      const {\n        signal\n      } = controller;\n      headers = headers || {};\n      if (typeof headers['Content-Type'] !== 'string') {\n        headers['Content-Type'] = 'text/plain'; // Avoid pre-flight\n      }\n      if (_CoreManager.default.get('IS_NODE')) {\n        headers['User-Agent'] = 'Parse/' + _CoreManager.default.get('VERSION') + ' (NodeJS ' + process.versions.node + ')';\n      }\n      if (isIdempotent) {\n        headers['X-Parse-Request-Id'] = requestId;\n      }\n      const customHeaders = _CoreManager.default.get('REQUEST_HEADERS');\n      for (const key in customHeaders) {\n        headers[key] = customHeaders[key];\n      }\n      // @ts-ignore\n      if (options && typeof options.requestTask === 'function') {\n        // @ts-ignore\n        options.requestTask(controller);\n      }\n      try {\n        var _context3;\n        const fetchOptions = {\n          method,\n          headers,\n          signal,\n          redirect: 'manual'\n        };\n        if (data) {\n          fetchOptions.body = data;\n        }\n        const response = await fetch(url, fetchOptions);\n        const {\n          status\n        } = response;\n        if (status >= 200 && status < 300) {\n          var _context2;\n          let result;\n          const responseHeaders = {};\n          const availableHeaders = response.headers.get('access-control-expose-headers') || '';\n          (0, _forEach.default)(_context2 = availableHeaders.split(', ')).call(_context2, header => {\n            if (header && response.headers.has(header)) {\n              responseHeaders[header] = response.headers.get(header);\n            }\n          });\n          if (options && typeof options.progress === 'function' && response.body) {\n            const reader = response.body.getReader();\n            const length = +response.headers.get('Content-Length') || 0;\n            if (length === 0) {\n              options.progress(null, null, null);\n              result = await response.json();\n            } else {\n              let recieved = 0;\n              const chunks = [];\n              while (true) {\n                const {\n                  done,\n                  value\n                } = await reader.read();\n                if (done) {\n                  break;\n                }\n                chunks.push(value);\n                recieved += value?.length || 0;\n                options.progress(recieved / length, recieved, length);\n              }\n              const body = new Uint8Array(recieved);\n              let offset = 0;\n              for (const chunk of chunks) {\n                body.set(chunk, offset);\n                offset += chunk.length;\n              }\n              const jsonString = new TextDecoder().decode(body);\n              result = JSON.parse(jsonString);\n            }\n          } else {\n            result = await response.json();\n          }\n          promise.resolve({\n            status,\n            response: result,\n            headers: responseHeaders\n          });\n        } else if (status >= 400 && status < 500) {\n          const error = await response.json();\n          promise.reject(error);\n        } else if ((0, _includes.default)(_context3 = [301, 302, 303, 307, 308]).call(_context3, status)) {\n          const location = response.headers.get('location');\n          promise.resolve({\n            status,\n            location,\n            method: status === 303 ? 'GET' : method,\n            dropBody: status === 303\n          });\n        } else if (status >= 500 || status === 0) {\n          // retry on 5XX or library error\n          if (++attempts < _CoreManager.default.get('REQUEST_ATTEMPT_LIMIT')) {\n            // Exponentially-growing random delay\n            const delay = Math.round(Math.random() * 125 * Math.pow(2, attempts));\n            (0, _setTimeout2.default)(dispatch, delay);\n          } else if (status === 0) {\n            promise.reject('Unable to connect to the Parse API');\n          } else {\n            // After the retry limit is reached, fail\n            const error = await response.json();\n            promise.reject(error);\n          }\n        } else {\n          promise.reject(response);\n        }\n      } catch (error) {\n        if (error.name === 'AbortError') {\n          promise.resolve({\n            response: {\n              results: []\n            },\n            status: 0\n          });\n        } else if (error.cause?.code === 'ECONNREFUSED') {\n          promise.reject('Unable to connect to the Parse API');\n        } else {\n          promise.reject(error);\n        }\n      }\n    };\n    dispatch();\n    return promise;\n  },\n  request(method, path, data, options) {\n    options = options || {};\n    const url = getPath(_CoreManager.default.get('SERVER_URL'), path);\n    const payload = {};\n    if (data && typeof data === 'object') {\n      for (const k in data) {\n        payload[k] = data[k];\n      }\n    }\n\n    // Add context\n    const context = options.context;\n    if (context !== undefined) {\n      payload._context = context;\n    }\n    if (method !== 'POST') {\n      payload._method = method;\n      method = 'POST';\n    }\n    payload._ApplicationId = _CoreManager.default.get('APPLICATION_ID');\n    const jsKey = _CoreManager.default.get('JAVASCRIPT_KEY');\n    if (jsKey) {\n      payload._JavaScriptKey = jsKey;\n    }\n    payload._ClientVersion = _CoreManager.default.get('VERSION');\n    let useMasterKey = options.useMasterKey;\n    if (typeof useMasterKey === 'undefined') {\n      useMasterKey = _CoreManager.default.get('USE_MASTER_KEY');\n    }\n    if (useMasterKey) {\n      if (_CoreManager.default.get('MASTER_KEY')) {\n        delete payload._JavaScriptKey;\n        payload._MasterKey = _CoreManager.default.get('MASTER_KEY');\n      } else {\n        throw new Error('Cannot use the Master Key, it has not been provided.');\n      }\n    }\n    if (options.useMaintenanceKey) {\n      payload._MaintenanceKey = _CoreManager.default.get('MAINTENANCE_KEY');\n    }\n    if (_CoreManager.default.get('FORCE_REVOCABLE_SESSION')) {\n      payload._RevocableSession = '1';\n    }\n    const installationId = options.installationId;\n    let installationIdPromise;\n    if (installationId && typeof installationId === 'string') {\n      installationIdPromise = _promise.default.resolve(installationId);\n    } else {\n      const installationController = _CoreManager.default.getInstallationController();\n      installationIdPromise = installationController.currentInstallationId();\n    }\n    return installationIdPromise.then(iid => {\n      payload._InstallationId = iid;\n      const userController = _CoreManager.default.getUserController();\n      if (options && typeof options.sessionToken === 'string') {\n        return _promise.default.resolve(options.sessionToken);\n      } else if (userController) {\n        return userController.currentUserAsync().then(user => {\n          if (user) {\n            return _promise.default.resolve(user.getSessionToken());\n          }\n          return _promise.default.resolve(null);\n        });\n      }\n      return _promise.default.resolve(null);\n    }).then(token => {\n      if (token) {\n        payload._SessionToken = token;\n      }\n      const payloadString = (0, _stringify.default)(payload);\n      return RESTController.ajax(method, url, payloadString, {}, options).then(async result => {\n        if (result.location) {\n          let newURL = getPath(result.location, path);\n          let newMethod = result.method;\n          let newBody = result.dropBody ? undefined : payloadString;\n\n          // Follow up to 5 redirects to avoid loops\n          for (let i = 0; i < 5; i += 1) {\n            const r = await RESTController.ajax(newMethod, newURL, newBody, {}, options);\n            if (!r.location) {\n              result = r;\n              break;\n            }\n            newURL = getPath(r.location, path);\n            newMethod = r.method;\n            newBody = r.dropBody ? undefined : payloadString;\n          }\n        }\n        const {\n          response,\n          status,\n          headers\n        } = result;\n        if (options.returnStatus) {\n          return {\n            ...response,\n            _status: status,\n            _headers: headers\n          };\n        } else {\n          return response;\n        }\n      });\n    }).catch(RESTController.handleError);\n  },\n  handleError(errorJSON) {\n    // Transform the error into an instance of ParseError by trying to parse\n    // the error string as JSON\n    let error;\n    if (errorJSON.code || errorJSON.error || errorJSON.message) {\n      error = new _ParseError.default(errorJSON.code, errorJSON.error || errorJSON.message);\n    } else {\n      error = new _ParseError.default(_ParseError.default.CONNECTION_FAILED, 'XMLHttpRequest failed: ' + (0, _stringify.default)(errorJSON));\n    }\n    return _promise.default.reject(error);\n  }\n};\nvar _default = exports.default = RESTController;","map":{"version":3,"names":["_Object$defineProperty","require","_interopRequireDefault","exports","value","default","_endsWith","_slice","_startsWith","_promise","_stringify","_includes","_forEach","_setTimeout2","_uuid","_CoreManager","_ParseError","_promiseUtils","_Xhr","useXDomainRequest","XDomainRequest","XMLHttpRequest","getPath","base","pathname","call","ajaxIE9","method","url","data","_headers","options","resolve","reject","xdr","onload","response","JSON","parse","responseText","e","onerror","ontimeout","fakeResponse","code","X_DOMAIN_REQUEST","error","onprogress","progress","open","send","requestTask","RESTController","ajax","headers","_context","fetch","Error","promise","resolvingPromise","isIdempotent","get","requestId","attempts","dispatch","controller","AbortController","signal","process","versions","node","customHeaders","key","_context3","fetchOptions","redirect","body","status","_context2","result","responseHeaders","availableHeaders","split","header","has","reader","getReader","length","json","recieved","chunks","done","read","push","Uint8Array","offset","chunk","set","jsonString","TextDecoder","decode","location","dropBody","delay","Math","round","random","pow","name","results","cause","request","path","payload","k","context","undefined","_method","_ApplicationId","jsKey","_JavaScriptKey","_ClientVersion","useMasterKey","_MasterKey","useMaintenanceKey","_MaintenanceKey","_RevocableSession","installationId","installationIdPromise","installationController","getInstallationController","currentInstallationId","then","iid","_InstallationId","userController","getUserController","sessionToken","currentUserAsync","user","getSessionToken","token","_SessionToken","payloadString","newURL","newMethod","newBody","i","r","returnStatus","_status","catch","handleError","errorJSON","message","CONNECTION_FAILED","_default"],"sources":["/home/snx/Desktop/CS_School/node_modules/parse/lib/browser/RESTController.js"],"sourcesContent":["\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _endsWith = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/ends-with\"));\nvar _slice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\"));\nvar _startsWith = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/starts-with\"));\nvar _promise = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/promise\"));\nvar _stringify = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/json/stringify\"));\nvar _includes = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/includes\"));\nvar _forEach = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/for-each\"));\nvar _setTimeout2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/set-timeout\"));\nvar _uuid = _interopRequireDefault(require(\"./uuid\"));\nvar _CoreManager = _interopRequireDefault(require(\"./CoreManager\"));\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\nvar _promiseUtils = require(\"./promiseUtils\");\nvar _Xhr = require(\"./Xhr.weapp\");\n/* global XMLHttpRequest, XDomainRequest */\n\nlet useXDomainRequest = false;\n// @ts-ignore\nif (typeof XDomainRequest !== 'undefined' && !('withCredentials' in new XMLHttpRequest())) {\n  useXDomainRequest = true;\n}\nfunction getPath(base, pathname) {\n  if ((0, _endsWith.default)(base).call(base, '/')) {\n    base = (0, _slice.default)(base).call(base, 0, -1);\n  }\n  if (!(0, _startsWith.default)(pathname).call(pathname, '/')) {\n    pathname = '/' + pathname;\n  }\n  return base + pathname;\n}\nfunction ajaxIE9(method, url, data, _headers, options) {\n  return new _promise.default((resolve, reject) => {\n    // @ts-ignore\n    const xdr = new XDomainRequest();\n    xdr.onload = function () {\n      let response;\n      try {\n        response = JSON.parse(xdr.responseText);\n      } catch (e) {\n        reject(e);\n      }\n      if (response) {\n        resolve({\n          response\n        });\n      }\n    };\n    xdr.onerror = xdr.ontimeout = function () {\n      // Let's fake a real error message.\n      const fakeResponse = {\n        responseText: (0, _stringify.default)({\n          code: _ParseError.default.X_DOMAIN_REQUEST,\n          error: \"IE's XDomainRequest does not supply error info.\"\n        })\n      };\n      reject(fakeResponse);\n    };\n    xdr.onprogress = function () {\n      if (options && typeof options.progress === 'function') {\n        options.progress(xdr.responseText);\n      }\n    };\n    xdr.open(method, url);\n    xdr.send(data);\n    // @ts-ignore\n    if (options && typeof options.requestTask === 'function') {\n      // @ts-ignore\n      options.requestTask(xdr);\n    }\n  });\n}\nconst RESTController = {\n  async ajax(method, url, data, headers, options) {\n    var _context;\n    if (useXDomainRequest) {\n      return ajaxIE9(method, url, data, headers, options);\n    }\n    if (typeof fetch !== 'function') {\n      throw new Error('Cannot make a request: Fetch API not found.');\n    }\n    const promise = (0, _promiseUtils.resolvingPromise)();\n    const isIdempotent = _CoreManager.default.get('IDEMPOTENCY') && (0, _includes.default)(_context = ['POST', 'PUT']).call(_context, method);\n    const requestId = isIdempotent ? (0, _uuid.default)() : '';\n    let attempts = 0;\n    const dispatch = async function () {\n      const controller = new AbortController();\n      const {\n        signal\n      } = controller;\n      headers = headers || {};\n      if (typeof headers['Content-Type'] !== 'string') {\n        headers['Content-Type'] = 'text/plain'; // Avoid pre-flight\n      }\n      if (_CoreManager.default.get('IS_NODE')) {\n        headers['User-Agent'] = 'Parse/' + _CoreManager.default.get('VERSION') + ' (NodeJS ' + process.versions.node + ')';\n      }\n      if (isIdempotent) {\n        headers['X-Parse-Request-Id'] = requestId;\n      }\n      const customHeaders = _CoreManager.default.get('REQUEST_HEADERS');\n      for (const key in customHeaders) {\n        headers[key] = customHeaders[key];\n      }\n      // @ts-ignore\n      if (options && typeof options.requestTask === 'function') {\n        // @ts-ignore\n        options.requestTask(controller);\n      }\n      try {\n        var _context3;\n        const fetchOptions = {\n          method,\n          headers,\n          signal,\n          redirect: 'manual'\n        };\n        if (data) {\n          fetchOptions.body = data;\n        }\n        const response = await fetch(url, fetchOptions);\n        const {\n          status\n        } = response;\n        if (status >= 200 && status < 300) {\n          var _context2;\n          let result;\n          const responseHeaders = {};\n          const availableHeaders = response.headers.get('access-control-expose-headers') || '';\n          (0, _forEach.default)(_context2 = availableHeaders.split(', ')).call(_context2, header => {\n            if (header && response.headers.has(header)) {\n              responseHeaders[header] = response.headers.get(header);\n            }\n          });\n          if (options && typeof options.progress === 'function' && response.body) {\n            const reader = response.body.getReader();\n            const length = +response.headers.get('Content-Length') || 0;\n            if (length === 0) {\n              options.progress(null, null, null);\n              result = await response.json();\n            } else {\n              let recieved = 0;\n              const chunks = [];\n              while (true) {\n                const {\n                  done,\n                  value\n                } = await reader.read();\n                if (done) {\n                  break;\n                }\n                chunks.push(value);\n                recieved += value?.length || 0;\n                options.progress(recieved / length, recieved, length);\n              }\n              const body = new Uint8Array(recieved);\n              let offset = 0;\n              for (const chunk of chunks) {\n                body.set(chunk, offset);\n                offset += chunk.length;\n              }\n              const jsonString = new TextDecoder().decode(body);\n              result = JSON.parse(jsonString);\n            }\n          } else {\n            result = await response.json();\n          }\n          promise.resolve({\n            status,\n            response: result,\n            headers: responseHeaders\n          });\n        } else if (status >= 400 && status < 500) {\n          const error = await response.json();\n          promise.reject(error);\n        } else if ((0, _includes.default)(_context3 = [301, 302, 303, 307, 308]).call(_context3, status)) {\n          const location = response.headers.get('location');\n          promise.resolve({\n            status,\n            location,\n            method: status === 303 ? 'GET' : method,\n            dropBody: status === 303\n          });\n        } else if (status >= 500 || status === 0) {\n          // retry on 5XX or library error\n          if (++attempts < _CoreManager.default.get('REQUEST_ATTEMPT_LIMIT')) {\n            // Exponentially-growing random delay\n            const delay = Math.round(Math.random() * 125 * Math.pow(2, attempts));\n            (0, _setTimeout2.default)(dispatch, delay);\n          } else if (status === 0) {\n            promise.reject('Unable to connect to the Parse API');\n          } else {\n            // After the retry limit is reached, fail\n            const error = await response.json();\n            promise.reject(error);\n          }\n        } else {\n          promise.reject(response);\n        }\n      } catch (error) {\n        if (error.name === 'AbortError') {\n          promise.resolve({\n            response: {\n              results: []\n            },\n            status: 0\n          });\n        } else if (error.cause?.code === 'ECONNREFUSED') {\n          promise.reject('Unable to connect to the Parse API');\n        } else {\n          promise.reject(error);\n        }\n      }\n    };\n    dispatch();\n    return promise;\n  },\n  request(method, path, data, options) {\n    options = options || {};\n    const url = getPath(_CoreManager.default.get('SERVER_URL'), path);\n    const payload = {};\n    if (data && typeof data === 'object') {\n      for (const k in data) {\n        payload[k] = data[k];\n      }\n    }\n\n    // Add context\n    const context = options.context;\n    if (context !== undefined) {\n      payload._context = context;\n    }\n    if (method !== 'POST') {\n      payload._method = method;\n      method = 'POST';\n    }\n    payload._ApplicationId = _CoreManager.default.get('APPLICATION_ID');\n    const jsKey = _CoreManager.default.get('JAVASCRIPT_KEY');\n    if (jsKey) {\n      payload._JavaScriptKey = jsKey;\n    }\n    payload._ClientVersion = _CoreManager.default.get('VERSION');\n    let useMasterKey = options.useMasterKey;\n    if (typeof useMasterKey === 'undefined') {\n      useMasterKey = _CoreManager.default.get('USE_MASTER_KEY');\n    }\n    if (useMasterKey) {\n      if (_CoreManager.default.get('MASTER_KEY')) {\n        delete payload._JavaScriptKey;\n        payload._MasterKey = _CoreManager.default.get('MASTER_KEY');\n      } else {\n        throw new Error('Cannot use the Master Key, it has not been provided.');\n      }\n    }\n    if (options.useMaintenanceKey) {\n      payload._MaintenanceKey = _CoreManager.default.get('MAINTENANCE_KEY');\n    }\n    if (_CoreManager.default.get('FORCE_REVOCABLE_SESSION')) {\n      payload._RevocableSession = '1';\n    }\n    const installationId = options.installationId;\n    let installationIdPromise;\n    if (installationId && typeof installationId === 'string') {\n      installationIdPromise = _promise.default.resolve(installationId);\n    } else {\n      const installationController = _CoreManager.default.getInstallationController();\n      installationIdPromise = installationController.currentInstallationId();\n    }\n    return installationIdPromise.then(iid => {\n      payload._InstallationId = iid;\n      const userController = _CoreManager.default.getUserController();\n      if (options && typeof options.sessionToken === 'string') {\n        return _promise.default.resolve(options.sessionToken);\n      } else if (userController) {\n        return userController.currentUserAsync().then(user => {\n          if (user) {\n            return _promise.default.resolve(user.getSessionToken());\n          }\n          return _promise.default.resolve(null);\n        });\n      }\n      return _promise.default.resolve(null);\n    }).then(token => {\n      if (token) {\n        payload._SessionToken = token;\n      }\n      const payloadString = (0, _stringify.default)(payload);\n      return RESTController.ajax(method, url, payloadString, {}, options).then(async result => {\n        if (result.location) {\n          let newURL = getPath(result.location, path);\n          let newMethod = result.method;\n          let newBody = result.dropBody ? undefined : payloadString;\n\n          // Follow up to 5 redirects to avoid loops\n          for (let i = 0; i < 5; i += 1) {\n            const r = await RESTController.ajax(newMethod, newURL, newBody, {}, options);\n            if (!r.location) {\n              result = r;\n              break;\n            }\n            newURL = getPath(r.location, path);\n            newMethod = r.method;\n            newBody = r.dropBody ? undefined : payloadString;\n          }\n        }\n        const {\n          response,\n          status,\n          headers\n        } = result;\n        if (options.returnStatus) {\n          return {\n            ...response,\n            _status: status,\n            _headers: headers\n          };\n        } else {\n          return response;\n        }\n      });\n    }).catch(RESTController.handleError);\n  },\n  handleError(errorJSON) {\n    // Transform the error into an instance of ParseError by trying to parse\n    // the error string as JSON\n    let error;\n    if (errorJSON.code || errorJSON.error || errorJSON.message) {\n      error = new _ParseError.default(errorJSON.code, errorJSON.error || errorJSON.message);\n    } else {\n      error = new _ParseError.default(_ParseError.default.CONNECTION_FAILED, 'XMLHttpRequest failed: ' + (0, _stringify.default)(errorJSON));\n    }\n    return _promise.default.reject(error);\n  }\n};\nvar _default = exports.default = RESTController;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}