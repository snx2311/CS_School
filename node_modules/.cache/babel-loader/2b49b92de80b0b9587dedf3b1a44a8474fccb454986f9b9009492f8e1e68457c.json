{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _isArray = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\"));\nvar _indexOf = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/index-of\"));\nvar _filter = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/filter\"));\nvar _slice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\"));\nvar _isInteger = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/number/is-integer\"));\nvar _map = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/map\"));\nvar _forEach = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/for-each\"));\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/keys\"));\nvar _equals = _interopRequireDefault(require(\"./equals\"));\nvar _decode = _interopRequireDefault(require(\"./decode\"));\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\nvar _ParsePolygon = _interopRequireDefault(require(\"./ParsePolygon\"));\nvar _ParseGeoPoint = _interopRequireDefault(require(\"./ParseGeoPoint\"));\n/**\n * contains -- Determines if an object is contained in a list with special handling for Parse pointers.\n *\n * @param haystack\n * @param needle\n * @private\n * @returns {boolean}\n */\nfunction contains(haystack, needle) {\n  if (needle && needle.__type && (needle.__type === 'Pointer' || needle.__type === 'Object')) {\n    for (const i in haystack) {\n      const ptr = haystack[i];\n      if (typeof ptr === 'string' && ptr === needle.objectId) {\n        return true;\n      }\n      if (ptr.className === needle.className && ptr.objectId === needle.objectId) {\n        return true;\n      }\n    }\n    return false;\n  }\n  if ((0, _isArray.default)(needle)) {\n    for (const need of needle) {\n      if (contains(haystack, need)) {\n        return true;\n      }\n    }\n  }\n  return (0, _indexOf.default)(haystack).call(haystack, needle) > -1;\n}\nfunction transformObject(object) {\n  if (object._toFullJSON) {\n    return object._toFullJSON();\n  }\n  return object;\n}\n\n/**\n * matchesQuery -- Determines if an object would be returned by a Parse Query\n * It's a lightweight, where-clause only implementation of a full query engine.\n * Since we find queries that match objects, rather than objects that match\n * queries, we can avoid building a full-blown query tool.\n *\n * @param className\n * @param object\n * @param objects\n * @param query\n * @private\n * @returns {boolean}\n */\nfunction matchesQuery(className, object, objects, query) {\n  if (object.className !== className) {\n    return false;\n  }\n  let obj = object;\n  let q = query;\n  if (object.toJSON) {\n    obj = object.toJSON();\n  }\n  if (query.toJSON) {\n    q = query.toJSON().where;\n  }\n  obj.className = className;\n  for (const field in q) {\n    if (!matchesKeyConstraints(className, obj, objects, field, q[field])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction equalObjectsGeneric(obj, compareTo, eqlFn) {\n  if ((0, _isArray.default)(obj)) {\n    for (let i = 0; i < obj.length; i++) {\n      if (eqlFn(obj[i], compareTo)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  return eqlFn(obj, compareTo);\n}\n\n/**\n * @typedef RelativeTimeToDateResult\n * @property {string} status The conversion status, `error` if conversion failed or\n * `success` if conversion succeeded.\n * @property {string} info The error message if conversion failed, or the relative\n * time indication (`past`, `present`, `future`) if conversion succeeded.\n * @property {Date|undefined} result The converted date, or `undefined` if conversion\n * failed.\n */\n/**\n * Converts human readable relative date string, for example, 'in 10 days' to a date\n * relative to now.\n *\n * @param {string} text The text to convert.\n * @param {Date} [now] The date from which add or subtract. Default is now.\n * @returns {RelativeTimeToDateResult}\n */\nfunction relativeTimeToDate(text) {\n  let now = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Date();\n  text = text.toLowerCase();\n  let parts = text.split(' ');\n\n  // Filter out whitespace\n  parts = (0, _filter.default)(parts).call(parts, part => part !== '');\n  const future = parts[0] === 'in';\n  const past = parts[parts.length - 1] === 'ago';\n  if (!future && !past && text !== 'now') {\n    return {\n      status: 'error',\n      info: \"Time should either start with 'in' or end with 'ago'\"\n    };\n  }\n  if (future && past) {\n    return {\n      status: 'error',\n      info: \"Time cannot have both 'in' and 'ago'\"\n    };\n  }\n\n  // strip the 'ago' or 'in'\n  if (future) {\n    parts = (0, _slice.default)(parts).call(parts, 1);\n  } else {\n    // past\n    parts = (0, _slice.default)(parts).call(parts, 0, parts.length - 1);\n  }\n  if (parts.length % 2 !== 0 && text !== 'now') {\n    return {\n      status: 'error',\n      info: 'Invalid time string. Dangling unit or number.'\n    };\n  }\n  const pairs = [];\n  while (parts.length) {\n    pairs.push([parts.shift(), parts.shift()]);\n  }\n  let seconds = 0;\n  for (const [num, interval] of pairs) {\n    const val = Number(num);\n    if (!(0, _isInteger.default)(val)) {\n      return {\n        status: 'error',\n        info: `'${num}' is not an integer.`\n      };\n    }\n    switch (interval) {\n      case 'yr':\n      case 'yrs':\n      case 'year':\n      case 'years':\n        seconds += val * 31536000; // 365 * 24 * 60 * 60\n        break;\n      case 'wk':\n      case 'wks':\n      case 'week':\n      case 'weeks':\n        seconds += val * 604800; // 7 * 24 * 60 * 60\n        break;\n      case 'd':\n      case 'day':\n      case 'days':\n        seconds += val * 86400; // 24 * 60 * 60\n        break;\n      case 'hr':\n      case 'hrs':\n      case 'hour':\n      case 'hours':\n        seconds += val * 3600; // 60 * 60\n        break;\n      case 'min':\n      case 'mins':\n      case 'minute':\n      case 'minutes':\n        seconds += val * 60;\n        break;\n      case 'sec':\n      case 'secs':\n      case 'second':\n      case 'seconds':\n        seconds += val;\n        break;\n      default:\n        return {\n          status: 'error',\n          info: `Invalid interval: '${interval}'`\n        };\n    }\n  }\n  const milliseconds = seconds * 1000;\n  if (future) {\n    return {\n      status: 'success',\n      info: 'future',\n      result: new Date(now.valueOf() + milliseconds)\n    };\n  } else if (past) {\n    return {\n      status: 'success',\n      info: 'past',\n      result: new Date(now.valueOf() - milliseconds)\n    };\n  } else {\n    return {\n      status: 'success',\n      info: 'present',\n      result: new Date(now.valueOf())\n    };\n  }\n}\n\n/**\n * Determines whether an object matches a single key's constraints\n *\n * @param className\n * @param object\n * @param objects\n * @param key\n * @param constraints\n * @private\n * @returns {boolean}\n */\nfunction matchesKeyConstraints(className, object, objects, key, constraints) {\n  if (constraints === null) {\n    return false;\n  }\n  if ((0, _indexOf.default)(key).call(key, '.') >= 0) {\n    // Key references a subobject\n    const keyComponents = key.split('.');\n    const subObjectKey = keyComponents[0];\n    const keyRemainder = (0, _slice.default)(keyComponents).call(keyComponents, 1).join('.');\n    return matchesKeyConstraints(className, object[subObjectKey] || {}, objects, keyRemainder, constraints);\n  }\n  let i;\n  if (key === '$or') {\n    for (i = 0; i < constraints.length; i++) {\n      if (matchesQuery(className, object, objects, constraints[i])) {\n        return true;\n      }\n    }\n    return false;\n  }\n  if (key === '$and') {\n    for (i = 0; i < constraints.length; i++) {\n      if (!matchesQuery(className, object, objects, constraints[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  if (key === '$nor') {\n    for (i = 0; i < constraints.length; i++) {\n      if (matchesQuery(className, object, objects, constraints[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  if (key === '$relatedTo') {\n    // Bail! We can't handle relational queries locally\n    return false;\n  }\n  if (!/^[A-Za-z][0-9A-Za-z_]*$/.test(key)) {\n    throw new _ParseError.default(_ParseError.default.INVALID_KEY_NAME, `Invalid Key: ${key}`);\n  }\n  // Equality (or Array contains) cases\n  if (typeof constraints !== 'object') {\n    if ((0, _isArray.default)(object[key])) {\n      var _context;\n      return (0, _indexOf.default)(_context = object[key]).call(_context, constraints) > -1;\n    }\n    return object[key] === constraints;\n  }\n  let compareTo;\n  if (constraints.__type) {\n    if (constraints.__type === 'Pointer') {\n      return equalObjectsGeneric(object[key], constraints, function (obj, ptr) {\n        return typeof obj !== 'undefined' && ptr.className === obj.className && ptr.objectId === obj.objectId;\n      });\n    }\n    return equalObjectsGeneric((0, _decode.default)(object[key]), (0, _decode.default)(constraints), _equals.default);\n  }\n  // More complex cases\n  for (const condition in constraints) {\n    compareTo = constraints[condition];\n    if (compareTo?.__type) {\n      compareTo = (0, _decode.default)(compareTo);\n    }\n    // is it a $relativeTime? convert to date\n    if (compareTo?.['$relativeTime']) {\n      const parserResult = relativeTimeToDate(compareTo['$relativeTime']);\n      if (parserResult.status !== 'success') {\n        throw new _ParseError.default(_ParseError.default.INVALID_JSON, `bad $relativeTime (${key}) value. ${parserResult.info}`);\n      }\n      compareTo = parserResult.result;\n    }\n    // Compare Date Object or Date String\n    if (toString.call(compareTo) === '[object Date]' || typeof compareTo === 'string' && new Date(compareTo).toString() !== 'Invalid Date') {\n      object[key] = new Date(object[key].iso ? object[key].iso : object[key]);\n    }\n    switch (condition) {\n      case '$lt':\n        if (object[key] >= compareTo) {\n          return false;\n        }\n        break;\n      case '$lte':\n        if (object[key] > compareTo) {\n          return false;\n        }\n        break;\n      case '$gt':\n        if (object[key] <= compareTo) {\n          return false;\n        }\n        break;\n      case '$gte':\n        if (object[key] < compareTo) {\n          return false;\n        }\n        break;\n      case '$ne':\n        if ((0, _equals.default)(object[key], compareTo)) {\n          return false;\n        }\n        break;\n      case '$in':\n        if (!contains(compareTo, object[key])) {\n          return false;\n        }\n        break;\n      case '$nin':\n        if (contains(compareTo, object[key])) {\n          return false;\n        }\n        break;\n      case '$all':\n        for (i = 0; i < compareTo.length; i++) {\n          var _context2;\n          if ((0, _indexOf.default)(_context2 = object[key]).call(_context2, compareTo[i]) < 0) {\n            return false;\n          }\n        }\n        break;\n      case '$exists':\n        {\n          const propertyExists = typeof object[key] !== 'undefined';\n          const existenceIsRequired = constraints['$exists'];\n          if (typeof constraints['$exists'] !== 'boolean') {\n            // The SDK will never submit a non-boolean for $exists, but if someone\n            // tries to submit a non-boolean for $exits outside the SDKs, just ignore it.\n            break;\n          }\n          if (!propertyExists && existenceIsRequired || propertyExists && !existenceIsRequired) {\n            return false;\n          }\n          break;\n        }\n      case '$regex':\n        {\n          if (typeof compareTo === 'object') {\n            return compareTo.test(object[key]);\n          }\n          // JS doesn't support perl-style escaping\n          let expString = '';\n          let escapeEnd = -2;\n          let escapeStart = (0, _indexOf.default)(compareTo).call(compareTo, '\\\\Q');\n          while (escapeStart > -1) {\n            // Add the unescaped portion\n            expString += compareTo.substring(escapeEnd + 2, escapeStart);\n            escapeEnd = (0, _indexOf.default)(compareTo).call(compareTo, '\\\\E', escapeStart);\n            if (escapeEnd > -1) {\n              expString += compareTo.substring(escapeStart + 2, escapeEnd).replace(/\\\\\\\\\\\\\\\\E/g, '\\\\E').replace(/\\W/g, '\\\\$&');\n            }\n            escapeStart = (0, _indexOf.default)(compareTo).call(compareTo, '\\\\Q', escapeEnd);\n          }\n          expString += compareTo.substring(Math.max(escapeStart, escapeEnd + 2));\n          let modifiers = constraints.$options || '';\n          modifiers = modifiers.replace('x', '').replace('s', '');\n          // Parse Server / Mongo support x and s modifiers but JS RegExp doesn't\n          const exp = new RegExp(expString, modifiers);\n          if (!exp.test(object[key])) {\n            return false;\n          }\n          break;\n        }\n      case '$nearSphere':\n        {\n          if (!compareTo || !object[key]) {\n            return false;\n          }\n          const distance = compareTo.radiansTo(object[key]);\n          const max = constraints.$maxDistance || Infinity;\n          return distance <= max;\n        }\n      case '$within':\n        {\n          if (!compareTo || !object[key]) {\n            return false;\n          }\n          const southWest = compareTo.$box[0];\n          const northEast = compareTo.$box[1];\n          if (southWest.latitude > northEast.latitude || southWest.longitude > northEast.longitude) {\n            // Invalid box, crosses the date line\n            return false;\n          }\n          return object[key].latitude > southWest.latitude && object[key].latitude < northEast.latitude && object[key].longitude > southWest.longitude && object[key].longitude < northEast.longitude;\n        }\n      case '$options':\n        // Not a query type, but a way to add options to $regex. Ignore and\n        // avoid the default\n        break;\n      case '$maxDistance':\n        // Not a query type, but a way to add a cap to $nearSphere. Ignore and\n        // avoid the default\n        break;\n      case '$select':\n        {\n          const subQueryObjects = (0, _filter.default)(objects).call(objects, (obj, _index, arr) => {\n            return matchesQuery(compareTo.query.className, obj, arr, compareTo.query.where);\n          });\n          for (let i = 0; i < subQueryObjects.length; i += 1) {\n            const subObject = transformObject(subQueryObjects[i]);\n            return (0, _equals.default)(object[key], subObject[compareTo.key]);\n          }\n          return false;\n        }\n      case '$dontSelect':\n        {\n          const subQueryObjects = (0, _filter.default)(objects).call(objects, (obj, _index, arr) => {\n            return matchesQuery(compareTo.query.className, obj, arr, compareTo.query.where);\n          });\n          for (let i = 0; i < subQueryObjects.length; i += 1) {\n            const subObject = transformObject(subQueryObjects[i]);\n            return !(0, _equals.default)(object[key], subObject[compareTo.key]);\n          }\n          return false;\n        }\n      case '$inQuery':\n        {\n          const subQueryObjects = (0, _filter.default)(objects).call(objects, (obj, _index, arr) => {\n            return matchesQuery(compareTo.className, obj, arr, compareTo.where);\n          });\n          for (let i = 0; i < subQueryObjects.length; i += 1) {\n            const subObject = transformObject(subQueryObjects[i]);\n            if (object[key].className === subObject.className && object[key].objectId === subObject.objectId) {\n              return true;\n            }\n          }\n          return false;\n        }\n      case '$notInQuery':\n        {\n          const subQueryObjects = (0, _filter.default)(objects).call(objects, (obj, _index, arr) => {\n            return matchesQuery(compareTo.className, obj, arr, compareTo.where);\n          });\n          for (let i = 0; i < subQueryObjects.length; i += 1) {\n            const subObject = transformObject(subQueryObjects[i]);\n            if (object[key].className === subObject.className && object[key].objectId === subObject.objectId) {\n              return false;\n            }\n          }\n          return true;\n        }\n      case '$containedBy':\n        {\n          for (const value of object[key]) {\n            if (!contains(compareTo, value)) {\n              return false;\n            }\n          }\n          return true;\n        }\n      case '$geoWithin':\n        {\n          if (compareTo.$polygon) {\n            var _context3;\n            const points = (0, _map.default)(_context3 = compareTo.$polygon).call(_context3, geoPoint => [geoPoint.latitude, geoPoint.longitude]);\n            const polygon = new _ParsePolygon.default(points);\n            return polygon.containsPoint(object[key]);\n          }\n          if (compareTo.$centerSphere) {\n            const [WGS84Point, maxDistance] = compareTo.$centerSphere;\n            const centerPoint = new _ParseGeoPoint.default({\n              latitude: WGS84Point[1],\n              longitude: WGS84Point[0]\n            });\n            const point = new _ParseGeoPoint.default(object[key]);\n            const distance = point.radiansTo(centerPoint);\n            return distance <= maxDistance;\n          }\n          return false;\n        }\n      case '$geoIntersects':\n        {\n          const polygon = new _ParsePolygon.default(object[key].coordinates);\n          const point = new _ParseGeoPoint.default(compareTo.$point);\n          return polygon.containsPoint(point);\n        }\n      default:\n        return false;\n    }\n  }\n  return true;\n}\nfunction validateQuery(query) {\n  var _context4;\n  let q = query;\n  if (query.toJSON) {\n    q = query.toJSON().where;\n  }\n  const specialQuerykeys = ['$and', '$or', '$nor', '_rperm', '_wperm', '_perishable_token', '_email_verify_token', '_email_verify_token_expires_at', '_account_lockout_expires_at', '_failed_login_count'];\n  (0, _forEach.default)(_context4 = (0, _keys.default)(q)).call(_context4, key => {\n    if (q && q[key] && q[key].$regex) {\n      if (typeof q[key].$options === 'string') {\n        if (!q[key].$options.match(/^[imxs]+$/)) {\n          throw new _ParseError.default(_ParseError.default.INVALID_QUERY, `Bad $options value for query: ${q[key].$options}`);\n        }\n      }\n    }\n    if ((0, _indexOf.default)(specialQuerykeys).call(specialQuerykeys, key) < 0 && !key.match(/^[a-zA-Z][a-zA-Z0-9_\\.]*$/)) {\n      throw new _ParseError.default(_ParseError.default.INVALID_KEY_NAME, `Invalid key name: ${key}`);\n    }\n  });\n}\nconst OfflineQuery = {\n  matchesQuery: matchesQuery,\n  validateQuery: validateQuery\n};\nvar _default = exports.default = OfflineQuery;","map":{"version":3,"names":["_Object$defineProperty","require","_interopRequireDefault","exports","value","default","_isArray","_indexOf","_filter","_slice","_isInteger","_map","_forEach","_keys","_equals","_decode","_ParseError","_ParsePolygon","_ParseGeoPoint","contains","haystack","needle","__type","i","ptr","objectId","className","need","call","transformObject","object","_toFullJSON","matchesQuery","objects","query","obj","q","toJSON","where","field","matchesKeyConstraints","equalObjectsGeneric","compareTo","eqlFn","length","relativeTimeToDate","text","now","arguments","undefined","Date","toLowerCase","parts","split","part","future","past","status","info","pairs","push","shift","seconds","num","interval","val","Number","milliseconds","result","valueOf","key","constraints","keyComponents","subObjectKey","keyRemainder","join","test","INVALID_KEY_NAME","_context","condition","parserResult","INVALID_JSON","toString","iso","_context2","propertyExists","existenceIsRequired","expString","escapeEnd","escapeStart","substring","replace","Math","max","modifiers","$options","exp","RegExp","distance","radiansTo","$maxDistance","Infinity","southWest","$box","northEast","latitude","longitude","subQueryObjects","_index","arr","subObject","$polygon","_context3","points","geoPoint","polygon","containsPoint","$centerSphere","WGS84Point","maxDistance","centerPoint","point","coordinates","$point","validateQuery","_context4","specialQuerykeys","$regex","match","INVALID_QUERY","OfflineQuery","_default"],"sources":["/home/snx/Desktop/CS_School/node_modules/parse/lib/browser/OfflineQuery.js"],"sourcesContent":["\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _isArray = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\"));\nvar _indexOf = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/index-of\"));\nvar _filter = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/filter\"));\nvar _slice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\"));\nvar _isInteger = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/number/is-integer\"));\nvar _map = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/map\"));\nvar _forEach = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/for-each\"));\nvar _keys = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/object/keys\"));\nvar _equals = _interopRequireDefault(require(\"./equals\"));\nvar _decode = _interopRequireDefault(require(\"./decode\"));\nvar _ParseError = _interopRequireDefault(require(\"./ParseError\"));\nvar _ParsePolygon = _interopRequireDefault(require(\"./ParsePolygon\"));\nvar _ParseGeoPoint = _interopRequireDefault(require(\"./ParseGeoPoint\"));\n/**\n * contains -- Determines if an object is contained in a list with special handling for Parse pointers.\n *\n * @param haystack\n * @param needle\n * @private\n * @returns {boolean}\n */\nfunction contains(haystack, needle) {\n  if (needle && needle.__type && (needle.__type === 'Pointer' || needle.__type === 'Object')) {\n    for (const i in haystack) {\n      const ptr = haystack[i];\n      if (typeof ptr === 'string' && ptr === needle.objectId) {\n        return true;\n      }\n      if (ptr.className === needle.className && ptr.objectId === needle.objectId) {\n        return true;\n      }\n    }\n    return false;\n  }\n  if ((0, _isArray.default)(needle)) {\n    for (const need of needle) {\n      if (contains(haystack, need)) {\n        return true;\n      }\n    }\n  }\n  return (0, _indexOf.default)(haystack).call(haystack, needle) > -1;\n}\nfunction transformObject(object) {\n  if (object._toFullJSON) {\n    return object._toFullJSON();\n  }\n  return object;\n}\n\n/**\n * matchesQuery -- Determines if an object would be returned by a Parse Query\n * It's a lightweight, where-clause only implementation of a full query engine.\n * Since we find queries that match objects, rather than objects that match\n * queries, we can avoid building a full-blown query tool.\n *\n * @param className\n * @param object\n * @param objects\n * @param query\n * @private\n * @returns {boolean}\n */\nfunction matchesQuery(className, object, objects, query) {\n  if (object.className !== className) {\n    return false;\n  }\n  let obj = object;\n  let q = query;\n  if (object.toJSON) {\n    obj = object.toJSON();\n  }\n  if (query.toJSON) {\n    q = query.toJSON().where;\n  }\n  obj.className = className;\n  for (const field in q) {\n    if (!matchesKeyConstraints(className, obj, objects, field, q[field])) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction equalObjectsGeneric(obj, compareTo, eqlFn) {\n  if ((0, _isArray.default)(obj)) {\n    for (let i = 0; i < obj.length; i++) {\n      if (eqlFn(obj[i], compareTo)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  return eqlFn(obj, compareTo);\n}\n\n/**\n * @typedef RelativeTimeToDateResult\n * @property {string} status The conversion status, `error` if conversion failed or\n * `success` if conversion succeeded.\n * @property {string} info The error message if conversion failed, or the relative\n * time indication (`past`, `present`, `future`) if conversion succeeded.\n * @property {Date|undefined} result The converted date, or `undefined` if conversion\n * failed.\n */\n/**\n * Converts human readable relative date string, for example, 'in 10 days' to a date\n * relative to now.\n *\n * @param {string} text The text to convert.\n * @param {Date} [now] The date from which add or subtract. Default is now.\n * @returns {RelativeTimeToDateResult}\n */\nfunction relativeTimeToDate(text) {\n  let now = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Date();\n  text = text.toLowerCase();\n  let parts = text.split(' ');\n\n  // Filter out whitespace\n  parts = (0, _filter.default)(parts).call(parts, part => part !== '');\n  const future = parts[0] === 'in';\n  const past = parts[parts.length - 1] === 'ago';\n  if (!future && !past && text !== 'now') {\n    return {\n      status: 'error',\n      info: \"Time should either start with 'in' or end with 'ago'\"\n    };\n  }\n  if (future && past) {\n    return {\n      status: 'error',\n      info: \"Time cannot have both 'in' and 'ago'\"\n    };\n  }\n\n  // strip the 'ago' or 'in'\n  if (future) {\n    parts = (0, _slice.default)(parts).call(parts, 1);\n  } else {\n    // past\n    parts = (0, _slice.default)(parts).call(parts, 0, parts.length - 1);\n  }\n  if (parts.length % 2 !== 0 && text !== 'now') {\n    return {\n      status: 'error',\n      info: 'Invalid time string. Dangling unit or number.'\n    };\n  }\n  const pairs = [];\n  while (parts.length) {\n    pairs.push([parts.shift(), parts.shift()]);\n  }\n  let seconds = 0;\n  for (const [num, interval] of pairs) {\n    const val = Number(num);\n    if (!(0, _isInteger.default)(val)) {\n      return {\n        status: 'error',\n        info: `'${num}' is not an integer.`\n      };\n    }\n    switch (interval) {\n      case 'yr':\n      case 'yrs':\n      case 'year':\n      case 'years':\n        seconds += val * 31536000; // 365 * 24 * 60 * 60\n        break;\n      case 'wk':\n      case 'wks':\n      case 'week':\n      case 'weeks':\n        seconds += val * 604800; // 7 * 24 * 60 * 60\n        break;\n      case 'd':\n      case 'day':\n      case 'days':\n        seconds += val * 86400; // 24 * 60 * 60\n        break;\n      case 'hr':\n      case 'hrs':\n      case 'hour':\n      case 'hours':\n        seconds += val * 3600; // 60 * 60\n        break;\n      case 'min':\n      case 'mins':\n      case 'minute':\n      case 'minutes':\n        seconds += val * 60;\n        break;\n      case 'sec':\n      case 'secs':\n      case 'second':\n      case 'seconds':\n        seconds += val;\n        break;\n      default:\n        return {\n          status: 'error',\n          info: `Invalid interval: '${interval}'`\n        };\n    }\n  }\n  const milliseconds = seconds * 1000;\n  if (future) {\n    return {\n      status: 'success',\n      info: 'future',\n      result: new Date(now.valueOf() + milliseconds)\n    };\n  } else if (past) {\n    return {\n      status: 'success',\n      info: 'past',\n      result: new Date(now.valueOf() - milliseconds)\n    };\n  } else {\n    return {\n      status: 'success',\n      info: 'present',\n      result: new Date(now.valueOf())\n    };\n  }\n}\n\n/**\n * Determines whether an object matches a single key's constraints\n *\n * @param className\n * @param object\n * @param objects\n * @param key\n * @param constraints\n * @private\n * @returns {boolean}\n */\nfunction matchesKeyConstraints(className, object, objects, key, constraints) {\n  if (constraints === null) {\n    return false;\n  }\n  if ((0, _indexOf.default)(key).call(key, '.') >= 0) {\n    // Key references a subobject\n    const keyComponents = key.split('.');\n    const subObjectKey = keyComponents[0];\n    const keyRemainder = (0, _slice.default)(keyComponents).call(keyComponents, 1).join('.');\n    return matchesKeyConstraints(className, object[subObjectKey] || {}, objects, keyRemainder, constraints);\n  }\n  let i;\n  if (key === '$or') {\n    for (i = 0; i < constraints.length; i++) {\n      if (matchesQuery(className, object, objects, constraints[i])) {\n        return true;\n      }\n    }\n    return false;\n  }\n  if (key === '$and') {\n    for (i = 0; i < constraints.length; i++) {\n      if (!matchesQuery(className, object, objects, constraints[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  if (key === '$nor') {\n    for (i = 0; i < constraints.length; i++) {\n      if (matchesQuery(className, object, objects, constraints[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  if (key === '$relatedTo') {\n    // Bail! We can't handle relational queries locally\n    return false;\n  }\n  if (!/^[A-Za-z][0-9A-Za-z_]*$/.test(key)) {\n    throw new _ParseError.default(_ParseError.default.INVALID_KEY_NAME, `Invalid Key: ${key}`);\n  }\n  // Equality (or Array contains) cases\n  if (typeof constraints !== 'object') {\n    if ((0, _isArray.default)(object[key])) {\n      var _context;\n      return (0, _indexOf.default)(_context = object[key]).call(_context, constraints) > -1;\n    }\n    return object[key] === constraints;\n  }\n  let compareTo;\n  if (constraints.__type) {\n    if (constraints.__type === 'Pointer') {\n      return equalObjectsGeneric(object[key], constraints, function (obj, ptr) {\n        return typeof obj !== 'undefined' && ptr.className === obj.className && ptr.objectId === obj.objectId;\n      });\n    }\n    return equalObjectsGeneric((0, _decode.default)(object[key]), (0, _decode.default)(constraints), _equals.default);\n  }\n  // More complex cases\n  for (const condition in constraints) {\n    compareTo = constraints[condition];\n    if (compareTo?.__type) {\n      compareTo = (0, _decode.default)(compareTo);\n    }\n    // is it a $relativeTime? convert to date\n    if (compareTo?.['$relativeTime']) {\n      const parserResult = relativeTimeToDate(compareTo['$relativeTime']);\n      if (parserResult.status !== 'success') {\n        throw new _ParseError.default(_ParseError.default.INVALID_JSON, `bad $relativeTime (${key}) value. ${parserResult.info}`);\n      }\n      compareTo = parserResult.result;\n    }\n    // Compare Date Object or Date String\n    if (toString.call(compareTo) === '[object Date]' || typeof compareTo === 'string' && new Date(compareTo).toString() !== 'Invalid Date') {\n      object[key] = new Date(object[key].iso ? object[key].iso : object[key]);\n    }\n    switch (condition) {\n      case '$lt':\n        if (object[key] >= compareTo) {\n          return false;\n        }\n        break;\n      case '$lte':\n        if (object[key] > compareTo) {\n          return false;\n        }\n        break;\n      case '$gt':\n        if (object[key] <= compareTo) {\n          return false;\n        }\n        break;\n      case '$gte':\n        if (object[key] < compareTo) {\n          return false;\n        }\n        break;\n      case '$ne':\n        if ((0, _equals.default)(object[key], compareTo)) {\n          return false;\n        }\n        break;\n      case '$in':\n        if (!contains(compareTo, object[key])) {\n          return false;\n        }\n        break;\n      case '$nin':\n        if (contains(compareTo, object[key])) {\n          return false;\n        }\n        break;\n      case '$all':\n        for (i = 0; i < compareTo.length; i++) {\n          var _context2;\n          if ((0, _indexOf.default)(_context2 = object[key]).call(_context2, compareTo[i]) < 0) {\n            return false;\n          }\n        }\n        break;\n      case '$exists':\n        {\n          const propertyExists = typeof object[key] !== 'undefined';\n          const existenceIsRequired = constraints['$exists'];\n          if (typeof constraints['$exists'] !== 'boolean') {\n            // The SDK will never submit a non-boolean for $exists, but if someone\n            // tries to submit a non-boolean for $exits outside the SDKs, just ignore it.\n            break;\n          }\n          if (!propertyExists && existenceIsRequired || propertyExists && !existenceIsRequired) {\n            return false;\n          }\n          break;\n        }\n      case '$regex':\n        {\n          if (typeof compareTo === 'object') {\n            return compareTo.test(object[key]);\n          }\n          // JS doesn't support perl-style escaping\n          let expString = '';\n          let escapeEnd = -2;\n          let escapeStart = (0, _indexOf.default)(compareTo).call(compareTo, '\\\\Q');\n          while (escapeStart > -1) {\n            // Add the unescaped portion\n            expString += compareTo.substring(escapeEnd + 2, escapeStart);\n            escapeEnd = (0, _indexOf.default)(compareTo).call(compareTo, '\\\\E', escapeStart);\n            if (escapeEnd > -1) {\n              expString += compareTo.substring(escapeStart + 2, escapeEnd).replace(/\\\\\\\\\\\\\\\\E/g, '\\\\E').replace(/\\W/g, '\\\\$&');\n            }\n            escapeStart = (0, _indexOf.default)(compareTo).call(compareTo, '\\\\Q', escapeEnd);\n          }\n          expString += compareTo.substring(Math.max(escapeStart, escapeEnd + 2));\n          let modifiers = constraints.$options || '';\n          modifiers = modifiers.replace('x', '').replace('s', '');\n          // Parse Server / Mongo support x and s modifiers but JS RegExp doesn't\n          const exp = new RegExp(expString, modifiers);\n          if (!exp.test(object[key])) {\n            return false;\n          }\n          break;\n        }\n      case '$nearSphere':\n        {\n          if (!compareTo || !object[key]) {\n            return false;\n          }\n          const distance = compareTo.radiansTo(object[key]);\n          const max = constraints.$maxDistance || Infinity;\n          return distance <= max;\n        }\n      case '$within':\n        {\n          if (!compareTo || !object[key]) {\n            return false;\n          }\n          const southWest = compareTo.$box[0];\n          const northEast = compareTo.$box[1];\n          if (southWest.latitude > northEast.latitude || southWest.longitude > northEast.longitude) {\n            // Invalid box, crosses the date line\n            return false;\n          }\n          return object[key].latitude > southWest.latitude && object[key].latitude < northEast.latitude && object[key].longitude > southWest.longitude && object[key].longitude < northEast.longitude;\n        }\n      case '$options':\n        // Not a query type, but a way to add options to $regex. Ignore and\n        // avoid the default\n        break;\n      case '$maxDistance':\n        // Not a query type, but a way to add a cap to $nearSphere. Ignore and\n        // avoid the default\n        break;\n      case '$select':\n        {\n          const subQueryObjects = (0, _filter.default)(objects).call(objects, (obj, _index, arr) => {\n            return matchesQuery(compareTo.query.className, obj, arr, compareTo.query.where);\n          });\n          for (let i = 0; i < subQueryObjects.length; i += 1) {\n            const subObject = transformObject(subQueryObjects[i]);\n            return (0, _equals.default)(object[key], subObject[compareTo.key]);\n          }\n          return false;\n        }\n      case '$dontSelect':\n        {\n          const subQueryObjects = (0, _filter.default)(objects).call(objects, (obj, _index, arr) => {\n            return matchesQuery(compareTo.query.className, obj, arr, compareTo.query.where);\n          });\n          for (let i = 0; i < subQueryObjects.length; i += 1) {\n            const subObject = transformObject(subQueryObjects[i]);\n            return !(0, _equals.default)(object[key], subObject[compareTo.key]);\n          }\n          return false;\n        }\n      case '$inQuery':\n        {\n          const subQueryObjects = (0, _filter.default)(objects).call(objects, (obj, _index, arr) => {\n            return matchesQuery(compareTo.className, obj, arr, compareTo.where);\n          });\n          for (let i = 0; i < subQueryObjects.length; i += 1) {\n            const subObject = transformObject(subQueryObjects[i]);\n            if (object[key].className === subObject.className && object[key].objectId === subObject.objectId) {\n              return true;\n            }\n          }\n          return false;\n        }\n      case '$notInQuery':\n        {\n          const subQueryObjects = (0, _filter.default)(objects).call(objects, (obj, _index, arr) => {\n            return matchesQuery(compareTo.className, obj, arr, compareTo.where);\n          });\n          for (let i = 0; i < subQueryObjects.length; i += 1) {\n            const subObject = transformObject(subQueryObjects[i]);\n            if (object[key].className === subObject.className && object[key].objectId === subObject.objectId) {\n              return false;\n            }\n          }\n          return true;\n        }\n      case '$containedBy':\n        {\n          for (const value of object[key]) {\n            if (!contains(compareTo, value)) {\n              return false;\n            }\n          }\n          return true;\n        }\n      case '$geoWithin':\n        {\n          if (compareTo.$polygon) {\n            var _context3;\n            const points = (0, _map.default)(_context3 = compareTo.$polygon).call(_context3, geoPoint => [geoPoint.latitude, geoPoint.longitude]);\n            const polygon = new _ParsePolygon.default(points);\n            return polygon.containsPoint(object[key]);\n          }\n          if (compareTo.$centerSphere) {\n            const [WGS84Point, maxDistance] = compareTo.$centerSphere;\n            const centerPoint = new _ParseGeoPoint.default({\n              latitude: WGS84Point[1],\n              longitude: WGS84Point[0]\n            });\n            const point = new _ParseGeoPoint.default(object[key]);\n            const distance = point.radiansTo(centerPoint);\n            return distance <= maxDistance;\n          }\n          return false;\n        }\n      case '$geoIntersects':\n        {\n          const polygon = new _ParsePolygon.default(object[key].coordinates);\n          const point = new _ParseGeoPoint.default(compareTo.$point);\n          return polygon.containsPoint(point);\n        }\n      default:\n        return false;\n    }\n  }\n  return true;\n}\nfunction validateQuery(query) {\n  var _context4;\n  let q = query;\n  if (query.toJSON) {\n    q = query.toJSON().where;\n  }\n  const specialQuerykeys = ['$and', '$or', '$nor', '_rperm', '_wperm', '_perishable_token', '_email_verify_token', '_email_verify_token_expires_at', '_account_lockout_expires_at', '_failed_login_count'];\n  (0, _forEach.default)(_context4 = (0, _keys.default)(q)).call(_context4, key => {\n    if (q && q[key] && q[key].$regex) {\n      if (typeof q[key].$options === 'string') {\n        if (!q[key].$options.match(/^[imxs]+$/)) {\n          throw new _ParseError.default(_ParseError.default.INVALID_QUERY, `Bad $options value for query: ${q[key].$options}`);\n        }\n      }\n    }\n    if ((0, _indexOf.default)(specialQuerykeys).call(specialQuerykeys, key) < 0 && !key.match(/^[a-zA-Z][a-zA-Z0-9_\\.]*$/)) {\n      throw new _ParseError.default(_ParseError.default.INVALID_KEY_NAME, `Invalid key name: ${key}`);\n    }\n  });\n}\nconst OfflineQuery = {\n  matchesQuery: matchesQuery,\n  validateQuery: validateQuery\n};\nvar _default = exports.default = OfflineQuery;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}